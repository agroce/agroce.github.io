<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>PLAI Version 3.2.2</title></head><body><div class="c" id="calibre_link-281"><p class="c1" id="calibre_link-381"><span class="c2">Programming Languages:<br class="calibre" />Application and Interpretation</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre1"><img alt="" src="images/000009.jpg" title="" class="calibre2" /></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c5" id="calibre_link-382"><span class="calibre3">Shriram Krishnamurthi<br class="calibre" /></span><span class="c6">Brown University</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="c8">Version 3.2.2, </span><span class="c8">2023-02-26</span><span class="c8">, © Shriram Krishnamurthi, </span><span class="c9"><a class="c10" href="https://www.google.com/url?q=http://creativecommons.org/licenses/by-nc-sa/4.0/&amp;sa=D&amp;source=editors&amp;ust=1695232021031104&amp;usg=AOvVaw39CIzlQ6Ssn3mDrdwrMpCt">CC-BY-NC-SA 4.0</a></span><span class="c8">.<br class="calibre" /></span><span class="calibre4"><img alt="" src="images/000012.png" title="" class="calibre5" /></span></p><p class="c7"><span class="c8">For up-to-date information about this book, please visit </span><span class="c9"><a class="c10" href="https://www.google.com/url?q=https://www.plai.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021031685&amp;usg=AOvVaw01i5Wn_21RAQhPw9IjcjKE">plai.org</a></span><span class="c11">.</span></p><p class="c7"><span class="c8">This book is provided </span><span class="c12">free of cost</span><span class="c11">. Please report any violations.</span></p><p class="c7"><span class="c8">If you make a derivative version, please include the above information.</span></p></div>

<div class="c" id="calibre_link-85">
<h1 class="c13" id="calibre_link-86"><span class="c2">Table of Contents</span></h1><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c14"><span class="c15"><a class="c10" href="#calibre_link-86">Table of Contents</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-87">Preface</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-88">Why Study Programming Languages?</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-89">The Target Audience</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-90">Why a Third Edition</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-91">Structuring Our Study</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-92">Equipment for Learning</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-93">The Language(s) of the Book</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-94">Acknowledgments</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-95">Readers</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-96">Everyone Else</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-97">••••• Learning SMoL •••••</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-98">Teach Yourself SMoL</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-99">••••• Evaluation •••••</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-100">Evaluation on Paper</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-101">Evaluators</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-102">Terminology</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-68">Simulating an Interpreter by Hand</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-103">Substitution</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-104">Representing Arithmetic</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-105">Representing Programs</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-106">Abstract Syntax</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-107">Representing Abstract Syntax</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-108">Evaluating Arithmetic</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-109">Defining the Evaluator</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-110">Testing the Evaluator</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-111">Some Subtler Tests</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-112">Conclusion</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-113">Parsing: From Source to ASTs</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-114">The Problem</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-115">S-Expressions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-116">Primus Inter Parsers</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-117">Evaluating Conditionals</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-118">Extending the AST</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-119">Extending the Calculator</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-120">The Design Space of Conditionals</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-121">Using Truthy-Falsy Values</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-122">Implementing Conditionals</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-123">Adding Booleans</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-124">The Value Datatype</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-125">Updating the Evaluator</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-126">Evaluating Local Binding</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-127">A Syntax for Local Binding</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-128">The Meaning of Local Binding</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-129">Static Scoping</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-130">An Evaluator for Local Binding</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-131">Caching Substitution</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-132">Evaluating Functions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-133">Functions in the Language</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-134">Extending the Representation</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-135">Evaluating Functions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-136">Extending Values</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-137">Stepping Back</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-138">Extending Tests</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-139">Return to Static Scope</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-140">A Subtle Test</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-141">••••• Syntactic Sugar •••••</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-142">How SMoL Becomes Large</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-143">Redundancy in Languages</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-144">Desugaring</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-145">Macros By Example</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-146">A New Conditional</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-147">Local Binding</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-148">Binding More Locals</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-149">Multi-Armed Conditionals</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-150">More on Macros</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-151">A Definitional Convenience</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-152">Name Capture</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-153">A Truthy/Falsy Idiom</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-154">A Macro Definition Peril</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-155">Back to Hygiene</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-156">Generalizing Macros</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-157">•••••&nbsp;Objects •••••</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-158">A Standard Model of Objects</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-159">What is an Object?</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-160">The “Object” Pattern</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-161">Constructors</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-162">The “Class” Pattern</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-163">State</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-164">Private Members</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-165">A Refined “Class” Pattern</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-166">Static Members</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-167">A Re-Refined “Class” Pattern</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-168">Objects with Self Reference</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-169">Self-Reference Using Mutation</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-170">Self-Reference Without Mutation</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-171">Dynamic Dispatch</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-172">What Else do Objects Have?</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-173">Member Name Design Space</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-174">What (Goes In) Else?</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-175">A Java Excursion</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-176">Extending Classes</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-177">Extending Prototypes</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-178">Multiple Inheritance</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-179">Class Extensions: Mixins and Traits</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-53">•••••&nbsp;Types •••••</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-180">Introduction to Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-181">A Standard Model of Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-42">A Concise Notation</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-182">Growing Types: Division, Conditionals</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-183">Handling Division</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-184">Another Perspective on Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-185">From Axioms and Rules to Judgments</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-186">Judgments and Errors</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-187">Typing Conditionals</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-188">Where Types Diverge from Evaluation</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-66">Growing Types: Typing Functions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-189">Typing Function Applications</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-190">Typing Function Definitions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-191">Typing Variables</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-192">Back to Typing Function Definitions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-193">More Divergence Between Types and Evaluation</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-194">Assume-Guarantee Reasoning</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-195">Recursion and Infinite Loops</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-196">Typing Recursion</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-197">Safety and Soundness</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-198">Revisiting the Basic Calculator</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-199">Making Memory Explicit (Unsafely)</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-200">Recovering Safety</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-201">What Price Safety?</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-202">Soundness</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-203">Generic Printing</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-204">The Representation of Numbers</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-32">Type Inference</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-205">Unannotated Programs and Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-206">Imagining a Solution</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-207">Unique Variable Names</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-208">More Informal Examples</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-209">Algorithmic Details</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-74">Algebraic Datatypes</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-210">Generated Bindings</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-211">Static Type Safety</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-212">Pattern-Matching and Type-Checking</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-213">Algebraic Datatypes and Space</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-214">Union Types and Retrofitted Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-215">You Get a Type! And You Get a Type! And You Get a Type!</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-216">Union Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-217">If-Splitting</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-218">Introducing Union Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-219">How Many Unions?</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-220">Union Types and Space</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-221">If-Splitting with Control Flow</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-222">If-Splitting with Control Flow and State</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-223">The Price of Retrofitting</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-224">Types and Tags</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-225">Nominal Types, Structural Types, and Subtyping</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-226">Algebraic Datatypes Encoded With Nominal Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-227">Nominal Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-228">Structural Types</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-229">Nominal Subtyping</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-230">Subtyping</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-231">Gradual Typing</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-232">From Scripts to Programs</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-233">Micro Versus Macro</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-234">Typed Racket at Work</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-235">•••••&nbsp;Non-Standard Models •••••</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-236">Relations</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-237">A Language Genealogy</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-238">Encoding Type Rules</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-239">Generators</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-240">A Canonical Example</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-241">Translating to SMoL</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-242">A Richer Example</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-83">Laziness</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-243">Evaluation Strategies</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-244">Why Lazy Evaluation</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-245">Strictness Points</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-246">Evaluating Without Substitution</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-247">Laziness Via Closures: Beyond Numbers</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-248">Tracing Laziness</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-249">Laziness and Side-Effects</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-250">Caching Results</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-251">Space Consumption</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-252">Laziness in Eagerness</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-253">Control on the Web</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-254">Server-Side Programming</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-255">Recording Contexts</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-256">Simulating in the Stacker</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-257">Client-Side Termination</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-258">Abstracting the Problem</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-259">Using Closures</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-260">Using Racket</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-261">Yielding on a Web Server</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-262">Interaction with State</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-263">Web Interactions</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-264">Returning to the Counters</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-265">Mapping between Web and Programming Language Features</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-266">Readings</a></span></p><p class="c16"><span class="c15"><a class="c10" href="#calibre_link-267">Reactivity</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-268">GUIs through Callbacks</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-269">Reactivity</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-270">How Evaluation Works</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-271">Dataflow Graphs</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-272">Rewriting Application</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-273">Non-Linear Graphs</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-274">Avoiding Glitches</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-275">Other Time-Varying Values</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-276">Even More Time-Varying Values</a></span></p><p class="c17"><span class="c15"><a class="c10" href="#calibre_link-277">Returning to Our Timer</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-278">Elapsed Time Without Resetting</a></span></p><p class="c18"><span class="c15"><a class="c10" href="#calibre_link-279">Adding Resets</a></span></p><p class="c19"><span class="c15"><a class="c10" href="#calibre_link-280">•••••&nbsp;What’s Next? •••••</a></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-350">
<div id="calibre_link-383" class="calibre6"></div><h1 class="c20" id="calibre_link-87"><span class="c2">Preface</span></h1><h2 class="c21" id="calibre_link-88"><span class="c2">Why Study Programming Languages?</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It is always healthy to begin a course of study by asking why we should engage in it. So let us list a few reasons to justify this one:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">Programming languages are some of the most beautiful and powerful objects invented by human beings.</span></li><li class="pcalibre c23"><span class="c2">They let us&mdash;indeed, force us to&mdash;capture our thoughts precisely, and in return command machines of immense power to do our bidding.</span></li><li class="pcalibre c23"><span class="c2">To a programmer, they are the ultimate human-computer interface. </span></li><li class="pcalibre c23"><span class="c2">They are industrially important: so important that major companies create new languages or co-opt existing ones to establish or expand their market share. </span></li><li class="pcalibre c23"><span class="calibre3">They embody a new form of knowledge: what </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html&amp;sa=D&amp;source=editors&amp;ust=1695232021060331&amp;usg=AOvVaw0FxIsmtPtHl1wGbU99LU18">Structure and Interpretation of Computer Programs</a></span><span class="c2">&nbsp;called a “procedural epistemology”. </span></li><li class="pcalibre c23"><span class="c2">They enable us to prove powerful statements about the means and limits of our expression. How many other languages let us do either?</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">How many more reasons does one need?</span></p></div>

<div class="c" id="calibre_link-72">
<h2 class="c21" id="calibre_link-89"><span class="c2">The Target Audience</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Starting with the first edition, this book’s target has been “the other 90%”. That is, I conjecture that roughly 10% of students in a programming languages class are like the educator: they are deeply excited about and motivated to learn the subject, identify with it personally, and may want to continue to study it further. These are wonderful students, and many of them will go on to become the next generation of educators. There are several terrific books that are designed&mdash;or at least, work best&mdash;for this kind of student.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But most of them&mdash;say 90%&mdash;may not have this deep personal identification. Instead, they want to learn the subject enough to become better computer scientists. What do </span><span class="c6">they</span><span class="c2">&nbsp;need to learn, and how do they need to learn it? They are the target audience for this book. On the one hand, the book tries to connect to many programming tasks. At the same time, it’s too easy to pander to such an audience. The book tries to balance these connections with a focus on principles that will stand the learner in good stead for a long time.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Of course, I believe the 10% will learn something useful from this book, too. If nothing else, they may learn a different </span><span class="c6">perspective</span><span class="c2">&nbsp;on the subject, and maybe also develop some empathy for learners not like themselves. If nothing else, well over a dozen students who used earlier editions of this book successfully completed PhDs in programming languages, and several are themselves professors now. So, at least, the book has not harmed them. I can live with those odds.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">I have also written this book with working programmers in mind. Many of them may have not had a formal computer science education, or at least one that included a proper introduction to programming languages. At some point, like that 90% of students, some of them become curious about the media they use. I want this book to speak to them, gently drawing them away from the hustle and bustle of daily programming into a space of reflection and thought.</span></p></div>

<div class="c" id="calibre_link-372">
<h2 class="c21" id="calibre_link-90"><span class="c2">Why a Third Edition</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Over the past several years, a significant part of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/&amp;sa=D&amp;source=editors&amp;ust=1695232021062166&amp;usg=AOvVaw1RZYx27xWDC--rnWjNoVEQ">my research</a></span><span class="c2">&nbsp;examines how students understand programming languages at many different levels. What I have learned has convinced me that we need a new approach to teaching this material. This edition is a first iteration to that end. (It was also a chance to rewrite the prose in my current “voice”, which has evolved a lot over two decades. Virtually no text is in common with the first edition, and only some with the second.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We also live in a world of unprecedented linguistic diversity and novelty. It seems like every few weeks I learn about someone trying some new linguistic experiment. The wide availability of robust and interesting run-time systems&mdash;as diverse as Erlang’s, the Java Virtual Machine, the browser’s JavaScript, Racket’s, and more&mdash;makes it easy to get a working prototype “with batteries” and focus on novelty. This affects both people trying to learn new languages and those trying to build them.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Relatedly, the first edition took a very “classical” look at programming languages, shaped by my own formal training in the subject. The second edition started to migrate from it, but not entirely. The third edition has mostly broken free of those constraints, reflecting more of the current linguistic landscape. There are not many books that cover topics like “scripting” and “gradual typing” without reducing them to slogans and fluff; this book tries to cover them in more rigorous ways.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But all this diversity brings up the important challenge of how to approach it. In other disciplines, we approach new objects by decomposing them into familiar constituent elements. Their commonalities provide an anchor, and a point of departure for what makes them novel. What are those elements for programming languages? Pedagogic tradition holds that “paradigms” are one such organizational medium, but I find them a moribund legacy of a period when computing wanted to be viewed as a “science” and felt the best way to do this was to put things in labeled boxes. But programming languages are artificial, not natural, entities, and nothing prevents designers from freely mixing between the boxes&mdash;as indeed many have. When virtually everything is “multiparadigm”, how can we make sense out of the world?</span></p></div>

<div class="c" id="calibre_link-292">
<h2 class="c21" id="calibre_link-91"><span class="c2">Structuring Our Study</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As I have argued in greater length </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/sk-teach-pl-post-linnaean/&amp;sa=D&amp;source=editors&amp;ust=1695232021063528&amp;usg=AOvVaw37Mi6t9TcyPiWLJtD_NsvH">elsewhere</a></span><span class="calibre3">, it is more meaningful to think of programming languages as aggregates of </span><span class="c6">features</span><span class="c2">. The features are the building blocks. Of course, once combined, languages are more like compounds than like mixtures: the features interact in ways that may not be easy to predict. Understanding both the features and their compositions is then a valuable way to approach a language.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The book revolves around a central idea, </span><span class="c6">SMoL</span><span class="c2">, the Standard Model of Languages. This is the embodiment of the computational core of many of our widely-used programming languages, from C# and Java to JavaScript, Lua, Python, and Ruby to OCaml and Racket. The astute reader will notice that this commonality pays no respect to “paradigms”. Rather, all these languages (and many others), to a large extent, have a common computational core: safe runtime systems, automated memory management, eager evaluation, first-class lexically-scoped functions, first-order mutable variables, and first-class mutable structures. Contemporary programming demands a deep understanding of these. For instance, I believe you cannot make sense of concurrency with mutation, static members, or ownership, without understanding SMoL.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, because languages are artificial and programming is an almost infinitely malleable material, even “standard” features have historically seen variation. Therefore, while we progress </span><span class="c6">across</span><span class="calibre3">&nbsp;features, we also want to study variation </span><span class="c6">within</span><span class="calibre3">&nbsp;them. We do this by using the </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pkf-teach-pl-exp-adv-think/&amp;sa=D&amp;source=editors&amp;ust=1695232021064466&amp;usg=AOvVaw0VIwT72D0WNabBksW4GD3x">mystery language</a></span><span class="calibre3">&nbsp;approach: with a fixed syntax, we explore the different ways the same feature can behave. This hopes to build on the cognitive theory of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://www.cultofpedagogy.com/contrasting-cases/&amp;sa=D&amp;source=editors&amp;ust=1695232021064751&amp;usg=AOvVaw1sitvi37D-BaEv1xrf6erl">contrasting cases</a></span><span class="calibre3">&nbsp;to improve learning</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What goes in SMoL is, of course, a judgment call: when a feature isn’t present across a large number of diverse languages (like static types), or shows too much variation between languages (like objects), I argue that it’s no longer part of the </span><span class="c6">standard</span><span class="calibre3">&nbsp;model. But it is not a </span><span class="c6">value</span><span class="c2">&nbsp;judgment: in this book we explore SMoL in some depth, &nbsp;then turn our attention to several non-“standard” features that are not only important but also beautiful and fascinating.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Turning to implementation, the book provides another pillar: </span><span class="c6">SImPl</span><span class="c2">, the Standard Implementation Plan. This is the idea that programming languages are usefully thought of in terms of an abstract syntax tree; this tree is represented well by an algebraic datatype; and a program that processes this tree is a recursive function that is largely guided by the structure of the type. This level of description encompasses both the standard media for evaluation, interpreters and compilers. It also captures the essence of type-checkers, type inference, static analysis, and more. Thus, students should gain facility with this structure for when they want to implement their own language experiments.</span></p></div>

<div class="c" id="calibre_link-359">
<h2 class="c21" id="calibre_link-92"><span class="c2">Equipment for Learning</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">While over time all the material might be incorporated into this book, for now, the book is part of a broader learning ecosystem, which is the course CSCI 1730 at Brown University. All the materials are available from the following site:</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/courses/csci1730/2022/&amp;sa=D&amp;source=editors&amp;ust=1695232021066072&amp;usg=AOvVaw12rsq8ZewnReEjggrk9lO5">https://cs.brown.edu/courses/csci1730/2022/</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The course’s work is divided into four “threads”. One thread, SMoL, uses an automated tutor to teach students SMoL. A second thread, ML, makes students work through </span><span class="calibre3">mystery languages</span><span class="c2">. The third is the Implementation thread. The fourth is Analysis, which asks students to relate material they are learning in the class to real-world language contexts. I especially encourage educators to make use of the Analysis thread assignments in their classes.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The book also makes extensive use of the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://github.com/LuKC1024/stacker&amp;sa=D&amp;source=editors&amp;ust=1695232021066666&amp;usg=AOvVaw0F8H7448KxzXTTcrlEvX1V">Stacker</a></span><span class="c2">&nbsp;notional machine. Readers will find it useful to run SMoL programs in the Stacker and study how they behave.</span></p></div>

<div class="c" id="calibre_link-78">
<h2 class="c21" id="calibre_link-93"><span class="c2">The Language(s) of the Book</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This book makes heavy use of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://racket-lang.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021067159&amp;usg=AOvVaw0kEHgZx4wlLC_o1l7GnVcx">Racket</a></span><span class="calibre3">. However, that is too simplistic. Racket’s power comes from its ability to define new languages: </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/fffkbmt-programmable-prog-lang/&amp;sa=D&amp;source=editors&amp;ust=1695232021067394&amp;usg=AOvVaw214fGxlshmCAnJzUJUG5dk">this article</a></span><span class="calibre3">&nbsp;and </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://youtu.be/R_1TnfCuxK8&amp;sa=D&amp;source=editors&amp;ust=1695232021067621&amp;usg=AOvVaw055kiEdpnPdwxtKaQRyL0R">this brief video</a></span><span class="calibre3">&nbsp;discuss that in more detail. Indeed, some programs in this book are written in the Racket programming language (</span><span class="c25">#lang racket</span><span class="calibre3">), but many are in a language ideally designed for this book (</span><span class="c25">#lang plait</span><span class="c2">). In addition, other parts define their own languages: there are multiple SMoL languages and well over a dozen mystery languages. Thus, while the learner must demonstrate some forbearance for parenthetical syntax, in return they will be richly rewarded with learning experiences.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The existence of </span><span class="c25">#lang</span><span class="calibre3">, in some ways, drove this book’s redesign. I had some hand in that feature’s </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/cffk-macros-to-dsls/&amp;sa=D&amp;source=editors&amp;ust=1695232021068197&amp;usg=AOvVaw2ek0jEgcbTPyCNMaXY6ktq">design</a></span><span class="calibre3">, which made me acutely self-conscious: materials intended to be for a broad audience shouldn’t be about work too close to my heart. That was one of the reasons that, while the first edition used a predecessor of Racket, the second edition did not. In the process, however, I realized that I was depriving my students of numerous learning opportunities: after all, what better medium for the study of languages than a language designed for designing languages? For instance, the first version of the mystery languages were ad hoc and confusing; reimplementing them as a collection of Racket </span><span class="c25">#lang</span><span class="c2">s made them far simpler and clearer (and also open them up to be an object of direct study themselves). Thus, this edition doubles down (and then some) on the use of Racket. Getting it right can be tricky (e.g., avoiding mode confusion) and may take a few iterations, but it’s well worth the effort.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-20">
<div id="calibre_link-384" class="calibre6"></div><h1 class="c26" id="calibre_link-385"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-94"><span class="c2">Acknowledgments</span></h1><h2 class="c21" id="calibre_link-95"><span class="c2">Readers</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">For this edition, I thank the students and other readers who have pointed out errors and suggested improvements:</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c2">Alex Ding, Ashley Chung, Calder Ruhl Hansen, Charles Gagnon, David Fryd, David Young, garare992 @ GitHub, Geoffrey J. Teale, Jack Zeng, Jason Eveleth, Kevin Gibbons, Kristoffer Balintona, Liam Bai, Michael Fishman, Nicholas Vadasz, Nolan Serbent, Paul Biberstein, Paul Carduner, Peter Li, Robert Wang, Shihang Li, Sidharth Anand, Sreshtaa Rajesh, Suzanne Rivoire, Tomas Dougan, Zack Amiton, Zack Eisbach</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A few have made numerous or especially good suggestions:</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c2">Benjamin Lee, Ian Arawjo, Neil Ramaswamy, Qiuhong Wei, Tianren Dong, Yongming Han, Zack Cheng</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Finally, a few deserve extra special praise for their attention to detail and staying power:</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c2">Chen Li, Ezra Marks, Futao Wei</span></p></div>

<div class="c" id="calibre_link-84">
<h2 class="c21" id="calibre_link-96"><span class="c2">Everyone Else</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This edition builds on </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/&amp;sa=D&amp;source=editors&amp;ust=1695232021070204&amp;usg=AOvVaw3CVpbu9X47jQ8MLGb5Ajjn">two</a></span><span class="calibre3">&nbsp;</span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/courses/cs173/2012/book/&amp;sa=D&amp;source=editors&amp;ust=1695232021070493&amp;usg=AOvVaw3c8_IB5k6Y0qVdQIpSCQg9">previous</a></span><span class="c2">&nbsp;editions. I remain deeply grateful to all the people who helped make those editions happen.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">My group’s PhD students, especially Jack Wrenn, have tolerated years of my complaining about my course. Amidst their eye-rolling they heard me out, batted away my worst ideas, and fleshed out my better ones. I am deeply fortunate to be able to work with them.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">John Clements’s sabbatical at Brown was a huge fillip to my rethinking the basics, and our conversations reminded me how much I have missed his company.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Kuang-Chen Lu has believed in this project from the start, and built and maintained numerous of the materials that make it possible. He has not only collaborated on but actively leads many of the materials that power or augment this book. His dissertation research will likely lead to significant improvements in how we teach programming languages.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Matthew Flatt’s fingerprints are all over this book. I especially thank him for the Racket ecosystem and the </span><span class="c25">#lang</span><span class="c2">&nbsp;concept, which also drove the redesign of this book, and for the plait language especially, which is central to much of this book’s code.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Most of this book’s ideas and composition were formed on the East Bay Bike Path. To the people who made it happen and keep it alive, many thanks, and may the winds always be at your back (which they often can be, if you ride south and then back north between 2pm and 4pm).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, this book wouldn’t have migrated from head to page without the love and support of Kathi and Tara, who </span><span class="c6">also</span><span class="calibre3">&nbsp;tolerated years of my complaining about my course and provided their </span><span class="c6">own</span><span class="calibre3">&nbsp;eye-rolling support. They are my rocks.</span></p><p class="c4"><span class="calibre3">&nbsp;</span></p></div>

<div class="c" id="calibre_link-43">
<h1 class="c13" id="calibre_link-97"><span class="calibre3">••••• </span><span class="calibre3">Learning SMoL</span><span class="c2">&nbsp;•••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c28">We begin by learning the Standard Model of Languages, which undergirds most of our subsequent study.</span></p></div>

<div class="c" id="calibre_link-81">
<h1 class="c20" id="calibre_link-98"><span class="c2">Teach Yourself SMoL</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This work is centered around your understanding of SMoL. However, to avoid a passive reading experience, </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://lukc1024.github.io/&amp;sa=D&amp;source=editors&amp;ust=1695232021072512&amp;usg=AOvVaw3O6JByCXbnLV7Fth_iekCw">Kuang-Chen Lu</a></span><span class="c2">&nbsp;has implemented a series of self-paced tutors to teach you SMoL. The tutors both give you conceptual knowledge and teach you important terminology. Importantly, they also have short, quick test questions to make sure you’re on the right track. These questions serve two ends. First, they force you to pay attention to the tutor: you can’t just scroll through passively. Second, they are based on known misconceptions with this material. Other learners made these mistakes, so you might too. Pay attention!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The tutors are still preliminary, but they have already been used successfully at Brown.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Because the tutorials currently do not support stopping, saving your work, and resuming, we have broken the material down into a set of small (!) tutors, each covering one concept (and sometimes even less). That way, you can do a tutor or three, take a break, and pick up later.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The tutors are here, in order:</span></p><p class="c3"><span class="c2"></span></p><ol class="c29" start="1"><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dscope&amp;sa=D&amp;source=editors&amp;ust=1695232021073286&amp;usg=AOvVaw2jCaJDO7DIAc1Y7QPXR-ip">scope</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dorder&amp;sa=D&amp;source=editors&amp;ust=1695232021073631&amp;usg=AOvVaw02VK-IQlGPN10i1EaDWAJM">order</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dmore-scope&amp;sa=D&amp;source=editors&amp;ust=1695232021073959&amp;usg=AOvVaw1mN0Av1aAjugY4QlJtO35W">more-scope</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dmut-vars&amp;sa=D&amp;source=editors&amp;ust=1695232021074279&amp;usg=AOvVaw3QZUxWQRk99MfEme5JBqpk">mutable variables</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dbegin&amp;sa=D&amp;source=editors&amp;ust=1695232021074610&amp;usg=AOvVaw0QYgUMQE-j5fpEjO6x6mAQ">sequencing</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dvectors1&amp;sa=D&amp;source=editors&amp;ust=1695232021074972&amp;usg=AOvVaw09X5FEnk6B-VwB80otQiwc">vectors1</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dvectors2&amp;sa=D&amp;source=editors&amp;ust=1695232021075331&amp;usg=AOvVaw3rziWdxNWxf2RqKYGxrRja">vectors2</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dheap&amp;sa=D&amp;source=editors&amp;ust=1695232021075752&amp;usg=AOvVaw2ooiEXa9eegpjBTMsXUlGR">the heap</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dlambda1&amp;sa=D&amp;source=editors&amp;ust=1695232021076127&amp;usg=AOvVaw1lsI1lKbVaBzKVhviJOg0s">lambda1</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dlambda2&amp;sa=D&amp;source=editors&amp;ust=1695232021076493&amp;usg=AOvVaw2S6_5DVxcpafrdm2oJbvrL">lambda2</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dlambda3&amp;sa=D&amp;source=editors&amp;ust=1695232021076846&amp;usg=AOvVaw0KtSU5-rn9A3Fmd9SeHqPn">lambda3</a></span></li><li class="pcalibre2 pcalibre1"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://script.google.com/a/brown.edu/macros/s/AKfycbz8R8BnTfQg9GErWjqt6RluW64tdgD1Bg4zCbQ6Y12_I85R3c3ihozuF3L8Ji4x-iMa/exec?tutorial%3Dlocal&amp;sa=D&amp;source=editors&amp;ust=1695232021077191&amp;usg=AOvVaw3b75zQfeMig-XzwSltgyok">local</a></span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Before you go on in this book, you should do the tutors!</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-362">
<h1 class="c26" id="calibre_link-386"><span class="c2"></span></h1><h1 class="c13" id="calibre_link-99"><span class="c2">••••• Evaluation •••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c28">We begin by studying the process of building evaluators: programs that turn programs into answers. We will follow SImPl, while exploring the core concepts in SMoL.</span></p></div>

<div class="c" id="calibre_link-79">
<h1 class="c26" id="calibre_link-387"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-100"><span class="c2">Evaluation on Paper</span></h1><h2 class="c21" id="calibre_link-101"><span class="c2">Evaluators</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We’re trying to implement a programming language: that is, to write an </span><span class="c6">evaluator</span><span class="calibre3">&nbsp;(i.e., something that “reduces programs to values”). It helps if we can first understand how </span><span class="calibre3">evaluation</span><span class="c2">&nbsp;works on paper, before we start dealing with computer complexities.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Before we get into the details, it’s worth knowing that there are broadly speaking two kinds of evaluators (as well as many combinations of them). They follow very different strategies:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">An </span><span class="c6">interpreter</span><span class="calibre3">&nbsp;consumes a program and </span><span class="c6">simulates</span><span class="c6">&nbsp;its execution</span><span class="c2">. That is, the interpreter does what we would expect “running the program” should do.</span></li><li class="pcalibre c23"><span class="calibre3">A </span><span class="c6">compiler</span><span class="calibre3">&nbsp;consumes a program and </span><span class="c6">produces another program</span><span class="c2">. That output program must then be further evaluated.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, an interpreter maps programs in some language </span><span class="c6">L</span><span class="c2">&nbsp;to values:</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="calibre3">interpreter :: Program</span><span class="c30">L</span><span class="c2">&nbsp;→ Value</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We leave open exactly what a </span><span class="c6">value</span><span class="c2">&nbsp;is for now, informally understanding it to be an answer the user would want to see&mdash;put differently, something that either cannot or does not need to be further e-valu-ated. In contrast,</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="calibre3">compiler :: Program</span><span class="c30">L</span><span class="calibre3">&nbsp;→ Program</span><span class="c31">T</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, a compiler from </span><span class="c6">L</span><span class="calibre3">&nbsp;to </span><span class="c6">T</span><span class="calibre3">&nbsp;(we use </span><span class="c6">T</span><span class="calibre3">&nbsp;for “target”) consumes programs in </span><span class="c6">L</span><span class="calibre3">&nbsp;and produces programs in </span><span class="c6">T</span><span class="calibre3">. We aren’t saying about how this </span><span class="c6">T</span><span class="c2">&nbsp;program must be evaluated. It may be interpreted directly, or it may be further compiled. For instance, one can compile a Scheme program to C. The C program may be interpreted directly, but it may very well be compiled to assembly. However, we can’t keep compiling ad infinitum: at the bottom, there must be some kind of interpreter (e.g., in the computer’s hardware) to provide answers.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Note that interpreters and compilers are themselves programs written in some language and must themselves run. Naturally, this can lead to interesting ideas and problems.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In our study, we will focus primarily on interpreters, but also see a very lightweight form of compilers. Interpreters are useful because:</span></p><p class="c3"><span class="c2"></span></p><ol class="c32" start="1"><li class="pcalibre3 pcalibre4"><span class="c2">A simple interpreter is often much easier to write than a compiler.</span></li><li class="pcalibre3 pcalibre4"><span class="c2">Debugging an interpreter can sometimes be much easier than debugging a compiler.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Therefore, they provide a useful “baseline” implementation technology that everyone can reach for. Compilers can often take an entire course of study.</span></p></div>

<div class="c" id="calibre_link-75">
<h2 class="c21" id="calibre_link-102"><span class="c2">Terminology</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It is common, on the Web, to read people speak of “interpreted languages” and “compiled languages”. These terms are </span><span class="c33">nonsense</span><span class="calibre3">. That isn’t just a judgment; that’s a literal statement: they do not make sense. Interpretation and compilation are techniques one uses to evaluate programs. A </span><span class="c6">language</span><span class="c2">&nbsp;(almost) never specifies how it should be evaluated. As a result, each implementer is free to choose whatever strategy they want.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Just as an example, C is often chosen as a canonically “compiled language”, while Scheme is often presented as an “interpreted language”. However, there have been (a handful of) interpreters for C; indeed, I used one when I first learned C. Likewise, there are numerous compilers for Scheme; I used one when I first learned Scheme. Python has several interpreters and compilers.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Furthermore, this seemingly hard distinction is frequently broken down in practice. Many languages now have a “JIT”, which stands for </span><span class="c6">just-in-time</span><span class="c2">&nbsp;compilation. That is, the evaluator starts out as an interpreter. If it finds itself interpreting the same code over and over, it compiles it and uses the compiled code instead. When and how to do this is a complex and fascinating topic, but it makes clear that the distinction is not a bright line.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Some people are confused by the </span><span class="c6">interface</span><span class="calibre3">&nbsp;that an implementation presents. Many languages provide a </span><span class="c6">read-eval-print loop</span><span class="calibre3">&nbsp;(REPL), i.e., an interactive interface. It is often easier for an interpreter to do this. However, many systems with such an interface accept code at a prompt, compile it, run it, and present the answer back to the user; they mask all these steps. Therefore, the interface is not an indicator of what kind of implementation you are seeing. It is perhaps meaningful to refer to an </span><span class="c6">implementation</span><span class="c2">&nbsp;as “interactive” or “non-interactive”, but that is not a reflection of the underlying language.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In short, please remember: </span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">(Most) Languages do not dictate implementations. Different platforms and other considerations dictate what implementation to use. </span></li><li class="pcalibre c23"><span class="c2">Implementations usually use one of two major strategies&mdash;interpretation and compilation&mdash;but many are also hybrids of these.</span></li><li class="pcalibre c23"><span class="calibre3">A specific implementation may offer an interactive or non-interactive interface. However, this does </span><span class="c6">not</span><span class="c2">&nbsp;automatically reveal the underlying implementation strategy.</span></li><li class="pcalibre c23"><span class="c2">Therefore, the terms “interpreted language” and “compiled language” are nonsensical.</span></li></ul></div>

<div class="c" id="calibre_link-82">
<h2 class="c21" id="calibre_link-68"><span class="c2">Simulating an Interpreter by Hand</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Since we have decided to write an interpreter, let’s start by understanding </span><span class="c6">what</span><span class="calibre3">&nbsp;we are trying to get it to do, before we start to investigate </span><span class="c6">how</span><span class="c2">&nbsp;we will make it do it.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s consider the following program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (f x) (+ x 1))</span></p><p class="c4"><span class="c34">(f 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What does it produce? We can all guess that it produces </span><span class="c25">3</span><span class="calibre3">. Now suppose we’re asked, </span><span class="c6">why</span><span class="calibre3">&nbsp;does it produce </span><span class="c25">3</span><span class="c2">? What might you say?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There’s a good chance you’ll say that it’s because x gets replaced with 2 in the body of f, then we compute the body, and that’s the answer:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c35">→</span><span class="calibre3">&nbsp;</span><span class="c34">(f 2)</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ x 1)</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">2</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 2 1)</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">3</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These programs are written in Racket. You can put these programs into DrRacket in an early student language level (like Beginning Student) and watch them run, step-by-step, using the Step button in the menu bar: </span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="calibre7"><img alt="" src="images/000005.png" title="" class="calibre8" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s look at an extended version of the program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">;; f is the same as before</span></p><p class="c4"><span class="c34">(define (g z)</span></p><p class="c4"><span class="c34">&nbsp; (f (+ z 4)))</span></p><p class="c4"><span class="c34">(g 5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can use the same process:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c35">→</span><span class="calibre3">&nbsp;</span><span class="c34">(g 5)</span></p><p class="c4"><span class="calibre3">→ (</span><span class="c25">f (+ z 4))</span><span class="calibre3">&nbsp;where </span><span class="c25">z</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">5</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(f (+ 5 4))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(f 9)</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ x 1)</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">9</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 9 1)</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">10</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;We call the variables in the function header the </span><span class="c6">formal parameters</span><span class="calibre3">&nbsp;and the expressions in the function call the </span><span class="c6">actual parameters</span><span class="calibre3">. So in </span><span class="c25">f</span><span class="calibre3">, </span><span class="c25">x</span><span class="calibre3">&nbsp;is the formal parameter, while </span><span class="c25">9</span><span class="calibre3">&nbsp;is an actual parameter. Some people also use </span><span class="c6">argument</span><span class="calibre3">&nbsp;in place of </span><span class="c6">parameter</span><span class="c2">, but there’s no real difference between these terms.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Observe that we had a choice: we could have gone either</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(f (+ 5 4))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(f 9)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">or</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(f (+ 5 4))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ x 1)</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">(+ 5 4)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">For now, both will produce the same </span><span class="c6">answer</span><span class="c2">, but this is actually a very consequential decision! It is in fact one of the most profound choices in programming language design.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;The former choice is called </span><span class="c6">eager</span><span class="calibre3">&nbsp;evaluation: think of it as “eagerly” reducing the actual parameter to a value before starting the function call. The latter choice is called </span><span class="c6">lazy</span><span class="c2">&nbsp;evaluation: think of it as not rushing to perform the evaluation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">SMoL is eager</span><span class="calibre3">. There are good reasons for this, which we will explore later [</span><span class="c15"><a class="c10" href="#calibre_link-83">👉</a></span><span class="c2">].</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Okay, so back to evaluation. Let’s do one more step:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">;; f is the same as before</span></p><p class="c4"><span class="c34">;; g is the same as before</span></p><p class="c4"><span class="c34">(define (h z w)</span></p><p class="c4"><span class="c34">&nbsp; (+ (g z) (g w)))</span></p><p class="c4"><span class="c34">(h 6 7)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Once again, we can look at the steps:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c35">→</span><span class="calibre3">&nbsp;</span><span class="c34">(h 6 7)</span></p><p class="c4"><span class="calibre3">→ (+ </span><span class="c25">(g z) (g w))</span><span class="calibre3">&nbsp;where </span><span class="c25">z</span><span class="calibre3">&nbsp;is replaced by </span><span class="c25">6</span><span class="calibre3">&nbsp;and </span><span class="c25">w</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">7</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ (g 6) (g 7))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ (f (+ y 4)) (g 7))</span><span class="calibre3">&nbsp;where </span><span class="c25">y</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">6</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ (f (+ 6 4)) (g 7))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ (f 10) (g 7))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ (+ x 1) (g 7))</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">10</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ (+ 10 1) (g 7))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 11 (g 7))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ 11 (f (+ y 4)))</span><span class="calibre3">&nbsp;where </span><span class="c25">y</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">7</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 11 (f (+ 7 4)))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 11 (f 11))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c25">(+ 11 (+ x 1))</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is replaced by </span><span class="c34">11</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 11 (+ 11 1))</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">(+ 11 12)</span></p><p class="c4"><span class="calibre3">→ </span><span class="c34">23</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Observe that we again had some choices:</span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">Do we replace both calls at once, or do one at a time?</span></li><li class="pcalibre c23"><span class="c2">If the latter, do we do the left or the right one first?</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Languages have to make decisions about these, too! Above, we’ve again done what SMoL does: it finishes one call before starting the other, which makes SMoL </span><span class="c6">sequential</span><span class="calibre3">. Had we replaced both calls at once, we’d be exploring a </span><span class="c6">parallel</span><span class="c2">&nbsp;language. Conventionally, most languages choose a left-to-right order, so that’s what we choose in SMoL.</span></p></div>

<div class="c" id="calibre_link-295">
<h2 class="c21" id="calibre_link-103"><span class="c2">Substitution</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">By the way, observe that you didn’t need to know any computer programming to answer these questions. You did something similar in middle- and high-school algebra classes. You probably learned the phrase </span><span class="c6">substitution</span><span class="c2">&nbsp;for “replaced with”. That’s the same process we’re following here. And indeed, we can think of programming as a natural outgrowth of algebra, except with much more interesting datatypes: not only numbers but also strings, images, lists, tables, vector fields, videos, and more.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Okay, so this gives us a way to implement an evaluator:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">Find a way to represent program source (e.g., a string or a tree).</span></li><li class="pcalibre c23"><span class="c2">Look for the next expression to evaluate.</span></li><li class="pcalibre c23"><span class="c2">Perform substitution (textually) to obtain a new program.</span></li><li class="pcalibre c23"><span class="c2">Continue evaluating until there’s nothing left but a value.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, as you might have guessed, that’s not how most programming languages </span><span class="c6">actually</span><span class="calibre3">&nbsp;work: in general it would be painfully slow. So we’ll have to find a better way!</span></p></div>

<div class="c" id="calibre_link-339">
<h1 class="c20" id="calibre_link-104"><span class="c2">Representing Arithmetic</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s start thinking about actually writing an evaluator. We’ll start with a simple arithmetic language, and then build our way up from there. So our language will have</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre5 c23"><span class="c2">numbers</span></li><li class="pcalibre5 c23"><span class="calibre3">some arithmetic operations: in fact, </span><span class="c6">just</span><span class="c2">&nbsp;addition</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and nothing more for now, so we can focus on the basics. Over time we’ll build this up.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Before we can think about the body of an evaluator, however, we need to figure out its type: in particular, what will it consume?</span></p></div>

<div class="c" id="calibre_link-340">
<h2 class="c21" id="calibre_link-105"><span class="c2">Representing Programs</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Well, what </span><span class="c6">does</span><span class="calibre3">&nbsp;an evaluator consume? It consumes </span><span class="c33">programs</span><span class="calibre3">. So we need to figure out how to </span><span class="c6">represent programs</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Of course, computers represent programs all the time. When we’re writing code, our text editor holds the program source. Every executable on disk and in memory is a representation of a program. When we visit a Web page, it sends down a JavaScript program. These are all programs represented in the computer. But all these are a bit inconvenient for our needs, and we’ll come up with a better representation in a moment.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Before thinking about represent</span><span class="c6">ations</span><span class="calibre3">, let’s think about what we’re represent</span><span class="c6">ing</span><span class="c2">. Here are some example (arithmetic) programs:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">1</span></p><p class="c4"><span class="c34">0</span></p><p class="c4"><span class="c34">-1</span></p><p class="c4"><span class="c34">2.3</span></p><p class="c4"><span class="c34">1 + 2</span></p><p class="c4"><span class="c34">3 + 4</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Already we have a question. How should we </span><span class="c6">write</span><span class="c2">&nbsp;our program? You can see where this is going: should we be writing the sum of 1 and 2 as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">1 + 2</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">or as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 1 2)</span></p><p class="c4"><span class="c34">+ 1 2</span></p><p class="c4"><span class="c34">1 2 +</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and so on. (For that matter, we can even ask what numeral system to use for basic numbers: e..g, should we write </span><span class="c25">3</span><span class="calibre3">&nbsp;or </span><span class="c25">III</span><span class="calibre3">? You can </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://github.com/shriram/roman-numerals&amp;sa=D&amp;source=editors&amp;ust=1695232021096337&amp;usg=AOvVaw196-G7CiljdYG4eyIDGvwA">program with the latter</a></span><span class="c2">&nbsp;if you’d really like to.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">These are questions of what </span><span class="c6">surface syntax</span><span class="c2">&nbsp;to use. And they are very important! And interesting! And important! People get really attached to some surface syntaxes over the other (you may already be having some feelings about Racket’s parenthetical syntax…I certainly do). You can even write that expression as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre9"><img alt="" src="images/000006.png" title="" class="calibre10" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">in Scratch and Snap!, and this syntax has been invaluable in getting young children to learn how to program without all the vagaries of textual syntax.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Thus, these are great human-factors considerations. But for now these are a distraction in terms of getting to understand the </span><span class="c6">models</span><span class="c2">&nbsp;underlying languages. Therefore, we need a way to represent all these different programs in a way that ignores these distinctions.</span></p></div>

<div class="c" id="calibre_link-54">
<h2 class="c21" id="calibre_link-106"><span class="c2">Abstract Syntax</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This leads us to the first part of </span><span class="c36">SImPl</span><span class="calibre3">&nbsp;(the Standard Implementation Plan): the creation of what is called </span><span class="c6">abstract syntax</span><span class="c2">. In abstract syntax, we represent the essence of the input, ignoring the superficial syntactic details. Thus, in abstract syntax, all of the above programs will have the exact same representation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">An abstract syntax is an in-computer representation of programs. There are many kinds of data we can use as a representation, so let’s think about the kinds of programs we might want to represent. For simplicity, we’ll assume that our language has only numbers and addition; once we can handle that, it’ll be easy to handle additional operations. Here are some sample (surface syntax) programs:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">1</span></p><p class="c4"><span class="c34">2.3</span></p><p class="c4"><span class="c34">1 + 2</span></p><p class="c4"><span class="c34">1 + 2 + 3</span></p><p class="c4"><span class="c34">1 + 2 + 3 + 4</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In conventional arithmetic notation, of course, we have to worry about the order of operations and what operations take precedence over what others. In abstract syntax, that’s another detail we want to ignore; we’ll instead assume that we are working internally with the equivalent of fully-parenthesized expressions, where all these issues have been resolved. Thus, it’s as if the last two expressions above were written as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(1 + 2) + 3</span><span class="calibre3">&nbsp; &nbsp; or &nbsp; &nbsp;</span><span class="c34">1 + (2 + 3)</span></p><p class="c4"><span class="c34">1 + ((2 + 3) + 4)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe, then, that each side of the addition operation can be a full-blown expression in its own right. This gives us a strong hint as to what kind of representation to use internally: a </span><span class="c6">tree</span><span class="calibre3">. Indeed, it’s so common to use </span><span class="c6">abstract syntax trees</span><span class="c2">&nbsp;that the abbreviation, AST, is routinely used without explanation; you can expect to see it in books, papers, blog posts, etc. on this topic.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">You have quite possibly seen this idea before: it’s called </span><span class="c6">sentence diagramming</span><span class="calibre3">&nbsp;(read more on </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Sentence_diagram&amp;sa=D&amp;source=editors&amp;ust=1695232021099891&amp;usg=AOvVaw0mLql56jjx6e6LF3zsSv2s">Wikipedia</a></span><span class="c2">). Here, for instance, is a diagram of the sentence “He studies linguistics at the university”:</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="calibre11"><img alt="" src="images/000001.png" title="" class="calibre12" /></span></p><p class="c7"><span class="c28">By Xbarst1.jpg: Russky1802 derivative work: Maxdamantus - This file was derived from: Xbarst1.jpg:, Public Domain, https://commons.wikimedia.org/w/index.php?curid=21979041</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">An NP is a Noun Phrase, V is a Verb, and so on. Observe how the sentence diagram takes a </span><span class="c6">linear</span><span class="calibre3">&nbsp;sentence and turns it into a </span><span class="c6">tree-shaped</span><span class="c2">&nbsp;representation of the grammatical structure. We want to do the same for programs.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-55">
<h2 class="c21" id="calibre_link-107"><span class="c2">Representing Abstract Syntax</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In the rest of this book, except where indicated otherwise, we will implement things in the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://docs.racket-lang.org/plait/index.html&amp;sa=D&amp;source=editors&amp;ust=1695232021101325&amp;usg=AOvVaw1V2YliLbtsEZqqySfseP61">plait</a></span><span class="c2">&nbsp; language of Racket. Please make sure you have plait installed to follow along.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We will create a new tree datatype in plait to represent ASTs. In the sentence diagram above, the leaves of the tree are words, and the nodes are grammatical terms. In our AST, the leaves will be numbers, while the nodes will be operations on the trees representing each sub-expression. For now, we have only one operation: addition. Here’s how we can represent this in plait syntax:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Exp</span></p><p class="c4"><span class="c34">&nbsp; [num (n : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [plus (left : Exp) (right : Exp)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This says:</span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">We are defining a new type, </span><span class="c34">Exp</span></li><li class="pcalibre c23"><span class="calibre3">There are two ways of making an </span><span class="c34">Exp</span></li><li class="pcalibre c23"><span class="calibre3">One way is through the constructor </span><span class="c25">num</span><span class="c2">:</span></li></ul><ul class="c22"><li class="pcalibre7 pcalibre6"><span class="calibre3">A </span><span class="c25">num</span><span class="c2">&nbsp;takes one argument</span></li><li class="pcalibre7 pcalibre6"><span class="c2">That argument must be an actual number</span></li></ul><ul class="c22"><li class="pcalibre c23"><span class="calibre3">The other way is through the constructor </span><span class="c25">plus</span><span class="c2">:</span></li></ul><ul class="c22"><li class="pcalibre7 pcalibre6"><span class="calibre3">A </span><span class="c25">plus</span><span class="c2">&nbsp;takes two arguments</span></li><li class="pcalibre7 pcalibre6"><span class="calibre3">Both arguments must be </span><span class="c25">Exp</span><span class="c2">s</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">If it helps as you read what follows, this is very analogous to the following Java pseudocode skeleton (or the analog with Python dataclasses):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">abstract class Exp {}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">class num extends Exp {</span></p><p class="c4"><span class="c34">&nbsp; num(Number n) { … }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">class plus extends Exp {</span></p><p class="c4"><span class="c34">&nbsp; plus(Exp left, Exp right) { … }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s look at how some of the previous examples would be represented:</span></p><p class="c3"><span class="c2"></span></p><a id="calibre_link-388"></a><a id="calibre_link-389"></a><table class="c37"><tbody class="calibre13"><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c40"><span class="c41">Surface Syntax</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c40"><span class="c41">AST</span></p></td></tr><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c4"><span class="c25">1</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c42"><span class="c34">(num 1)</span></p></td></tr><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c4"><span class="c25">2.3</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c42"><span class="c34">(num 2.3)</span></p></td></tr><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c4"><span class="c25">1 + 2</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c42"><span class="c34">(plus (num 1) (num 2))</span></p></td></tr><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c4"><span class="c25">(1 + 2) + 3</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c42"><span class="c34">(plus (plus (num 1) (num 2))</span></p><p class="c42"><span class="c34">&nbsp; &nbsp; &nbsp; (num 3))</span></p></td></tr><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c4"><span class="c34">1 + (2 + 3)</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c42"><span class="c34">(plus (num 1)</span></p><p class="c42"><span class="c34">&nbsp; &nbsp; &nbsp; (plus (num 2) (num 3)))</span></p></td></tr><tr class="c38"><td class="c39" colspan="1" rowspan="1"><p class="c4"><span class="c34">1 + ((2 + 3) + 4)</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c42"><span class="c34">(plus (num 1)</span></p><p class="c42"><span class="c34">&nbsp; &nbsp; &nbsp; (plus (plus (num 2)</span></p><p class="c42"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 3))</span></p><p class="c42"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 4)))</span></p></td></tr></tbody></table><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Observe a few things about these examples:</span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">The datatype definition does not let us </span><span class="c6">directly</span><span class="calibre3">&nbsp;represent surface syntax terms such as </span><span class="c25">1 + 2 + 3 + 4</span><span class="c2">; any ambiguity has to be handled by the time we construct the corresponding AST term.</span></li><li class="pcalibre c23"><span class="calibre3">The number representation might look a bit odd: we have a </span><span class="c25">num</span><span class="c2">&nbsp;constructor whose only job is to “wrap” a number. We do this for consistency of representation. As we start writing programs to process these data, it’ll become clear why we did this.</span></li><li class="pcalibre c23"><span class="calibre3">Notice that every significant part of the expression went into its AST representation, though not always in the same way. In particular, the </span><span class="c25">+</span><span class="calibre3">&nbsp;of an addition is represented by the </span><span class="c6">constructor</span><span class="c2">; it is not part of the parameters.</span></li><li class="pcalibre c23"><span class="calibre3">The AST really doesn’t care what surface syntax was used. The last term could instead have been written as<br class="calibre" /><br class="calibre" /></span><span class="c25">(+ 1<br class="calibre" /> &nbsp; (+ (+ 2 3)<br class="calibre" /> &nbsp; &nbsp; &nbsp;4))</span><span class="calibre3"><br class="calibre" /><br class="calibre" />or even as<br class="calibre" /><br class="calibre" /></span><span class="calibre14"><img alt="" src="images/000021.png" title="" class="calibre15" /></span><span class="c2"><br class="calibre" /><br class="calibre" />and it would presumably produce the same AST. </span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In short, ASTs are tree-structured data that </span><span class="c33">represent programs in programs</span><span class="c2">. This is a profound idea! In fact, it’s one of the great ideas of the 20th century, building on the brilliant work of Gödel (encoding), Turing (universal machine), von Neumann (stored program computer), and McCarthy (metacircular interpreter).</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Not every part of the source program has been represented in the AST. For instance, presumably both </span><span class="c25">1 + 2</span><span class="calibre3">&nbsp;and </span><span class="c25">1 &nbsp; &nbsp;+ &nbsp;2</span><span class="c2">&nbsp;would be represented the same way, ignoring the spaces. In practice, a real language implementation does need to know something about the syntax: for instance, to highlight pieces of the program source when there is an error, as DrRacket does. Therefore, real-world implementations use abstract syntax but with metadata relating it back to the source.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-341">
<h1 class="c26" id="calibre_link-390"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-108"><span class="c2">Evaluating Arithmetic</span></h1><h2 class="c21" id="calibre_link-109"><span class="c2">Defining the Evaluator</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Having seen how to represent arithmetic programs, we turn to writing an evaluator program that turns them into answers.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What is the type of this evaluator? Clearly it consumes programs, which here are represented by </span><span class="c25">Exp</span><span class="calibre3">s. What does it produce? In this case, all these expressions are going to produce numbers. For this reason, we’ll call this a calculator, or </span><span class="c25">calc</span><span class="calibre3">&nbsp;for short, for now. We can thus give </span><span class="c25">calc</span><span class="c2">&nbsp;the type</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(calc : (Exp -&gt; Number))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s now try to define its body. Clearly we must have</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; …)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In the body, given an Exp, we will want to take it apart using type-case, which tells us there are two options, each with some additional data (this is the moral equivalent of the method dispatch we’d have used in Java):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) …]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) …])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What happens in the case that the whole expression is already a number? Well, we have our answer, so we just return it. Otherwise, we have to add the two sides:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ l r)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">giving us an overall body of:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ l r)]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Let’s run it to…oops! We get a type error! It tells us that addition is expecting a number, but </span><span class="c25">l</span><span class="calibre3">&nbsp;is not a number: it’s an </span><span class="c25">Exp</span><span class="calibre3">. Ah, that’s because </span><span class="c25">l</span><span class="calibre3">&nbsp;and </span><span class="c25">r</span><span class="calibre3">&nbsp;still represent </span><span class="c6">expressions</span><span class="calibre3">, not the </span><span class="c6">answer</span><span class="c2">&nbsp;that the expressions evaluate to. To fix that, we need something that can turn an expression into a number…which is precisely what we’re defining! Thus, we instead write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ (calc l) (calc r))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The type-checker is happy now. And sure enough, we can confirm that our examples produce what we expect. For instance:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(calc (num 1))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">produces </span><span class="c25">1</span><span class="c2">,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(calc (plus (num 1) (num 2))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">produces </span><span class="c25">3</span><span class="c2">, and</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(plus (num 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (plus (num 2) (num 3)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">produces</span><span class="c25">&nbsp;6</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;We’ve glossed over a detail: we’ve assumed that </span><span class="c25">+</span><span class="calibre3">&nbsp;always means numeric addition (which was already implicit in calling it “</span><span class="c25">plus</span><span class="c2">” in the AST). But some languages allow any number of different types to be “added”: e.g., it can also concatenate strings. In such languages, the name in the AST might be something more generic, and the evaluator would need to handle the different possible behaviors.</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="calibre3">In fact, we’ve glossed over something even more basic: what numeric addition means, or for that matter, even what numbers are. As we see from the Mystery Language: Arithmetic, there are many choices here. In our calculator, we have adopted numbers from plait (in </span><span class="c25">num</span><span class="calibre3">) and addition from plait (by using </span><span class="c25">+</span><span class="calibre3">). Those places in </span><span class="c25">calc</span><span class="c2">&nbsp;also tell us where we would go to change those choices.</span></p></div>

<div class="c" id="calibre_link-56">
<h2 class="c21" id="calibre_link-110"><span class="c2">Testing the Evaluator </span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The examples above are fine, but we should write these in the syntax of </span><span class="c6">tests</span><span class="c2">, so that the computer checks them for us automatically:</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(test (calc (num 1)) 1)</span></p><p class="c4"><span class="c34">(test (calc (num 2.3)) 2.3)</span></p><p class="c4"><span class="c34">(test (calc (plus (num 1) (num 2))) 3)</span></p><p class="c4"><span class="c34">(test (calc (plus (plus (num 1) (num 2))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 3)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 6)</span></p><p class="c4"><span class="c34">(test (calc (plus (num 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (plus (num 2) (num 3))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 6)</span></p><p class="c4"><span class="c34">(test (calc (plus (num 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (plus (plus (num 2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 3))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 4))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 10)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Sure enough, when we run this, Racket confirms that all these tests pass.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Pro Tip:</span><span class="c2">&nbsp;It can get annoying to scan through all this testing output to see whether any of the tests failed. Simply add</span></p><p class="c43"><span class="c34"></span></p><p class="c27"><span class="c34">(print-only-errors #true)</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c2">before your tests and Racket will suppress reporting on the passing tests, so you can focus on the ones that failed: in other words, no news is good news.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In general, test early, often, and extensively. Programming language evaluators translate our thoughts into computer actions. Therefore, it’s critical that they do so precisely. This is why language implementations are some of the most tested software you can imagine (when’s the last time you were stopped by a bug in your language implementation?), and people who will tolerate bugs in just about any other software are much less forgiving of bugs in implementations. </span></p></div>

<div class="c" id="calibre_link-342">
<h2 class="c21" id="calibre_link-111"><span class="c2">Some Subtler Tests</span></h2><p class="c4"><span class="c2">Try the following test:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (calc (plus (num 0.1) (num 0.2))) 0.3)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It succeeds! Are we happy? Suppose we instead write it as:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (calc (plus (num 0.1) (num 0.2))) 1/3)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As expected, it fails: but the error message reveals that the left-hand side evaluated to 0.30000000000000004. This should be a cue that we have actually gotten </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://0.30000000000000004.com/&amp;sa=D&amp;source=editors&amp;ust=1695232021117958&amp;usg=AOvVaw3K_UT0jvSMRzJJKE3HmGaN">floating point</a></span><span class="calibre3">&nbsp;addition. This is because plait treats numbers written with a decimal point, like </span><span class="c25">0.1</span><span class="calibre3">, as </span><span class="c6">floating point</span><span class="calibre3">&nbsp;bitstrings. However, floating point bitstrings cannot precisely represent the number 0.3. In fact, plait’s </span><span class="c25">test</span><span class="calibre3">&nbsp;allows a little bit of numeric slack so that the passing test above works. (This is because in plait, </span><span class="c25">0.3</span><span class="c2">&nbsp;really does precisely represent the number 0.3, because it was written literally and not the result of a floating-point computation.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This reinforces a point we made in passing above and was therefore easy to miss: by adopting plait’s primitives, we have also inherited its semantics. This may or may not be what we wanted! Therefore, when writing an evaluator using a host language, we have to make sure that its semantics are the one we want, otherwise we could be in for an unpleasant surprise. If we want different behavior, we have to implement it explicitly.</span></p></div>

<div class="c" id="calibre_link-57">
<h2 class="c21" id="calibre_link-112"><span class="c2">Conclusion</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This concludes our first look at SImPl: we have </span><span class="c6">represented</span><span class="calibre3">&nbsp;a program in a program, and we have </span><span class="c6">processed</span><span class="calibre3">&nbsp;that represented program in a program. We have just written our first program that processes programs&mdash;now we’re off to the races!</span></p></div>

<div class="c" id="calibre_link-338">
<h1 class="c20" id="calibre_link-113"><span class="c2">Parsing: From Source to ASTs</span></h1><h2 class="c21" id="calibre_link-114"><span class="c2">The Problem</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Earlier we went through the basic steps of the SImPl, but we left open a big question: how do we get programs </span><span class="c6">into</span><span class="c2">&nbsp;the AST representation? Of course, the simplest way is what we already did: to write the AST constructors directly, e.g.,</span></p><p class="c3"><span class="c2"></span></p><p class="c42"><span class="c34">(num 1)</span></p><p class="c44"><span class="c34"></span></p><p class="c42"><span class="c34">(plus (num 1) (num 2))</span></p><p class="c3"><span class="c2"></span></p><p class="c42"><span class="c34">(plus (num 1)</span></p><p class="c42"><span class="c25">&nbsp; &nbsp; &nbsp; (plus (num 2) (num 3)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which, as we noted, has the virtue of also ignoring exactly how the program source was written.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, this can get very tedious. We don’t want to have to write </span><span class="c25">(num …)</span><span class="calibre3">&nbsp;every time we want to write a number, for instance! In particular, the more tedious it is the less likely we are to write many or complex tests, and that would be especially unfortunate. Therefore, we’d like a more convenient surface syntax, along with a </span><span class="c6">program</span><span class="c2">&nbsp;to translate that into ASTs.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">As we have already seen, there is a large number of surface syntaxes we can use, and we aren’t even limited to textual syntax: it could be graphical; spoken; gestural (imagine you’re in a virtual reality environment); and so on. As we have noted, this wide range of modalities is important&mdash;especially so if the programmer has physical constraints&mdash;but it’s outside the range of our current study. Even with textual syntax, we have to deal with issues like ambiguity (e.g., order of operations in arithmetic).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In general, the process of converting the input syntax into ASTs is called </span><span class="c6">parsing</span><span class="c2">. We could write a whole booklet just on parsing…so we won’t. Instead, we’re going to pick one syntax that strikes a reasonable balance between convenience and simplicity, which is the parenthetical syntax of Racket, and has special support in plait. That is, we will write the above examples as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">1</span></p><p class="c4"><span class="c34">(+ 1 2)</span></p><p class="c4"><span class="c34">(+ 1 (+ 2 3))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and see how Racket can help us make these convenient to work with. In fact, in this book we will follow a convention (that Racket doesn’t care about, because it treats </span><span class="c25">()</span><span class="calibre3">, </span><span class="c25">[]</span><span class="calibre3">, and </span><span class="c25">{}</span><span class="calibre3">&nbsp;interchangeably): we’ll write programs to be represented using </span><span class="c25">{}</span><span class="calibre3">&nbsp;instead of </span><span class="c25">()</span><span class="c2">. Thus, the above three programs become</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">1</span></p><p class="c4"><span class="c34">{+ 1 2}</span></p><p class="c4"><span class="c25">{+ 1 {+ 2 3}}</span></p></div>

<div class="c" id="calibre_link-61">
<h2 class="c21" id="calibre_link-115"><span class="c2">S-Expressions</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">There is a name for this syntax: these are called </span><span class="c6">s-expressions</span><span class="calibre3">&nbsp;(the </span><span class="c6">s-</span><span class="calibre3">&nbsp;is for historical reasons). In plait, we will write these expressions </span><span class="c6">preceded by a back-tick</span><span class="calibre3">&nbsp;(</span><span class="c25">`</span><span class="calibre3">). A back-tick followed by a Racket term is of type </span><span class="c25">S-Exp</span><span class="c2">. Here are examples of s-expressions:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">`1</span></p><p class="c4"><span class="c34">`2.3</span></p><p class="c4"><span class="c34">`-40</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These are all numeric s-expressions. We can also write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">`{+ 1 2}</span></p><p class="c4"><span class="c34">`{+ 1 {+ 2 3}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It’s not obvious, but these are actually </span><span class="c6">list</span><span class="c2">&nbsp;s-expressions. We can tell by asking</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (s-exp-list? `1)</span></p><p class="c4"><span class="c34">- Boolean</span></p><p class="c4"><span class="c34">#f</span></p><p class="c4"><span class="c34">&gt; (s-exp-list? `{+ 1 2})</span></p><p class="c4"><span class="c34">- Boolean</span></p><p class="c4"><span class="c34">#t</span></p><p class="c4"><span class="c34">&gt; (s-exp-list? `{+ 1 {+ 2 3}})</span></p><p class="c4"><span class="c34">- Boolean</span></p><p class="c4"><span class="c34">#t</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So the first is not but the second two are; similarly,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (s-exp-number? `1)</span></p><p class="c4"><span class="c34">- Boolean</span></p><p class="c4"><span class="c34">#t</span></p><p class="c4"><span class="c34">&gt; (s-exp-number? `{+ 1 {+ 2 3}})</span></p><p class="c4"><span class="c34">- Boolean</span></p><p class="c4"><span class="c34">#f</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The </span><span class="c25">S-Exp</span><span class="c2">&nbsp;type is a container around the actual number or list, which we can extract:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (s-exp-&gt;number `1)</span></p><p class="c4"><span class="c34">- Number</span></p><p class="c4"><span class="c34">1</span></p><p class="c4"><span class="c34">&gt; (s-exp-&gt;list `{+ 1 2})</span></p><p class="c4"><span class="c34">- (Listof S-Exp)</span></p><p class="c4"><span class="c34">(list `+ `1 `2)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now: </span><span class="calibre3">What happens if you apply </span><span class="c25">s-exp-&gt;number</span><span class="calibre3">&nbsp;to a list s-exp or </span><span class="c25">s-exp-&gt;list</span><span class="c2">&nbsp;to a number s-expression? Or either to something that isn't an s-expression at all? Try it right now and find out! Do you get somewhat different results?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s look at that last output above a bit more closely. The resulting list has three elements, two of which are numbers, but the third is something else:</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">`+</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">is a </span><span class="c6">symbol</span><span class="calibre3">&nbsp;s-expressions. Symbols are like strings but somewhat different in operations and performance. Whereas there are numerous string operations (like substrings), symbols are treated atomically; other than being converted to strings, the only other operation they support is equality. But in return, symbols can be checked for equality in </span><span class="c6">constant</span><span class="c2">&nbsp;time.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Symbols have the same syntax as Racket variables, and hence are perfect for representing variable-like things. Thus</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (s-exp-symbol? `+)</span></p><p class="c4"><span class="c34">- Boolean</span></p><p class="c4"><span class="c34">#t</span></p><p class="c4"><span class="c34">&gt; (s-exp-&gt;symbol `+)</span></p><p class="c4"><span class="c34">- Symbol</span></p><p class="c4"><span class="c34">'+</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This output shows how symbols are written in Racket: with a single-quote (</span><span class="c25">'</span><span class="calibre3">). </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There are other kinds of s-expressions as well, but this is all we need for now! With this, we can write our first parser!</span></p></div>

<div class="c" id="calibre_link-345">
<h2 class="c21" id="calibre_link-116"><span class="c2">Primus Inter Parsers</span></h2><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now: </span><span class="c2">Think about what type we want for our parser.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What does our parser need to produce? Whatever the calculator consumes, i.e., </span><span class="c25">Expr</span><span class="calibre3">. What does it consume? Program source expressions written in a “convenient” syntax, i.e., </span><span class="c25">S-Exp</span><span class="c2">. Hence, its type must be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(parse : (S-Exp -&gt; Exp))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That is, it converts the human-friendly(ier) syntax into the computer’s internal representation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Writing this requires a certain degree of pedantry. First, we need a conditional to check what kind of s-exp we were given:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (parse s)</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(s-exp-number? s) …]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(s-exp-list? s) …]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">If it’s a numeric s-exp, then we need to extract the number and pass it to the </span><span class="c25">num</span><span class="c2">&nbsp;constructor:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(num (s-exp-&gt;number s))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Otherwise, we need to extract the list and check whether the first thing in the list is an addition symbol. If it is not, we signal an error:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([l (s-exp-&gt;list s)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(if (symbol=? '+</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(s-exp-&gt;symbol (first l)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;…</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'parse "list not an addition")))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Otherwise, we create a plus term by recurring on the two sub-pieces.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (plus (parse (second l))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (parse (third l)))</span></p><p class="c4"><span class="c25">&nbsp;</span></p><p class="c4"><span class="c2">Putting it all together:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (parse s)</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(s-exp-number? s)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(num (s-exp-&gt;number s))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(s-exp-list? s)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([l (s-exp-&gt;list s)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(if (symbol=? '+</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(s-exp-&gt;symbol (first l)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(plus (parse (second l))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(parse (third l)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'parse "list not an addition")))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It’s all a bit much, but fortunately this is about as hard as parsing will get in this book! Everything you see from now on will basically be this same sort of pattern, which you can freely copy.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We should, of course, make sure we’ve got good tests for our parser. For instance:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (parse `1) (num 1))</span></p><p class="c4"><span class="c34">(test (parse `2.3) (num 2.3))</span></p><p class="c4"><span class="c34">(test (parse `{+ 1 2}) (plus (num 1) (num 2)))</span></p><p class="c4"><span class="c34">(test (parse `{+ 1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{+ {+ 2 3}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4}})</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (plus (num 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (plus (plus (num 2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 3))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (num 4))))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;Are there other kinds of tests we should have written?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We have only written </span><span class="c6">positive</span><span class="calibre3">&nbsp;tests. We can also write </span><span class="c6">negative</span><span class="c2">&nbsp;tests for situations where we expect errors:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test/exn (parse `{1 + 2}) "")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">test/exn</span><span class="calibre3">&nbsp;takes a string that must be a substring of the error message. You might be surprised that the test above uses the empty string rather than, say, </span><span class="c25">"addition"</span><span class="c2">. Try out this example to investigate why. How can you improve your parser to address this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Other situations we should check for include there being too few or too many sub-parts. Addition, for instance, is defined to take exactly two sub-expressions. What if a source program contains none, one, three, four, …? This is the kind of pedantry that parsing calls for.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Once we have considered these situations, we’re in a happy place, because </span><span class="c25">parse</span><span class="calibre3">&nbsp;produces output that </span><span class="c25">calc</span><span class="c2">&nbsp;can consume. We can therefore compose the two functions! Better still, we can write a helper function that does it for us:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(run : (S-Exp -&gt; Number))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (run s)</span></p><p class="c4"><span class="c34">&nbsp; (calc (parse s)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So we can now rewrite our old evaluator tests in a much more convenient way:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (run `1) 1)</span></p><p class="c4"><span class="c34">(test (run `2.3) 2.3)</span></p><p class="c4"><span class="c34">(test (run `{+ 1 2}) 3)</span></p><p class="c4"><span class="c34">(test (run `{+ {+ 1 2} 3})</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 6)</span></p><p class="c4"><span class="c34">(test (run `{+ 1 {+ 2 3}})</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 6)</span></p><p class="c4"><span class="c34">(test (run `{+ 1 {+ {+ 2 3} 4}})</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 10)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Compare this against the </span><span class="c25">calc</span><span class="c2">&nbsp;tests we had earlier!</span></p></div>

<div class="c" id="calibre_link-60">
<h1 class="c26" id="calibre_link-391"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-117"><span class="c2">Evaluating Conditionals</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So far our language has had only arithmetic. Building on Mystery Language: Conditionals, we will now examine how to extend our language to also support conditionals. There can be quite complex conditional expressions in real languages, but for our purposes it will suffice to have an </span><span class="c25">if</span><span class="c2">&nbsp;with three parts: the conditional, the then-branch, and the else-branch. Later, when we learn how to extend the language, we can see how to layer more sophisticated conditional expressions atop this.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In SImPl, we have to do at least two things:</span></p><p class="c3"><span class="c2"></span></p><ol class="c45" start="1"><li class="c46 pcalibre8"><span class="c2">Extend the datatype representing expressions to include conditionals.</span></li><li class="c46 pcalibre8"><span class="c2">Extend the evaluator to handle (the representation of) these new expressions.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Optionally, if we have a parser, we should also</span></p><p class="c3"><span class="c2"></span></p><ol class="c22" start="3"><li class="c46 pcalibre8"><span class="c2">Extend the parser to produce these new representations.</span></li></ol></div>

<div class="c" id="calibre_link-343">
<h2 class="c21" id="calibre_link-118"><span class="c2">Extending the AST</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Because we have fixed our conditionals to have three parts, we just need to represent that in the AST. This is straightforward:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Exp</span></p><p class="c4"><span class="c34">&nbsp; [num (n : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [plus (left : Exp) (right : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [cnd (test : Exp) (then : Exp) (else : Exp)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The real work will happen in the evaluator.</span></p></div>

<div class="c" id="calibre_link-58">
<h2 class="c21" id="calibre_link-119"><span class="c2">Extending the Calculator</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Clearly, adding conditionals doesn’t change what our calculator previously did, we can leave that intact, and just focus on the handling of </span><span class="c25">if</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ (calc l) (calc r))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(cnd c t e) …]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Indeed, we can recursively evaluate each term, in case it’s useful:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ (calc l) (calc r))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(cnd c t e) … (calc c) … (calc t) … (calc e) …]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s take these one at a time.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But now we run into a problem. What is the result of calling </span><span class="c25">(calc c)</span><span class="calibre3">? We expect it to be some kind of Boolean value. But we don’t </span><span class="c6">have</span><span class="c2">&nbsp;Boolean values in the language!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That’s not all. Above, we have written both </span><span class="c25">(calc t)</span><span class="calibre3">&nbsp;and </span><span class="c25">(calc e)</span><span class="calibre3">. However, the whole point of a conditional is that we </span><span class="c6">don’t</span><span class="c2">&nbsp;want to evaluate both, only one. So we have to pick which one to evaluate based on some criterion.</span></p></div>

<div class="c" id="calibre_link-347">
<h2 class="c21" id="calibre_link-120"><span class="c2">The Design Space of Conditionals</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Even the simplest conditional exposes us to many variations in language design. The intent is that test-expression is evaluated first; if it results in a true value then (only) the then-expression is evaluated, else (only) the else-expression is evaluated. (We usually refer to these two parts as </span><span class="c6">branches</span><span class="c2">, since the program’s control must take one or the other.) However, even this simple construct results in at least three different, mostly independent design decisions:</span></p><p class="c3"><span class="c2"></span></p><ol class="c47" start="1"><li class="pcalibre9 pcalibre10"><span class="calibre3">What kind of values can the test-expression be? In some languages they must be Boolean values (two values, one representing truth and the other falsehood). In other languages this expression can evaluate to just about any value, with some set&mdash;colloquially called </span><span class="c6">truthy</span><span class="calibre3">&mdash;representing truth (i.e., they result in execution of the then-expression) while the remaining ones are </span><span class="c6">falsy</span><span class="c2">, meaning they cause the else-expression to run.<br class="calibre" /><br class="calibre" />Initially, it may seem attractive to design a language with several truthy and falsy values: after all, this appears to give the programmer more convenience, permitting non-Boolean-valued functions and expressions to be used in conditionals. However, this can lead to bewildering inconsistencies across languages:<br class="calibre" /><br class="calibre" /></span></li></ol><a id="calibre_link-392"></a><a id="calibre_link-393"></a><table class="c48"><tbody class="calibre13"><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c41">Value</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c41">JavaScript</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c41">Perl</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c41">PHP</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c41">Python</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c41">Ruby</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c34">-1</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c34">0</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c34">""</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c34">"0"</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c34">NaN</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c25">nil</span><span class="calibre3">, </span><span class="c25">null</span><span class="calibre3">, </span><span class="c25">None</span><span class="c2">, undefined</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c34">[]</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr><tr class="c38"><td class="c49" colspan="1" rowspan="1"><p class="c42"><span class="c2">empty map or object</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">falsy</span></p></td><td class="c49" colspan="1" rowspan="1"><p class="c40"><span class="c2">truthy</span></p></td></tr></tbody></table><p class="c27"><span class="calibre3"><br class="calibre" />Of course, it need not be so complex. Scheme, for instance, has only one value that is falsy: false itself (written as </span><span class="c25">#false</span><span class="calibre3">). </span><span class="c6">Every</span><span class="c2">&nbsp;other value is truthy. For those who value allowing non-Boolean values in conditionals, this represents an elegant trade-off: it means a function need not worry that a type-consistent value resulting from a computation might cause a conditional to reverse itself. (For instance, if a function returns strings, it need not worry that the empty string might be treated differently from every other string.) Note that Ruby, which is inspired in part by Scheme, adopted this simple model. Lua, another Scheme-inspired language, is also spartan in its falsy values.<br class="calibre" /></span></p><ol class="c22" start="2"><li class="pcalibre9 pcalibre10"><span class="calibre3">What kind of terms are the branches? Some languages make a distinction between </span><span class="c6">statements</span><span class="calibre3">&nbsp;and </span><span class="c6">expressions</span><span class="calibre3">; in such languages, designers need to decide which of these are permitted. In some languages, there are even two syntactic forms of conditional to reflect these two choices: e.g., in C, </span><span class="c25">if</span><span class="calibre3">&nbsp;uses statements (and does not return any value) while the “ternary operator” (</span><span class="c25">(...?...:...)</span><span class="c2">) permits expressions and returns a value.<br class="calibre" /></span></li><li class="pcalibre9 pcalibre10"><span class="calibre3">If the branches are expressions and hence allowed to evaluate to values, how do the values relate? Many (but not all) languages with static type systems expect the two branches to have the same type [</span><span class="c15"><a class="c10" href="#calibre_link-187">👉</a></span><span class="c2">]. Languages without static type systems usually place no restrictions.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">While writing an earlier version of this very chapter, I stumbled on a strange bug in the Pyret programming language: all numeric s-expressions parsed as </span><span class="c25">s-num</span><span class="calibre3">&nbsp;values except </span><span class="c25">0</span><span class="calibre3">, which parsed as a </span><span class="c25">s-sym</span><span class="calibre3">. Eventually Justin Pombrio reported: “It’s a silly bug with an </span><span class="c25">if</span><span class="calibre3">&nbsp;in JavaScript that’s getting </span><span class="c25">0</span><span class="c2">&nbsp;and thinking it’s false.” Seems fitting.</span></p></div>

<div class="c" id="calibre_link-344">
<h2 class="c21" id="calibre_link-121"><span class="c2">Using Truthy-Falsy Values</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Some languages use truthy-falsy values to handle partial functions. Instead of signaling an error, they return a falsy value when the argument cannot be handled. For instance, it is common to return </span><span class="c25">#false</span><span class="calibre3">&nbsp;in Racket or </span><span class="c25">None</span><span class="c2">&nbsp;in Python as an error code, and a proper value for normal execution. Consider this Racket example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (g s)</span></p><p class="c4"><span class="c25">&nbsp; (+ 1 (or (string-&gt;number s) 0)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This function accepts a string that may or may not represent a number. If it does, it returns one bigger number; otherwise it returns </span><span class="c25">1</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (g "5") 6)</span></p><p class="c4"><span class="c34">(test (g "hello") 1)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This works because </span><span class="c25">string-&gt;number</span><span class="calibre3">&nbsp;returns a number or, if the string is not legal, </span><span class="c25">#false</span><span class="calibre3">. In Racket, all values other than </span><span class="c25">#false</span><span class="calibre3">&nbsp;are truthy. Thus, legitimate strings short-circuit evaluation of the </span><span class="c25">or</span><span class="calibre3">, while non-numeric strings result in </span><span class="c25">0</span><span class="c2">. These therefore serve as a rough-and-ready option types in languages that don’t (or didn’t) have proper datatype constructors.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We will discuss this issue further later in the book [</span><span class="c15"><a class="c10" href="#calibre_link-214">👉</a></span><span class="c2">].</span></p></div>

<div class="c" id="calibre_link-59">
<h2 class="c21" id="calibre_link-122"><span class="c2">Implementing Conditionals</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, so we have many decisions to make! To first get a working evaluator, without having to go beyond numbers, we can use a slightly different conditional construct: one that checks whether evaluates to a special numeric value, such as </span><span class="c25">0</span><span class="calibre3">. That is, instead of a proper </span><span class="c25">if</span><span class="calibre3">, we really have something we might call </span><span class="c25">if0</span><span class="c2">&nbsp;that works only for numbers.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">How do we make this choice? Luckily, we’re writing our interpreter in plait, which of course already has a conditional. Therefore, we can just reuse it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ (calc l) (calc r))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(cnd c t e) (if (zero? (calc c))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(calc t)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(calc e))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that the semantics of the conditional&mdash;that </span><span class="c25">0</span><span class="calibre3">&nbsp;is true, and everything else is false&mdash;is now made manifest in the body of </span><span class="c25">calc</span><span class="c2">. If we want a different semantics, that’s the part of the program to zero into and change.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This solution, and indeed so far our entire evaluator, might feel a bit… disappointing? We have numbers and conditionals, sure, but all we’ve done is (mostly) deferred to plait to handle these. Here are some thoughts on this:</span></p><p class="c3"><span class="c2"></span></p><ol class="c50" start="1"><li class="pcalibre11 pcalibre12"><span class="c2">This is true!</span></li><li class="pcalibre11 pcalibre12"><span class="c2">This is not entirely true. We have made some conscious decisions, like the handling of conditionals.</span></li><li class="pcalibre11 pcalibre12"><span class="c2">In fact, we have made even more decisions, whether or not we were conscious of them, such as the handling of numbers. We just happened to defer those to plait, but we could have made other decisions if we wanted.</span></li><li class="pcalibre11 pcalibre12"><span class="calibre3">This reuse is actually part of the </span><span class="c6">power</span><span class="c2">&nbsp;of an interpreter: it lets you exploit features that have already been built instead of having to re-implement all of them from scratch.</span></li><li class="pcalibre11 pcalibre12"><span class="calibre3">By reusing the </span><span class="c6">host</span><span class="c2">&nbsp;language (here, plait), we can zero in on the differences (like the handling of conditionals), which would otherwise be lost if we had to implement everything. Later we will see stronger departures from the semantics of plait.</span></li></ol></div>

<div class="c" id="calibre_link-52">
<h2 class="c21" id="calibre_link-123"><span class="c2">Adding Booleans</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Okay, so what if we wanted proper Booleans?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Again, to employ SImPl, we need to alter the AST, the evaluator, and the parser.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can add Booleans much like we did numbers: with a constructor that wraps a plait representation of the Boolean.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Exp</span></p><p class="c4"><span class="c34">&nbsp; [num (n : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [bool (b : Boolean)]</span></p><p class="c4"><span class="c34">&nbsp; [plus (left : Exp) (right : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [cnd (test : Exp) (then : Exp) (else : Exp)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It’s very important to keep in mind what the </span><span class="c25">num</span><span class="calibre3">&nbsp;and </span><span class="c25">bool</span><span class="calibre3">&nbsp;constructors stand for. Recall that this is </span><span class="c6">abstract syntax</span><span class="calibre3">: we are just (abstractly) representing the </span><span class="c6">program that the user wrote</span><span class="calibre3">, not the result of its evaluation. Therefore, these constructors are capturing syntactic </span><span class="c6">constants</span><span class="calibre3">&nbsp;in the source program: values like </span><span class="c25">3.14</span><span class="calibre3">&nbsp;and </span><span class="c25">-1</span><span class="calibre3">&nbsp;for the former and </span><span class="c25">#true</span><span class="calibre3">&nbsp;and </span><span class="c25">#false</span><span class="calibre3">&nbsp;for the latter. They do </span><span class="c51">not</span><span class="calibre3">&nbsp;represent compound expressions that will </span><span class="c6">evaluate to</span><span class="calibre3">&nbsp;numbers or Booleans. What an expression will evaluate to, for now, can only be determined by running it. Later [</span><span class="c15"><a class="c10" href="#calibre_link-53">👉</a></span><span class="c2">], we will see there are other ways of doing it too!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;The abstract syntax does not dictate what concrete syntax we use. For instance, we may write numbers as </span><span class="c25">3</span><span class="calibre3">&nbsp;or as </span><span class="c25">III</span><span class="calibre3">. We might write Boolean values as </span><span class="c25">#t</span><span class="calibre3">, </span><span class="c25">#true</span><span class="calibre3">, </span><span class="c25">true</span><span class="calibre3">, </span><span class="c25">True</span><span class="calibre3">, …. We may even have different concrete syntaxes for the same abstract syntax. This is precisely the </span><span class="c6">abstraction</span><span class="c2">&nbsp;that abstract syntax provides!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Easy peasy! This naturally suggests what we should do in the evaluator:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(bool b) b]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (+ (calc l) (calc r))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(cnd c t e) (if (zero? (calc c))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(calc t)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(calc e))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Oh…oops. This version of </span><span class="c25">calc</span><span class="c2">&nbsp;doesn’t type-check, because our calculator is supposed to return only numbers, not Booleans!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In fact, we had to know that this couldn’t last. We aren’t interested only in calculators; we want to build full-fledged programming languages. They have a wide range of values, i.e., answers: numbers, Boolean, strings, images, functions, and more.</span></p></div>

<div class="c" id="calibre_link-346">
<h2 class="c21" id="calibre_link-124"><span class="calibre3">The Value </span><span class="calibre3">Datatype</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Therefore, we first need to define a datatype that reflects the different kinds of values that an evaluator can produce. We will follow a convention and call the return type constructors </span><span class="c25">…V</span><span class="calibre3">&nbsp;to distinguish from the inputs. Dually, we’ll call the inputs </span><span class="c25">…E</span><span class="c2">&nbsp;(for expressions) to distinguish from the outputs.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First we’ll rename our expressions:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Exp</span></p><p class="c4"><span class="c34">&nbsp; [numE (n : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [boolE (b : Boolean)]</span></p><p class="c4"><span class="c34">&nbsp; [plusE (left : Exp) (right : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [cndE (test : Exp) (then : Exp) (else : Exp)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(nothing has changed other than the </span><span class="c6">names</span><span class="c2">&nbsp;of the constructors).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we introduce a </span><span class="c25">Value</span><span class="c2">&nbsp;datatype to represent the types of answers our evaluator can produce:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Value</span></p><p class="c4"><span class="c34">&nbsp; [numV (the-number : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [boolV (the-boolean : Boolean)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We update the type of our evaluator:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(calc : (Exp -&gt; Value))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and the early parts are easy:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE n) (numV n)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(boolE b) (boolV b)]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; …))</span></p></div>

<div class="c" id="calibre_link-76">
<h2 class="c21" id="calibre_link-125"><span class="c2">Updating the Evaluator</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now suppose we try to use our existing code:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">[(plusE l r) (+ (calc l) (calc r))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This has two problems. The first is we can’t return a number; we have to return a </span><span class="c25">numV</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">[(plusE l r) (numV (+ (calc l) (calc r)))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But now we run into a subtler problem. The type-checker is not happy with this program. Why?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Because the result of </span><span class="c25">calc</span><span class="calibre3">&nbsp;is a </span><span class="c25">Value</span><span class="calibre3">, and </span><span class="c25">+</span><span class="calibre3">&nbsp;consumes only </span><span class="c25">Number</span><span class="calibre3">s. Indeed, the type checker is forcing us to </span><span class="c6">make a decision</span><span class="calibre3">&nbsp;here: what happens if one of the sides of </span><span class="c25">+</span><span class="c2">&nbsp;does not evaluate to a number?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First, let’s build an abstraction to handle this, so that we can keep the core of the interpreter relatively clean:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">[(plusE l r) (add (calc l) (calc r))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we can defer all the logic of evaluating </span><span class="c25">+</span><span class="calibre3">&nbsp;to </span><span class="c25">add</span><span class="calibre3">. </span><span class="c6">Now we have to make a semantic decision</span><span class="c2">. Should we be allowed to “add” two Boolean values? What about adding a number to a Boolean or vice versa? Though there isn’t quite a SMoL decision here&mdash;some languages are very strict while others are very permissive&mdash;the least-non-standard policy is to require both branches to evaluate to numbers, which we would express as follows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (add v1 v2)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Value v1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numV n1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case Value v2</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(numV n2) (numV (+ n1 n2))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[else (error '+ "expects RHS to be a number")])]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [else (error '+ "expects LHS to be a number")]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that these </span><span class="c25">else</span><span class="c2">&nbsp;clauses can easily represent other decisions. We can embed an entire family of mystery languages in the different choices available!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Why did we write the numV constructor in </span><span class="c25">add</span><span class="calibre3">&nbsp;rather than in </span><span class="c25">calc</span><span class="c2">?</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Pro Tip:</span><span class="c2">&nbsp;You’ve just added a complex chunk of code. Now would be a very good time to test your evaluator. Here are two things to consider:</span></p><p class="c43"><span class="c2"></span></p><ol class="c52" start="1"><li class="pcalibre14 pcalibre13"><span class="calibre3">Right now the code for conditionals </span><span class="c6">also</span><span class="calibre3">&nbsp;does not type-check. You may find it convenient to replace the entire RHS with something semantically incorrect but type-correct, like </span><span class="c25">(numV 0)</span><span class="c2">, so you restore your working evaluator.<br class="calibre" /></span></li><li class="pcalibre14 pcalibre13"><span class="calibre3">Don’t forget to test for the error cases! You would do so using </span><span class="c25">test/exn</span><span class="calibre3">. For instance:<br class="calibre" /><br class="calibre" /></span><span class="c34">(test/exn (calc (plusE (numE 4) (boolE #false))) "RHS")</span></li></ol><p class="c43"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s now turn our attention to the conditional (with the constructor name updated):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">[(cndE c t e) …]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The core logic must clearly be similar: check something about the condition, and based on it, evaluate only one of the other two clauses. Once again, we have to make decisions about how we handle the conditional: should we strictly require a Boolean value, or should we make a truthy/falsy decision? We can again defer that to a helper function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(cndE c t e) (if (boolean-decision (calc c))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (calc t)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (calc e))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Again, the least non-standard policy, and one that sets up later material, is to be strict about requiring a Boolean:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (boolean-decision v)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Value v</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(boolV b) b]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [else (error 'if "expects conditional to evaluate to a boolean")]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But again, starting from a strict interpretation, we can see where we can give in to any urges we feel to design a more liberal semantics: by replacing the </span><span class="c25">else</span><span class="c2">&nbsp;clause.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe, by the way, that we did something different with conditionals than we did for addition. With </span><span class="c25">add</span><span class="calibre3">, we evaluated both branches and gave it their corresponding </span><span class="c25">Value</span><span class="calibre3">s. It would be a terrible idea to do that with conditionals, because the entire point of a conditional is to </span><span class="c33">not</span><span class="calibre3">&nbsp;evaluate one of the branches! We could have sent the ASTs for the branches to a helper function, but what we have done above also works well: it localizes the </span><span class="c6">variation</span><span class="c2">&nbsp;in the semantics to the helper function, but keeps what is not expected to change (the fact that a conditional syntax leads to a conditional evaluation) in the core of the evaluator.</span></p></div>

<div class="c" id="calibre_link-26">
<h1 class="c20" id="calibre_link-126"><span class="c2">Evaluating Local Binding</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Most programming languages have some notion of </span><span class="c6">local binding</span><span class="c2">. There are two words there, which we’ll tease apart:</span></p><ul class="c22"><li class="pcalibre c23"><span class="c6">Binding</span><span class="c2">&nbsp;means to associate names with values. For instance, when we call a function, the act of calling associates (“binds”) the formal parameters with the actual values.</span></li><li class="pcalibre c23"><span class="c6">Local</span><span class="c2">&nbsp;means they are limited to some region of the program, and not available outside that region.</span></li></ul><p class="c4"><span class="c2">For instance, in many languages we can write something like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">fun f(x):</span></p><p class="c4"><span class="c34">&nbsp; y = 2</span></p><p class="c4"><span class="c34">&nbsp; x + y</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This seems clear enough. But here is a more subtle program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">fun f(x):</span></p><p class="c4"><span class="c34">&nbsp; for(y from 0 to 10):</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; print(x + y)</span></p><p class="c4"><span class="c34">&nbsp; y</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Is that legal? It depends on whether the </span><span class="c25">y</span><span class="calibre3">&nbsp;is still “alive” or “active” or “visible” or whatever other phrase you would like; formally, we would say, it depends on whether </span><span class="c25">y</span><span class="calibre3">&nbsp;is </span><span class="c6">in scope</span><span class="calibre3">. Specifically, we’d ask whether the last </span><span class="c25">y</span><span class="calibre3">&nbsp;is a </span><span class="c6">bound</span><span class="calibre3">&nbsp;instance of the </span><span class="c6">binding</span><span class="calibre3">&nbsp;that takes place in the </span><span class="c25">for</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This is complicated! Many languages do rather odd, complicated, and certainly unintuitive things, as you will see from Mystery Languages. These odd things are not really part of SMoL; if anything, they are a violation of it.</span></p></div>

<div class="c" id="calibre_link-366">
<h2 class="c21" id="calibre_link-127"><span class="c2">A Syntax for Local Binding</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Part of the problem is actually syntactic. When we write a program like the above, there’s no clear beginning or ending of the scope of </span><span class="c25">y</span><span class="calibre3">&nbsp;(i.e., the region where </span><span class="c25">y</span><span class="calibre3">&nbsp;is bound). This is actually a great virtue of parenthetical syntax: it </span><span class="c6">suggests</span><span class="calibre3">&nbsp;a clear region (between the parentheses). Of course, we have a responsibility to make sure that that’s where the variable </span><span class="c6">is</span><span class="c2">&nbsp;actually bound (though this is something that we’ll find, in a little while, is not so trivial).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Following the syntax of Racket, we’ll add a new construct to our language. At this point it’s getting a bit tricky to keep track of the full syntax, so we’ll use a notation called BNF (short for Backus-Naur Form). Let’s start with our arithmetic language:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&lt;expr&gt; ::= &lt;num&gt;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {+ &lt;expr&gt; &lt;expr&gt;}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">which reads as “define (</span><span class="c25">::=</span><span class="calibre3">) </span><span class="c25">expr</span><span class="calibre3">&nbsp;(short for expression) to be either a number or (</span><span class="c25">|</span><span class="calibre3">) the surface syntax consisting of an opening brace (</span><span class="c25">{</span><span class="calibre3">), a plus sign (</span><span class="c25">+</span><span class="calibre3">), an </span><span class="c25">expr</span><span class="calibre3">, another </span><span class="c25">expr</span><span class="calibre3">, and a closing brace”. BNF gives us a convenient notation for the </span><span class="c6">grammar</span><span class="calibre3">&nbsp;of a language through its concrete syntax, and our abstract syntax will usually correspond very directly to the BNF in a very natural manner. (Observe, however, that in the BNF, we simply say that each sub-expression is an </span><span class="c25">expr</span><span class="c2">, because that’s all we need to know to properly form programs. However, in the AST, we give the parts different names to tell them apart.)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Notation:</span><span class="calibre3">&nbsp;BNF is divided into </span><span class="c6">terminals</span><span class="calibre3">&nbsp;and </span><span class="c6">non-terminals</span><span class="calibre3">. Non-terminals are placeholders like </span><span class="c25">expr</span><span class="calibre3">&nbsp;and </span><span class="c25">num</span><span class="calibre3">&nbsp;above: they stand for many more possibilities (an </span><span class="c25">expr</span><span class="calibre3">&nbsp;above can be replaced with one of two possibilities (for now), while there are many possible ways to write </span><span class="c25">num</span><span class="c2">s). They are given this name because the grammar doesn’t “terminate” here: the name is a place-holder that can (and must) be further expanded. </span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="calibre3">The convention is to write non-terminals inside </span><span class="c25">&lt;</span><span class="calibre3">pointy brackets</span><span class="c25">&gt;</span><span class="calibre3">. Terminals, in contrast, are concrete syntax, like </span><span class="c25">{</span><span class="calibre3">, </span><span class="c25">}</span><span class="calibre3">, and </span><span class="c25">+</span><span class="calibre3">&nbsp;above. They are so-called because they stand for themselves and can’t be expanded further. They are sometimes also called </span><span class="c6">literals</span><span class="c2">, because they must be written literally as shown. For this reason, they are not surrounded by any decorative symbols. Everything is written literally unless it’s a non-terminal, in which case it’s replaced by something according to the definition of the non-terminal.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we can define an extended language:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&lt;expr&gt; ::= &lt;num&gt;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {+ &lt;expr&gt; &lt;expr&gt;}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {let1 {&lt;var&gt; &lt;expr&gt;} &lt;expr&gt;}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">That is, we’re adding a new language construct, </span><span class="c25">let1</span><span class="calibre3">, which has three parts: a variable (</span><span class="c25">var</span><span class="calibre3">) and two expressions (the two </span><span class="c25">expr</span><span class="c2">’s). </span></p></div>

<div class="c" id="calibre_link-321">
<h2 class="c21" id="calibre_link-128"><span class="c2">The Meaning of Local Binding</span></h2><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="calibre3">&nbsp;Here are some examples of this new construct; what do you </span><span class="c6">expect</span><span class="c2">&nbsp;each one to produce?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ x x}}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {let1 {y 2}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; {+ x y}}}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {let1 {y 2}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; {let1 {x 3}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; {+ x y}}}}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;{let1 {x 2} x}}}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {let1 {x 2} x}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;x}}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">x</span></p><p class="c3"><span class="c34"></span></p><p class="c27"><span class="c33">Do Now: </span><span class="c2">Oh, did you notice something? None of the above programs is syntactically legal! Why?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It’s because there is no syntax yet for variables. Our syntax permits us to </span><span class="c6">bind</span><span class="calibre3">&nbsp;variables but not to </span><span class="c6">use</span><span class="c2">&nbsp;them. So we have to fix that:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&lt;expr&gt; ::= &lt;num&gt;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {+ &lt;expr&gt; &lt;expr&gt;}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| {let1 {&lt;var&gt; &lt;expr&gt;} &lt;expr&gt;}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &lt;var&gt;</span></p><p class="c4"><span class="c2">&nbsp;</span></p><p class="c4"><span class="c2">Now the above terms are all syntactically valid, so we can go back to the question of what they should evaluate to.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The first two programs are pretty obvious:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c25">&nbsp; {+ x x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">should evaluate to 2, and</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {let1 {y 2}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; {+ x y}}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">should evaluate to 3.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">How about this program?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {let1 {y 2}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; {let1 {x 3}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; {+ x y}}}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here we see the advantage of the parenthetical notation. In a more conventional syntax, this might correspond to</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">x = 1</span></p><p class="c4"><span class="c34">y = 2</span></p><p class="c4"><span class="c34">x = 3</span></p><p class="c4"><span class="c34">x + y</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where any number of things could happen: we might have two different </span><span class="c25">x</span><span class="calibre3">’s; we might have an </span><span class="c25">x</span><span class="calibre3">&nbsp;bound and then modified; and in some languages, an introduction of </span><span class="c25">x</span><span class="calibre3">&nbsp;could be “lifted” so that it’s no longer clear which </span><span class="c25">x</span><span class="calibre3">&nbsp;is most recent. With our parenthetical syntax, though, it’s pretty clear what scopes we want. To determine the value, we can rely on our old friend, substitution. However, when we substitute the outer </span><span class="c25">x</span><span class="calibre3">, we expect that to stop at the point where the inner </span><span class="c25">x</span><span class="calibre3">&nbsp;begins: that is, the inner </span><span class="c25">x</span><span class="calibre3">&nbsp;</span><span class="c6">shadows</span><span class="calibre3">&nbsp;the outer one. Hence, the result should be </span><span class="c25">5</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now: </span><span class="calibre3">The example above is uninteresting in that the outer </span><span class="c25">x</span><span class="calibre3">&nbsp;never sees any use. What kind of program might we write that has two </span><span class="c25">let</span><span class="calibre3">&nbsp;bindings of </span><span class="c25">x</span><span class="calibre3">&nbsp;that lets us clearly see that there are two </span><span class="c25">x</span><span class="c2">’s?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That’s what this program shows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ x</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp;{let1 {x 2} x}}}</span></p><p class="c4"><span class="c2">&nbsp;</span></p><p class="c4"><span class="calibre3">It seems fairly clear that the left </span><span class="c25">x</span><span class="calibre3">&nbsp;in the addition should be </span><span class="c25">1</span><span class="calibre3">, while </span><span class="c25">x</span><span class="calibre3">&nbsp;in the right expression should be shadowed and hence should evaluate to </span><span class="c25">2</span><span class="calibre3">. The sum should therefore be </span><span class="c25">3</span><span class="c2">. Incidentally, DrRacket is useful in such cases, because we can write an equivalent expression in #lang racket&mdash;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([x 1])</span></p><p class="c4"><span class="c34">&nbsp; (+ x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([x 2]) </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;x)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">&mdash;and hover over the last </span><span class="c25">x</span><span class="c2">, and DrRacket (for Racket, which represents a fairly ideal form of SMoL) will automatically draw a blue arrow showing where the variable is bound:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre16"><img alt="" src="images/000002.png" title="" class="calibre17" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now for a more complex example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {let1 {x 2} x}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp;x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here, it’s especially useful to turn to substitution to determine the answer. Again, it seems clear that </span><span class="c25">x</span><span class="calibre3">&nbsp;in the left expression is shadowed and hence should be </span><span class="c25">2</span><span class="calibre3">. The big question, of course, is what about the </span><span class="c25">x</span><span class="c2">&nbsp;on the right hand side of the addition (i.e., on the last line)?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here, again, conventional textual syntax is fraught with ambiguity: is</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">x = 2</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">on the left a </span><span class="c6">binding</span><span class="calibre3">&nbsp;of a new </span><span class="c25">x</span><span class="calibre3">&nbsp;or a</span><span class="c6">&nbsp;modification</span><span class="calibre3">&nbsp;of the outer </span><span class="c25">x</span><span class="calibre3">? Those are two very different things! But with our syntax it’s much clearer that it </span><span class="c6">should</span><span class="calibre3">&nbsp;be the former, not the latter. Thus, by substitution, the outer </span><span class="c25">x</span><span class="calibre3">&nbsp;is replaced by </span><span class="c25">1</span><span class="c2">, giving</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{+ {let1 {x 2} x}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp;1}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">in which we perform one more substitution, producing</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{+ 2</span></p><p class="c4"><span class="c25">&nbsp; &nbsp;1}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and hence </span><span class="c25">3</span><span class="c2">. This time, DrRacket is especially useful confirmation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre18"><img alt="" src="images/000020.png" title="" class="calibre19" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That leaves just one program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">x</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Because </span><span class="c25">x</span><span class="c2">&nbsp;is not bound anywhere, this is just a syntax error.</span></p></div>

<div class="c" id="calibre_link-80">
<h2 class="c21" id="calibre_link-129"><span class="c2">Static Scoping</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The program</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {let1 {x 2} x}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp;x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">introduces us to a very important concept: indeed, one of the central ideas behind SMoL. This is that a variable’s binding is determined by </span><span class="c6">its position in the source program</span><span class="calibre3">, and </span><span class="c33">not</span><span class="calibre3">&nbsp;by </span><span class="c6">the order of the program’s execution</span><span class="calibre3">. That is, the </span><span class="c25">x</span><span class="c2">&nbsp;on the last line is bound by the same place&mdash;and hence obtains the same value&mdash;irrespective of other bindings that took place before it was evaluated. To understand this better, let’s see a progression of programs:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {let1 {x 2} x}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp;x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">You might think it’s okay whether it produces </span><span class="c25">3</span><span class="calibre3">&nbsp;or </span><span class="c25">4</span><span class="c2">. How about this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {if true</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{let1 {x 2} x}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">You should expect the same out of this: the conditional is always true, so clearly we are always going to evaluate the inner binding, so its answer should be the same as for the previous program. But how about this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {if true</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c53">{let1 {x 2} x}</span><span class="c34">}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now you might not be so sure. Since the conditional is never taken, you probably don’t want the inner binding to have an influence. That is, you are willing to </span><span class="c6">let the program’s control flow influence the bindings</span><span class="c2">. On its face that sounds reasonable, but now how about this program?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c25">&nbsp; {+ {if </span><span class="c54">{random}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{let1 {x 2} x}}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">or</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c25">&nbsp; {+ {if </span><span class="c54">{moon-is-currently-full}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{let1 {x 2} x}}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Are you okay with the binding structure changing every two weeks? What about this version:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {x 1}</span></p><p class="c4"><span class="c34">&nbsp; {+ {if {moon-is-currently-full}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{let1 {</span><span class="c53">y</span><span class="c34">&nbsp;2} x}}</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; </span><span class="c53">y</span><span class="c25">}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Then, depending on the phase of the moon, the program either produces an answer or results in an unbound-variable error.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The decision to let control flow determine binding is called </span><span class="c6">dynamic scope</span><span class="calibre3">. It is the one </span><span class="c33">unambiguously wrong</span><span class="c2">&nbsp;design decision in programming languages. It has a long and sordid history: the original Lisp had it, and it was not until over a decade later that Scheme fixed it. Unfortunately, those who don’t know history are doomed to repeat it: early versions of Python and JavaScript also had dynamic scope. Taking it back out has been a herculean effort. Dynamic scope means:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">We can’t be sure about the binding structure of our programs.</span></li><li class="pcalibre c23"><span class="c2">The evaluator can’t be sure, either.</span></li><li class="pcalibre c23"><span class="c2">Nor can programmer tools.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">For instance, a program refactoring tool needs to know binding structure: even a simple “variable renaming” tool needs to know which variables to rename. In DrRacket, there is no ambiguity, so variable renaming works correctly. This is not true in other languages: see, for instance, Appendix 2 of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&amp;sa=D&amp;source=editors&amp;ust=1695232021187018&amp;usg=AOvVaw137u3e7Dklg2SwW_JHiS7q">this paper</a></span><span class="c2">&nbsp;on the semantics of Python.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The opposite of dynamic scope&mdash;where we can determine the binding by following the structure of the AST&mdash;is called </span><span class="c6">static scope</span><span class="c2">. Static scope is a defining characteristic of SMoL.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Dynamic scope occurred in early implementations because it was easy to obtain: it was the default behavior. We have to work a bit harder to obtain static scope, as we will see.</span></p></div>

<div class="c" id="calibre_link-27">
<h2 class="c21" id="calibre_link-130"><span class="c2">An Evaluator for Local Binding</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now that we’ve seen what behavior we want, we should implement it. That is, we’ll extend our calculator to handle local binding (a feature you may well have wished your calculator had). To reflect that our calculator is growing up, from now on we’ll call it an </span><span class="c6">interpreter</span><span class="calibre3">, abbreviated in code to </span><span class="c25">interp</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s start with the new AST. For simplicity, we’ll ignore conditionals, which are anyway orthogonal to our goal of handling local binding. Recall that we added two new branches to the BNF, so we’ll want two new corresponding branches to the AST:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Exp</span></p><p class="c4"><span class="c34">&nbsp; [numE (n : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [plusE (left : Exp) (right : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [varE (name : Symbol)]</span></p><p class="c4"><span class="c34">&nbsp; [let1E (var : Symbol)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(value : Exp)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(body : Exp)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can also copy over our previous calculator, but we pretty quickly run into trouble:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (interp e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case (Exp) e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(varE s) …]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plusE l r) (+ (interp l) (interp r))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(let1E var val body) …]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What do we do when we encounter a </span><span class="c25">let1E</span><span class="c2">? For that matter, what do we do when we encounter a variable? In fact, these two should be intimately connected: the variable binding introduced by the former should substitute the variable use in the latter.</span></p></div>

<div class="c" id="calibre_link-331">
<h2 class="c21" id="calibre_link-131"><span class="c2">Caching Substitution</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We repeatedly&mdash;and rightly&mdash;refer back to substitution to understand how programs should work, and indeed will do so again later. But substitution as an </span><span class="c6">evaluation</span><span class="calibre3">&nbsp;technique is messy. This requires us to constantly keep rewriting the program text, which takes time linear in the size of the program (which can get quite large) for </span><span class="c6">every</span><span class="c2">&nbsp;variable binding. Most real language implementations do not work this way.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Instead, we might think of employing a space-time tradeoff: we’ll use a little extra space to save ourselves a whole lot of time. That is, we’ll </span><span class="c6">cache</span><span class="calibre3">&nbsp;the substitution in a data structure called the </span><span class="c6">environment</span><span class="c2">. An environment records names and their corresponding values: that is, it’s a collection of key-value pairs. Thus, whenever we encounter a binding we remember its value, and when we encounter a variable, we look up its value.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">A</span><span class="calibre3">s with all caches, we want them to only improve performance along a dimension, not change the meaning. That is, we no longer want substitution to define </span><span class="c6">how</span><span class="calibre3">&nbsp;we produce an answer. But, we still want it to tell us </span><span class="c6">what</span><span class="c2">&nbsp;answer to produce. This will become important below.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We will use a hash table to represent the environment:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type-alias Env (Hashof Symbol Value))</span></p><p class="c4"><span class="c34">(define mt-env (hash empty)) ;; "empty environment"</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We will need the interpreter to actually take an environment as a formal parameter, to use in place of substitution. Thus:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(interp : (Exp Env -&gt; Value))</span></p><p class="c4"><span class="c34">(define (interp e nv) …)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now what happens when we encounter a variable? We try to look it up in the environment. That may succeed or, in the case of our last example above, fail. We will use </span><span class="c25">hash-ref</span><span class="calibre3">, which looks up keys in hash tables, and returns an </span><span class="c25">Optionof</span><span class="c2">&nbsp;type to account for the possibility of failure. We can encapsulate it in a function that we will repeatedly find useful:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (lookup (s : Symbol) (n : Env))</span></p><p class="c4"><span class="c34">&nbsp; (type-case (Optionof Value) (hash-ref n s)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(none) (error s "not bound")]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(some v) v]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In the event the lookup succeeds, then we want the value found, which is wrapped in </span><span class="c25">some</span><span class="c2">. This function &nbsp;enables our interpreter to stay very clean and readable:</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(varE s) (lookup s nv)]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, we are ready to tackle </span><span class="c25">let1</span><span class="c2">. What happens here? We must </span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">evaluate the body of the expression, in</span></li><li class="pcalibre c23"><span class="c2">an environment that has been extended, with</span></li><li class="pcalibre c23"><span class="c2">the new name </span></li><li class="pcalibre c23"><span class="c2">bound to its value.</span></li></ul><p class="c4"><span class="c2">Phew!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Fortunately, this isn’t as bad as it sounds. Again, a function will help a lot:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(extend : (Env Symbol Value -&gt; Env))</span></p><p class="c4"><span class="c34">(define (extend old-env new-name value)</span></p><p class="c4"><span class="c34">&nbsp; (hash-set old-env new-name value))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With this, we can see the structure clearly:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(let1E var val body)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([new-env (extend nv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp val nv))])</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">(Observe that we used </span><span class="c25">let</span><span class="calibre3">&nbsp;in plait to define </span><span class="c25">let1</span><span class="c2">&nbsp;in Paret. We’ll see more of this…)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In sum, our core interpreter is now:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (interp e nv)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE n) n]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(varE s) (lookup s nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plusE l r) (+ (interp l nv) (interp r nv))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(let1E var val body)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([new-env (extend nv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp val nv))])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(interp body new-env))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;</span></p><ol class="c55" start="1"><li class="pcalibre15 pcalibre16"><span class="calibre3">What if we had not called </span><span class="c25">(interp val nv)</span><span class="c2">&nbsp;above?</span></li><li class="pcalibre15 pcalibre16"><span class="calibre3">What if we’d used </span><span class="c25">nv</span><span class="calibre3">&nbsp;instead of </span><span class="c25">new-env</span><span class="calibre3">&nbsp;in the call to </span><span class="c25">interp</span><span class="c2">?}</span></li><li class="pcalibre15 pcalibre16"><span class="c2">Are there any other errors in the interpreter based on copying what we had before?</span></li><li class="pcalibre15 pcalibre16"><span class="c2">We seem to extend the environment but never remove anything from it. Is that okay? If not, it should cause an error. What program would demonstrate this error, and does it actually do so? (If not, why not?)</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This concludes our first interesting “programming language”. We have already been forced to deal with some fairly subtle questions of scope, and with how to interpret them. Things will only get more interesting from here!</span></p></div>

<div class="c" id="calibre_link-322">
<h1 class="c20" id="calibre_link-132"><span class="c2">Evaluating Functions</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now that we have arithmetic and conditionals, let’s proceed to creating a full-fledged programming language by adding functions.</span></p></div>

<div class="c" id="calibre_link-77">
<h2 class="c21" id="calibre_link-133"><span class="c2">Functions in the Language</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There are many ways to think about adding functions to the language. Many languages, for instance, have top-level functions; e.g.:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">fun f(x):</span></p><p class="c4"><span class="c34">&nbsp; x + x</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Indeed, some languages (such as C) </span><span class="c6">only</span><span class="c2">&nbsp;have top-level functions. Most modern languages, however, have the ability to write functions outside the top-level: e.g.,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">fun f(x):</span></p><p class="c4"><span class="c34">&nbsp; fun sq(y):</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; y * y</span></p><p class="c4"><span class="c34">&nbsp; sq(x) + sq(x)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and even to </span><span class="c6">return</span><span class="calibre3">&nbsp;those functions, and even to allow them to be written </span><span class="c6">anonymously</span><span class="c2">. Since just about every modern language supports it, we’ll think of this as a component of SMoL. Indeed, with such a facility, we don’t really need a named function construct per se: we could instead have written</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">fun f(x):</span></p><p class="c4"><span class="c34">&nbsp; sq = lam(y): y * y</span></p><p class="c4"><span class="c34">&nbsp; sq(x) + sq(x)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">And in turn we can replace </span><span class="c25">f</span><span class="calibre3">&nbsp;with a name-binding and </span><span class="c25">lam</span><span class="c2">, too.</span></p></div>

<div class="c" id="calibre_link-25">
<h2 class="c21" id="calibre_link-134"><span class="c2">Extending the Representation</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Therefore, let’s think about what it takes to evaluate functions-as-values to SMoL. We don’t need functions to inherently have a name, because naming can be done by </span><span class="c25">let1</span><span class="c2">. &nbsp;We’ll assume, for simplicity, that all functions take only one argument; extending this to multiple arguments is left as an exercise.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;What issues might we have to deal with when we extend functions from having one argument only to having multiple arguments?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First, we need to extend our abstract syntax.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;How many new constructs do we need to add to the abstract syntax?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">When we added </span><span class="c25">let1</span><span class="calibre3">, you may recall that it didn’t suffice to add one construct; we needed two: one for variable </span><span class="c6">binding</span><span class="calibre3">&nbsp;and one for variable </span><span class="c6">use</span><span class="calibre3">. You’ll often see this pattern when adding values to the language. For any new kind of value, &nbsp;you can expect to see one or more ways to </span><span class="c6">make</span><span class="calibre3">&nbsp;it and one or more ways to </span><span class="c6">use</span><span class="c2">&nbsp;it. (Even arithmetic: numeric constants were a way to make them, arithmetic operations consumed them&mdash;but also made them.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Likewise with functions, we need a way to represent both</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">lam(x): x * x</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">for defining new functions, and</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">sq(3)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">to use them.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;In more advanced texts, you will sometimes see the (formally correct, but perhaps slightly confusing) terms </span><span class="c6">introduction</span><span class="calibre3">&nbsp;and </span><span class="c6">elimination</span><span class="calibre3">: introduction brings the new concept in, elimination uses them. Thus, the </span><span class="c25">lam</span><span class="c2">&nbsp;introduces new functions, and an application eliminates them.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We therefore add</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; [lamE (var : Symbol) (body : Exp)]</span></p><p class="c4"><span class="c25">&nbsp; [appE (fun : Exp) (arg : Exp)]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">to our AST.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s assume we’ve already extended our parser, so that programs like the following are legal:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{let1 {f {lam x {+ x x}}}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; {f 3}}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">{let1 {x 3}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; {let1 {f {lam y {+ x y}}}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {f 3}}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These parse, respectively, into</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let1E 'f (lamE 'x (plusE (varE 'x) (varE 'x))) </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(appE (varE 'f) (numE 3)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(let1E 'x (numE 3) </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(let1E 'f (lamE 'y (plusE (varE 'x) (varE 'y))) </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (appE (varE 'f) (numE 3))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and should both evaluate to </span><span class="c25">6</span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-337">
<h2 class="c21" id="calibre_link-135"><span class="c2">Evaluating Functions</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s think about the evaluator, which by now we can think of as turning into a full-blown interpreter.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s start with the (almost) simplest kind of new program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{lam x {+ x x}}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which is represented as</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(lamE 'x (plusE (varE 'x) (varE 'x)))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;What do we want this program to evaluate to? Think in terms of types!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Remember that </span><span class="c25">calc</span><span class="calibre3">&nbsp;produces numbers. What </span><span class="c6">number</span><span class="calibre3">&nbsp;does the above expression evaluate to? What number do you </span><span class="c6">expect</span><span class="c2">&nbsp;it to produce?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If we really want to stretch our credibility, we could either make up an encoding of it in a number, or use a number in memory. But neither of these is what we would </span><span class="c6">expect</span><span class="c2">! Let’s look at what some other languages do:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (lambda (x) (+ x x))</span></p><p class="c4"><span class="c34">#&lt;procedure&gt;</span></p><p class="c4"><span class="c34">&gt; (number? (lambda (x) (+ x x)))</span></p><p class="c4"><span class="c34">#f</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&gt;&gt;&gt; lambda x: x + x</span></p><p class="c4"><span class="c34">&lt;function &lt;lambda&gt; at 0x108fd16a8&gt;</span></p><p class="c4"><span class="c34">&gt;&gt;&gt; isinstance(lambda x: x + x, numbers.Number)</span></p><p class="c4"><span class="c34">False</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Both Racket and Python agree: the result of creating an anonymous function is a function-kind of value, not a number. What this says is that we have to broaden the kinds of values that </span><span class="c25">interp</span><span class="c2">&nbsp;can produce.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology: </span><span class="calibre3">A </span><span class="c6">side-effect</span><span class="calibre3">&nbsp;is a change to the system that is visible from outside the body of a function. Typical side-effects are modifications to variables that are defined outside the function, communication with a network, changes to files, and so on.</span></p><p class="c43"><span class="c41"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;A function is </span><span class="c6">pure</span><span class="calibre3">&nbsp;if, for a given input, it always produces the same output, and has no side-effects. In reality, a computation always has </span><span class="c6">some</span><span class="c2">&nbsp;side-effects, such as the consumption of energy and production of heat, but we usually overlook these because they are universal. In a few settings, however, they can matter: e.g., if a cryptographic key can be stolen by measuring these side-effects.</span></p><p class="c43"><span class="c41"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;Traditionally, some languages have used the terms </span><span class="c6">procedure</span><span class="calibre3">&nbsp;and </span><span class="c6">function</span><span class="c2">&nbsp;for similar but not identical concepts. Both are function-like entities that encapsulate a body of code and can be applied (or “called”). A procedure is an encapsulation that does not produce a value; therefore, it must have side-effects to be of any use. In contrast, a function always produces a value (and may be expected to not have any side-effects). This terminology has gotten completely scrambled over the years and people now use the terms interchangeably, but if someone seems to be making a distinction between the two, they probably mean something like the above.</span></p></div>

<div class="c" id="calibre_link-363">
<h2 class="c21" id="calibre_link-136"><span class="c2">Extending Values</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What happens when evaluating a function? Both Racket and Python seem to suggest that we return a function.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We could have no additional information about the function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Value</span></p><p class="c4"><span class="c34">&nbsp; [numV (the-number : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [boolV (the-boolean : Boolean)]</span></p><p class="c4"><span class="c34">&nbsp; [funV])</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">(That syntax means </span><span class="c25">funV</span><span class="calibre3">&nbsp;is a constructor of no parameters. It conveys no information at all other than the fact that it’s a </span><span class="c25">funV</span><span class="calibre3">; because we can’t mix types, it says, in particular, that a value is not numeric or a Boolean&mdash;and nothing more.) But now think about a program like this (assuming </span><span class="c25">x</span><span class="c2">&nbsp;is bound):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">{{if0 x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; {lam x {+ x 1}}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; {lam x {- x 2}}}</span></p><p class="c4"><span class="c34">&nbsp;5}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In both cases we’re going to get a </span><span class="c25">funV</span><span class="c2">&nbsp;value with no additional information, so when we try to perform the application, we…can’t.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Instead, it’s clear that the function value needs to tell us about the function. We need to know the body, because that’s what we need to evaluate; but the body can (and very likely does) reference the name of the formal parameter, so we need that too. Therefore, what we really need is</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Value</span></p><p class="c4"><span class="c34">&nbsp; [numV (the-number : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [boolV (the-boolean : Boolean)]</span></p><p class="c4"><span class="c34">&nbsp; [funV (var : Symbol) (body : Exp)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">At this point, it seems like we’ve gone to a lot of trouble for nothing. We take numeric and Boolean values and simply re-wrap them in new constructors, and now we’re doing the same thing for functions. &nbsp;A certain Shakespeareian play’s title comes to mind.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Patience.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With what we have, we can already have a functioning interpreter. The lam case is obviously very simple:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; [(lamE v b) (funV v b)]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The application case is a bit more detailed. We need to:</span></p><ol class="c56" start="1"><li class="c57 pcalibre17"><span class="c2">Evaluate the function position, to figure out what kind of value it is.</span></li><li class="c57 pcalibre17"><span class="c2">Evaluate the argument position, since we’ve agreed that’s what happens in SMoL.</span></li><li class="c57 pcalibre17"><span class="c2">Check that the function position really does evaluate to a function. If it does not, raise an error.</span></li><li class="c57 pcalibre17"><span class="c2">Evaluate the body of the function. But because the body can refer to the formal parameter…</span></li><li class="c57 pcalibre17"><span class="c2">…first make sure the formal is bound to the actual value of the argument.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Codifying this, in stages:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; [(appE f a) </span><span class="c54">(let ([fv (interp f nv)]</span></p><p class="c4"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [av (interp a nv)])</span></p><p class="c4"><span class="c53">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; …)</span><span class="c34">]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [av (interp a nv)])</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c54">(type-case Value fv</span></p><p class="c4"><span class="c54">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(funV v b) …]</span></p><p class="c4"><span class="c53">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (error 'app "didn't get a function")]</span><span class="c25">))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [av (interp a nv)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (type-case Value fv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(funV v b)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c53">(interp b …)</span><span class="c34">]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (error 'app "didn't get a function")]))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [av (interp a nv)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (type-case Value fv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(funV v b)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp b </span><span class="c53">(extend nv v av)</span><span class="c34">)]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (error 'app "didn't get a function")]))]</span></p></div>

<div class="c" id="calibre_link-367">
<h2 class="c21" id="calibre_link-137"><span class="c2">Stepping Back</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Putting it all together, we get the following interpreter:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(interp : (Exp Env -&gt; Value))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (interp e nv)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE n) (numV n)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(varE s) (lookup s nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plusE l r) (add (interp l nv) (interp r nv))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(lamE v b) (funV v b)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [av (interp a nv)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (type-case Value fv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(funV v b)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp b (extend nv v av))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (error 'app "didn't get a function")]))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(let1E var val body)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([new-env (extend nv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (interp val nv))])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(interp body new-env))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;We wrote down a particular ordering above, which we put into practice in the code. But is that the same ordering that actual languages use? In particular, are non-function errors reported after or before evaluating the argument? Experiment and find out!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Since we’ve taken several steps to get here, it’s easy to lose sight of what we’ve just done. In just 20 lines of code (with a few helper functions), we have described the implementation of a </span><span class="c6">full programming language</span><span class="calibre3">. Not only that, a language that can express </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Church%25E2%2580%2593Turing_thesis&amp;sa=D&amp;source=editors&amp;ust=1695232021212601&amp;usg=AOvVaw1o9iRZ1zIR7qNKrD6lFhCa">all computations</a></span><span class="calibre3">. When Turing Award winner </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Alan_Kay&amp;sa=D&amp;source=editors&amp;ust=1695232021213036&amp;usg=AOvVaw1mQ9COqfNQ40uhDQa8ed0D">Alan Kay</a></span><span class="calibre3">&nbsp;first saw the equivalent program, </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://queue.acm.org/detail.cfm?id%3D1039523&amp;sa=D&amp;source=editors&amp;ust=1695232021213294&amp;usg=AOvVaw2Jqf_V8SktzbJT9CEIRj32">he says</a></span><span class="c2">,</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c2">Yes, that was the big revelation to me when I was in graduate school&mdash;when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c2">I realized that anytime I want to know what I’m doing, I can just write down the kernel of this thing in a half page and it’s not going to lose any power. In fact, it’s going to gain power by being able to reenter itself much more readily than most systems done the other way can possibly do.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We’ve just rediscovered this same beautiful, powerful idea! If you want to see the original, here’s </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://www.softwarepreservation.org/projects/LISP/book/LISP%25201.5%2520Programmers%2520Manual.pdf&amp;sa=D&amp;source=editors&amp;ust=1695232021214133&amp;usg=AOvVaw2NEGhAo0Lj5kqCqv5LySNb">that manual</a></span><span class="c2">&nbsp;(by McCarthy, Abrahams, Edwards, Hart, Levin). Here it is, copied:</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="calibre20"><img alt="" src="images/000008.png" title="" class="calibre21" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Alright, so we now have a working interpreter for a full-fledged language. But before we can feel sure of that, we should try a few more examples to confirm that we’re happy with what we have.</span></p></div>

<div class="c" id="calibre_link-356">
<h2 class="c21" id="calibre_link-138"><span class="c2">Extending Tests</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Well, actually, we shouldn’t be too happy. Consider the following examples:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let1E 'x (numE 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(let1E 'f (lamE 'y (varE 'x))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (let1E 'x (numE 2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(appE (varE 'f) (numE 10)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What do we expect it to produce? If in doubt, we can write the same thing as a Racket program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([x 1])</span></p><p class="c4"><span class="c34">&nbsp; (let ([f (lambda (y) x)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (let ([x 2])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (f 10))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">What we see is that </span><span class="c6">in Racket</span><span class="calibre3">, the inner binding of </span><span class="c25">x</span><span class="calibre3">&nbsp;does </span><span class="c6">not</span><span class="calibre3">&nbsp;override the outer one, the one that was present at the time the function bound to </span><span class="c25">f</span><span class="calibre3">&nbsp;was defined. Therefore, this produces </span><span class="c25">1</span><span class="c2">&nbsp;in Racket.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We should want this! Otherwise, consider this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let1E 'f (lamE 'y (varE 'x))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(let1E 'x (numE 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (appE (varE 'f) (numE 10))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c2">This corresponds to</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([f (lambda (y) x)])</span></p><p class="c4"><span class="c34">&nbsp; (let ([x 5])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (f 3)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">which has an unbound identifier (</span><span class="c25">x</span><span class="calibre3">) error. But our interpreter produces </span><span class="c25">1</span><span class="calibre3">&nbsp;instead of halting with an error, which leads us right back to </span><span class="c58">☠️</span><span class="c33">dynamic scope </span><span class="c2">☠️!</span></p></div>

<div class="c" id="calibre_link-358">
<h2 class="c21" id="calibre_link-139"><span class="c2">Return to Static Scope</span></h2><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="c2">Run the following programs in the Stacker.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So how do we fix this? The examples above actually give us a clue, but there is another source of inspiration as well. Do you remember that we started with </span><span class="c6">substitution</span><span class="c2">? We’ll walk through these examples in Racket, so that you can run each of them directly and check that they produce the same answer. Consider again this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([x 1])</span></p><p class="c4"><span class="c34">&nbsp; (let ([f (lambda (y) x)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (let ([x 2])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (f 10))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Substituting </span><span class="c25">1</span><span class="calibre3">&nbsp;for </span><span class="c25">x</span><span class="c2">&nbsp;produces:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (let ([f (lambda (y) 1)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (let ([x 2])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (f 10)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Substituting </span><span class="c25">f</span><span class="c2">&nbsp;produces:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (let ([x 2])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; ((lambda (y) 1) 10))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, substituting </span><span class="c25">x</span><span class="calibre3">&nbsp;with </span><span class="c25">2</span><span class="calibre3">&nbsp;produces (note that there are no </span><span class="c25">x</span><span class="c2">s left in the program!):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; ((lambda (y) 1) 10)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">When you see it this way, it’s clear </span><span class="c6">why</span><span class="calibre3">&nbsp;the later binding of </span><span class="c25">x</span><span class="calibre3">&nbsp;should have no impact: it’s a different </span><span class="c25">x</span><span class="calibre3">, and the earlier </span><span class="c25">x</span><span class="calibre3">&nbsp;has effectively already been substituted. Since we have agreed that substitution is how we want our programs to work, our job now is to make sure that the environment actually implements that </span><span class="c6">correctly</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The way to do it is to recognize that the environment represents the substitutions waiting to happen, and just </span><span class="c6">remember</span><span class="c2">&nbsp;them. That is, our representation of a function needs to also keep track of the environment at the moment of function creation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Value</span></p><p class="c4"><span class="c34">&nbsp; [numV (the-number : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [boolV (the-boolean : Boolean)]</span></p><p class="c4"><span class="c25">&nbsp; [funV (var : Symbol) (body : Exp) </span><span class="c53">(nv : Env)</span><span class="c34">])</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">This new and richer kind of </span><span class="c25">funV</span><span class="calibre3">&nbsp;value has a special name: it’s called a </span><span class="c6">closure</span><span class="c2">. That’s because the expression is “closed” over the environment in which it was defined.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;A </span><span class="c6">closed</span><span class="calibre3">&nbsp;term is one that has no unbound variables. The body of a function may have unbound variables&mdash;like </span><span class="c25">x</span><span class="calibre3">&nbsp;above&mdash;but the closure makes sure that they aren’t </span><span class="c6">really</span><span class="c2">&nbsp;unbound, because they can get their values from the stored environment.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Quote:</span><span class="calibre3">&nbsp;“Save the environment! Create a closure today!” &mdash;</span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://users.soe.ucsc.edu/~cormac/&amp;sa=D&amp;source=editors&amp;ust=1695232021221610&amp;usg=AOvVaw0ubwf31ENzplf9Txn7x4SS">Cormac Flanagan</a></span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c33">Quote:</span><span class="calibre3">&nbsp;“Lambdas are relegated to relative obscurity until Java makes them popular by not having them.” </span><span class="c33">&mdash;</span><span class="calibre3">James Iry, </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html&amp;sa=D&amp;source=editors&amp;ust=1695232021222322&amp;usg=AOvVaw15zUkk_RscjegRPA01Zrxb">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That means, when we create a closure, we have to record the environment at the time of its creation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; [(lamE v b) (funV v b </span><span class="c53">nv</span><span class="c34">)]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, when we use a function (represented by a closure), we have to make sure we use the </span><span class="c6">stored</span><span class="calibre3">&nbsp;environment, not the one present at the point of calling the function, which is the </span><span class="c6">dynamic</span><span class="c2">&nbsp;one:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(appE f a) (let ([fv (interp f nv)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [av (interp a nv)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (type-case Value fv</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(funV v b </span><span class="c53">nv</span><span class="c34">)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(interp b (extend nv v av))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (error 'app "didn't get a function")]))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Just to be clear: in the code above, the </span><span class="c25">nv</span><span class="calibre3">&nbsp;in the </span><span class="c25">funV</span><span class="calibre3">&nbsp;case </span><span class="c6">intentionally shadows</span><span class="calibre3">&nbsp;the </span><span class="c25">nv</span><span class="calibre3">&nbsp;bound at the top of the interpreter. Thus, the call to </span><span class="c25">extend</span><span class="calibre3">&nbsp;extends the environment </span><span class="c6">from the closure</span><span class="c2">, rather than the one present at the point of the call.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Notice that the function and argument expressions (</span><span class="c25">f</span><span class="calibre3">&nbsp;and </span><span class="c25">a</span><span class="c2">, respectively) are evaluated in the environment given to the interpreter, not the one inside the closure. Is this correct? Or should they be using the closure’s environment? </span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="calibre3">You can do two things: argue from first principles or argue with examples. In the latter case, you would modify the interpreter to make the other choice. You would then use a sample input that produces different answers depending on which environment is used, indicate which one is correct (showing what the equivalent Racket program would produce can be a good argument), and use that to justify the chosen environment. </span><span class="c33">Hint:</span><span class="c2">&nbsp;One of these you will need to argue from first principles, the other you should be able to argue using a program.</span></p></div>

<div class="c" id="calibre_link-373">
<h2 class="c21" id="calibre_link-140"><span class="c2">A Subtle Test</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In the examples above, we always use the closure in the scope in which it was defined. However, our language is actually more powerful than that: we can </span><span class="c6">return</span><span class="calibre3">&nbsp;a closure and use it </span><span class="c6">outside</span><span class="c2">&nbsp;the scope in which it was defined. Here’s a sample Racket program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">((let ([x 3])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;(lambda (y) (+ x y)))</span></p><p class="c4"><span class="c34">&nbsp;4)</span></p><p class="c3"><span class="c34"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;Take a moment to read it carefully. What should it produce?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">First we bind the </span><span class="c25">x</span><span class="calibre3">, then we evaluate the lambda. This creates a closure that remembers the binding to </span><span class="c25">x</span><span class="c2">. This closure is the value returned by this expression:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(</span><span class="c54">(let ([x 3])</span></p><p class="c4"><span class="c54">&nbsp; &nbsp;(lambda (y) (+ x y)))</span></p><p class="c4"><span class="c25">&nbsp;4)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This value is now applied to </span><span class="c25">4</span><span class="calibre3">. It’s legal to do this, because the value returned is a function. When we apply it to </span><span class="c25">4</span><span class="calibre3">, that evaluates the sum of </span><span class="c25">4</span><span class="calibre3">&nbsp;and </span><span class="c25">3</span><span class="calibre3">, producing </span><span class="c25">7</span><span class="calibre3">. Sure enough, translating this and sending it to our interpreter produces </span><span class="c25">7</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (interp (appE (let1E 'x (numE 3)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(lamE 'y (plusE (varE 'x) (varE 'y))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (numE '4))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mt-env)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (numV 7))</span></p><p class="c3"><span class="c34"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Here’s another test to try out, written as a Racket program:</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c34">((let ([y 3])</span></p><p class="c27"><span class="c34">&nbsp; &nbsp;(lambda (y) (+ y 1)))</span></p><p class="c27"><span class="c34">&nbsp;5)</span></p><p class="c43"><span class="c34"></span></p><p class="c27"><span class="c2">What does it produce in Racket? Translate it and try it in your interpreter.</span></p></div>

<div class="c" id="calibre_link-376">
<h1 class="c13" id="calibre_link-141"><span class="c2">••••• Syntactic Sugar •••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">We have now seen the essence of a small core language. In practice, programming languages need to also be </span><span class="calibre3">usable</span><span class="c28">. To do this, they have to provide features that make programming convenient. We will see they can do this while minimizing their effort and pain.</span></p></div>

<div class="c" id="calibre_link-380">
<h1 class="c20" id="calibre_link-142"><span class="c2">How SMoL Becomes Large</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We have already been introduced to the idea of SImPl, the Standard Implementation Plan. The core idea is that the program’s syntax is represented as abstract syntax using a (mutually) recursive algebraic datatype, and we then write a similar (mutually) recursive program to process it. What that program produces depends on the process we are trying to implement: an interpreter produces </span><span class="c6">values</span><span class="calibre3">, a compiler produces </span><span class="c6">programs</span><span class="calibre3">&nbsp;(in another language), a type-checker produces </span><span class="c6">judgments about type-correctness</span><span class="c2">&nbsp;(and more, as we’ll soon see), and so on. But they all have the same basic structure.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In practice, this means that a SImPl needs to have a case to handle each of the constructs in the language. This is not a problem in principle, but it can become onerous in practice. Suppose we have two constructs that have a lot of repetition. Not only does it mean we have to duplicate programming, it also means we have to duplicate </span><span class="c6">maintenance</span><span class="c2">: if we fix a bug in one, we have to remember to fix it in the other in the corresponding way.</span></p></div>

<div class="c" id="calibre_link-2">
<h2 class="c21" id="calibre_link-143"><span class="c2">Redundancy in Languages</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Where might we find such redundancy? There are several examples in real languages. For instance, many languages have both </span><span class="c25">for</span><span class="calibre3">&nbsp;and </span><span class="c25">while</span><span class="calibre3">&nbsp;loops. Consider a typical </span><span class="c25">for</span><span class="c2">&nbsp;loop in C:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">for(x = 0; x &lt; 10; x++) {</span></p><p class="c4"><span class="c34">&nbsp; sum += x;</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This is </span><span class="c6">exactly</span><span class="c2">&nbsp;the same as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">x = 0;</span></p><p class="c4"><span class="c34">while (x &lt; 10) {</span></p><p class="c4"><span class="c34">&nbsp; sum += x;</span></p><p class="c4"><span class="c34">&nbsp; x++;</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There is, in fact, a general pattern:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">for(INITIAL; CONDITIONAL; UPDATE) {</span></p><p class="c4"><span class="c34">&nbsp; sum += x;</span></p><p class="c4"><span class="c25">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">is the same (with some syntactic liberties) as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">INITIAL;</span></p><p class="c4"><span class="c34">while (CONDITIONAL) {</span></p><p class="c4"><span class="c34">&nbsp; sum += x;</span></p><p class="c4"><span class="c34">&nbsp; UPDATE;</span></p><p class="c4"><span class="c25">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now imagine you’re writing an interpreter for this. Clearly, the </span><span class="c25">while</span><span class="calibre3">&nbsp;loop’s implementation has to make several recursive calls, iterate, check, and perhaps perform some other bookkeeping (and maybe even manage temporary scope extensions). </span><span class="c6">All</span><span class="calibre3">&nbsp;of that work has to be </span><span class="c6">duplicated</span><span class="calibre3">&nbsp;for </span><span class="c25">for</span><span class="calibre3">! Wouldn’t it be much simpler to instead implement it just once, and translate the </span><span class="c25">for</span><span class="calibre3">&nbsp;body into a </span><span class="c25">while</span><span class="c2">&nbsp;body?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Why have both constructs at all? Because each one is convenient for different purposes. In particular, there’s a certain&nbsp;stylistic use of </span><span class="c25">while</span><span class="calibre3">&nbsp;that would be harder to spot from a mass of </span><span class="c25">while</span><span class="calibre3">&nbsp;code that is automatically classified for us with </span><span class="c25">for</span><span class="c2">. It adds to our vocabulary as programmers. It just happens to also add to our pain as implementors. We’d like the convenience and richer vocabulary without the pain.</span></p></div>

<div class="c" id="calibre_link-364">
<h2 class="c21" id="calibre_link-144"><span class="c2">Desugaring</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This introduces a distinction between a </span><span class="c6">core</span><span class="calibre3">&nbsp;language and a </span><span class="c6">surface</span><span class="calibre3">&nbsp;language. The surface language may have various conveniences, but these get translated into the core language, whose constructs are all handled directly. The extra constructs&mdash;those that make it “sweeter” to program&mdash;are called </span><span class="c6">syntactic sugar</span><span class="calibre3">. The program that translates surface programs down to the core is called a </span><span class="c6">desugarer</span><span class="calibre3">, because it removes sugar. (In principle, a desugarer is actually a </span><span class="c6">compiler</span><span class="calibre3">&nbsp;from the surface language to the core language. However, since the core language is a </span><span class="c6">sub</span><span class="calibre3">-language of the surface, this is a very special case of compilation, and we find it useful to have a special term to distinguish it from general compilation. Just like we find it useful to have a special term to distinguish </span><span class="c25">for</span><span class="calibre3">&nbsp;from the general </span><span class="c25">while</span><span class="c2">…)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;In a real implementation, this compilation requires a little more care. Suppose you make an error using </span><span class="c25">for</span><span class="calibre3">, but the error was reported in terms of </span><span class="c25">while</span><span class="calibre3">: you’d be pretty confused, because you never did type the </span><span class="c25">while</span><span class="calibre3">. As a special case, you may be a student who doesn’t even know what </span><span class="c25">while</span><span class="calibre3">&nbsp;</span><span class="c6">is</span><span class="c2">! Modern desguaring systems, such as that in Racket, have special support to take care of this in most of the common cases.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">There are actually many more desugarings in real languages. For instance, </span><span class="c25">and</span><span class="calibre3">&nbsp;and </span><span class="c25">or</span><span class="calibre3">&nbsp;can desugar into nested </span><span class="c25">if</span><span class="calibre3">s. In JavaScript, </span><span class="c25">o.x</span><span class="calibre3">&nbsp;desugars into </span><span class="c25">o["x"]</span><span class="calibre3">&nbsp;(which will be relevant in a while). In many languages, </span><span class="c25">x += y</span><span class="calibre3">&nbsp;is sugar for </span><span class="c25">x = x + y</span><span class="calibre3">. In Python, </span><span class="c25">+</span><span class="calibre3">&nbsp;desugars into the method </span><span class="c25">__add__</span><span class="calibre3">. In fact, Python has a whole bunch of these desugarings; these methods are called “dunder” methods (short for double-underscore), and a whole programming style of “</span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://twitter.com/gvanrossum/status/1307712322320785409&amp;sa=D&amp;source=editors&amp;ust=1695232021233535&amp;usg=AOvVaw2ERm9Pb0kR6LijXtV_K83D">protocols</a></span><span class="c2">” has evolved around it. Many languages (like Haskell and Python) have list comprehensions, which desugar into function and method calls. And so on. In short, desugaring is everywhere in programming. If you don’t notice it, that’s part of the point: it feels like you’re working with a larger surface syntax than the implementor has to manage.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">There are many ways in which desugaring can be implemented. One way is to parse the program normally, then rewrite the AST into a subset of the same AST. But in some languages, especially those with parenthetical syntax, there are two levels of parsing: the coarser parenthetical level and the finer level of ASTs. This means we can perform rewriting on the parenthetical terms, and the internal AST never needs to know about the sugars (i.e., it need cover only the core language). These are typically called </span><span class="c6">macro</span><span class="calibre3">&nbsp;systems: systems in which program source (slightly abstracted) is rewritten into program source, before parsing takes place. It’s important to understand that </span><span class="c6">most</span><span class="calibre3">&nbsp;languages have syntactic sugar, but </span><span class="c6">very few</span><span class="c2">&nbsp;languages have macro systems, which provide program rewriting capabilities directly to the programmer (as opposed to hiding them inside the compiler).</span></p></div>

<div class="c" id="calibre_link-368">
<h2 class="c21" id="calibre_link-145"><span class="c2">Macros By Example</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Racket is one of the few languages to have a macro system, and in fact has a very powerful one. Its rarity means ideas we learn using macros will take some effort to port to other languages; but its power means we can write quite sophisticated systems by leveraging the full power of Racket, and we will do so. In essence, Racket macros compile an extended version of Racket&mdash;call it Racket++, if you like&mdash;down to Racket, where we can then exploit the full power of the existing Racket framework.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We will introduce the Racket macro system through a series of examples. In what follows, please switch to using</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang racket</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">because the restrictions and types of </span><span class="c25">plait</span><span class="c2">, while very useful for writing interpreters, can get in the way of some of what we’ll write.</span></p></div>

<div class="c" id="calibre_link-21">
<h2 class="c21" id="calibre_link-146"><span class="c2">A New Conditional</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Recall that Racket is a truthy/falsy language, where </span><span class="c25">if</span><span class="calibre3">&nbsp;takes any non-false value to be true. Suppose we want a strict </span><span class="c25">if</span><span class="calibre3">&nbsp;that takes only Booleans. That is, we want to extend Racket itself with a </span><span class="c25">strict-if</span><span class="c2">. Let’s try this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (strict-if C T E)</span></p><p class="c4"><span class="c34">&nbsp; (if (boolean? C)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (if C T E)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (error 'strict-if "expected a boolean")))</span></p><p class="c3"><span class="c41"></span></p><p class="c4"><span class="c2">Try examples like:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(strict-if true 1 2)</span></p><p class="c4"><span class="c34">(strict-if 0 1 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Seems to work as desired!</span></p><p class="c3"><span class="c41"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;Do you see what the problem is?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The problem is that we have an eager language (this is true of SMoL in general!), so </span><span class="c25">strict-if</span><span class="c2">s arguments are going to be evaluated before the body begins to execute. However, the whole point of a conditional is to avoid evaluating part of the evaluation: Try</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(strict-if true 1 (/ 1 0))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Compare this to what happens with</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(if true 1 (/ 1 0))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, so we can’t use functions for this purpose. We need some other definition mechanism that consumes the </span><span class="c6">syntax</span><span class="c2">&nbsp;and rewrites that, instead of letting it evaluate right away. These are macros.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s dive into how the macro is written, because it’s not so different from the function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax strict-if</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(strict-if C T E)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(if (boolean? C)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(if C T E)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'strict-if "expected a boolean"))]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">What are the pieces? </span><span class="c25">define-syntax</span><span class="calibre3">&nbsp;says we’re defining a new piece of </span><span class="c6">syntax</span><span class="calibre3">&nbsp;(as opposed to a function). </span><span class="c25">syntax-rules</span><span class="calibre3">&nbsp;introduces a pattern-matcher (for now, ignore what the </span><span class="c25">()</span><span class="calibre3">&nbsp;means: but you do need to include it). Each rule, in brackets, is a pattern and output: if the input matches the pattern, then the desugarer (here called a </span><span class="c6">macro expander</span><span class="calibre3">) produces the corresponding output, but with the </span><span class="c6">names</span><span class="calibre3">&nbsp;in the pattern (here, </span><span class="c25">C</span><span class="calibre3">, </span><span class="c25">T</span><span class="calibre3">, and </span><span class="c25">E</span><span class="c2">) copied as program source into the output. Thus, given</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(strict-if true 1 (/ 1 0))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">the above macro definition transforms it into</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(if (boolean? true)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (if true 1 (/ 1 0))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (error 'strict-if "expected a boolean"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which then evaluates exactly as we’d expect.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">One nice feature of Racket is the Macro Stepper (</span><span class="calibre22"><img alt="" src="images/000019.png" title="" class="calibre23" /></span><span class="c2">). It shows the program expanding step-by-step, which is useful both for understanding macros and debugging them. If necessary, change the “Macro hiding” option at the bottom-left to read “Standard”.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Try it out with the above macro definition and use. See what you get. Observe how, at each step, it highlights the macro use about to be expanded followed by the result of that expansion.</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c33">Note:</span><span class="calibre3">&nbsp;The Macro Stepper is not an </span><span class="c6">evaluator</span><span class="calibre3">. It does not show the steps of evaluation, only the steps of expansion! Thus, if you write a program that will produce an error at run-time, the Macro Stepper does not show that error. It only shows </span><span class="c6">syntax</span><span class="c2">&nbsp;errors.</span></p></div>

<div class="c" id="calibre_link-24">
<h2 class="c21" id="calibre_link-147"><span class="c2">Local Binding</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s look at the </span><span class="c25">let</span><span class="calibre3">&nbsp;bindings we’ve been using until now. Imagine we want to extend Racket with a </span><span class="c25">let1</span><span class="c2">&nbsp;construct: for example, we want</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let1 (x 3) (+ x x))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">to evaluate to 6.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="calibre3">&nbsp;Can </span><span class="c25">let1</span><span class="c2">&nbsp;be defined as a function? Why or why not?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">let1</span><span class="calibre3">&nbsp;can’t be a function. If it were, we would first try to evaluate each of the sub-terms as arguments. There are two things here that look like argument expressions: </span><span class="c25">(x 3)</span><span class="calibre3">&nbsp;and </span><span class="c25">(+ x x)</span><span class="calibre3">. Suppose we try to </span><span class="c6">evaluate</span><span class="calibre3">&nbsp;</span><span class="c25">(x 3)</span><span class="calibre3">. First of all, it looks like an application. Second, </span><span class="c25">x</span><span class="calibre3">&nbsp;isn’t even bound. Third, there is no meaningful “value” it could produce: its only job is instead to </span><span class="c6">bind</span><span class="calibre3">&nbsp;</span><span class="c25">x</span><span class="calibre3">. No, </span><span class="c25">let1</span><span class="c2">&nbsp;is also a new piece of syntax.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;We will often refer to these new pieces of syntax as </span><span class="c6">constructs</span><span class="calibre3">&nbsp;(as in, “a new language construct”). In the Lisp/Scheme/Racket community, these are sometimes also called </span><span class="c6">special forms</span><span class="c2">, because they are syntactic forms with their own special rules for binding and evaluation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">From now on we’ll use the prefix </span><span class="c25">my-</span><span class="c2">&nbsp;on our macros, because we don’t want to clash with the names of macros already built into Racket.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">From what we’ve seen above, we can probably figure out half of the macro for </span><span class="c25">my-let1</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax my-let1</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(my-let1 (var val) body)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;…]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But what would it </span><span class="c25">expan</span><span class="calibre3">d into? We certainly </span><span class="c6">could</span><span class="calibre3">&nbsp;just expand it into the existing </span><span class="c25">let</span><span class="c2">&nbsp;construct in Racket, but there’s another interesting option.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Let’s think about what </span><span class="c25">my-let1</span><span class="calibre3">&nbsp;does: it </span><span class="c6">binds</span><span class="calibre3">&nbsp;a name to a value, and then immediately </span><span class="c6">evaluates</span><span class="calibre3">&nbsp;its body in an environment extended by its name. Now, can we think of anything else that binds names to values? Yes, functions. And functions evaluate a body in an extended environment. When do functions evaluate their body? When they are applied to an argument. Therefore, we can express </span><span class="c25">my-let1</span><span class="c2">&nbsp;in terms of an anonymous function that is applied immediately:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax my-let1</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(my-let1 (var val) body)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;((lambda (var) body) val)]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Sure enough,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(my-let1 (x 3) (+ x x))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">will produce </span><span class="c25">6</span><span class="c2">. Use the Macro Stepper to see how!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;This pattern, of an anonymous function that is used right away, is commonly called </span><span class="c6">left-left-lambda</span><span class="calibre3">&nbsp;(where “left” stands for left-parenthesis). For a long time this remained an obscure term in the Lisp/Scheme community. But JavaScript made this pattern popular again under the name </span><span class="c6">Immediately Invoked Function Expression</span><span class="c2">&nbsp;(IIFE), because of problems with the handling of scope in earlier versions of the language. If you think the parentheses look bad here, look up some examples of IIFE on the Web.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Suppose we make a mistake in the macro and swap two parts:</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c34">(define-syntax my-let1</span></p><p class="c27"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; [(my-let1 (var val) body)</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp;((lambda (var) val) body)]))</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c2">What happens when we try to evaluate</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c34">(my-let1 (x 3) (+ x x))</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c2">? Use the Macro Stepper to see what happened.</span></p></div>

<div class="c" id="calibre_link-38">
<h2 class="c21" id="calibre_link-148"><span class="c2">Binding More Locals</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As we have noticed in Racket, however, the </span><span class="c25">let</span><span class="c2">&nbsp;can bind many names at once, not only one. It becomes clear how: the function takes formal arguments, and is applied to just as many actual arguments. There can be as many as we want! But how do we express this in macro syntax?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In mathematics, it’s common to use ellipses (…) to denote a sequence of arbitrary length. Therefore, it would be nice if we could write something like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax my-let2</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(my-let2 ([var val] ...) body)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;((lambda (var ...) body) val ...)]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This would say, </span><span class="c25">my-let2</span><span class="calibre3">&nbsp;is followed by any number of </span><span class="c25">var</span><span class="calibre3">-</span><span class="c25">val</span><span class="calibre3">&nbsp;pairs, followed by a body. Turn that into a </span><span class="c25">lambda</span><span class="calibre3">&nbsp;with all the </span><span class="c25">var</span><span class="calibre3">s as formal arguments, whose body is </span><span class="c25">body</span><span class="calibre3">, applied to all the same </span><span class="c25">val</span><span class="c2">s as the actual argument expressions. We would use it like so (the extra parens are to help us group the bindings):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(my-let2 ([x 3] [y 4]) (+ x y))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">In fact, that is </span><span class="c6">exactly</span><span class="c2">&nbsp;the syntax supported by Racket! Try out the above program: run it, and also examine it in the Macro Stepper!</span></p></div>

<div class="c" id="calibre_link-44">
<h2 class="c21" id="calibre_link-149"><span class="c2">Multi-Armed Conditionals</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here’s one last example that clarifies what … means: it means “zero or more instances of the preceding pattern”. Using it, we can define our own multi-armed conditional. Suppose we want to define a function called </span><span class="c25">sign</span><span class="c2">&nbsp;that produces a string based on the sign of a number:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (sign n)</span></p><p class="c4"><span class="c34">&nbsp; (my-cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;[(&lt; n 0) "negative"]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;[(= n 0) "zero"]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;[(&gt; n 0) "positive"]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">Again, it’s clear that </span><span class="c25">my-cond</span><span class="c2">&nbsp;can’t be a function; we need to extend the language with a new construct, using a macro.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">How many arms should our multi-armed conditional have? As many as the programmer wants, of course. We’ll further stipulate that if we have exhausted all the questions and none has yielded a true value, the “falling through” produces an error.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Thus, we want to peel off the first question-answer pair and evaluate the question. If it succeeds, we evaluate the answer. Otherwise, we want to recur on the remaining questions…which is essentially a smaller instance of </span><span class="c25">my-cond</span><span class="calibre3">. (That’s right, we’re recurring on </span><span class="c6">syntax</span><span class="c2">&nbsp;now!)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Since </span><span class="c25">…</span><span class="calibre3">&nbsp;means “zero or more”, we end up with a pattern where we repeat a pattern: the first copy peels off the first instance, while the second, followed by a </span><span class="c25">…</span><span class="c2">, captures all the remaining instances:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax my-cond</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(my-cond) (error 'my-cond "should not get here")]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(my-cond [q0 a0] [q1 a1] ...)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(if q0</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a0</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(my-cond [q1 a1] ...))]))</span></p><p class="c3"><span class="c34"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Examine this code in detail. Try out the example above. It’s </span><span class="c6">essential</span><span class="c2">&nbsp;that you run this through the Macro Stepper: you’ll learn a lot about macros from this example!</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-48">
<h1 class="c26" id="calibre_link-394"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-150"><span class="c2">More on Macros</span></h1><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Note:</span><span class="calibre3">&nbsp;All the examples from this chapter you can find in a video on YouTube, so if you prefer, you can watch that instead: </span><span class="c59"><a class="c10" href="https://www.google.com/url?q=https://youtu.be/2FK6jpAcX9Q&amp;sa=D&amp;source=editors&amp;ust=1695232021251280&amp;usg=AOvVaw2wCzzJcOXLR7zXUAetXhxF">More on Macros</a></span><span class="c2">. Be sure to stop and reflect after each example, and try each of them out for yourself!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s start to look at various idiomatic aspects of using Racket macros. We’ll want this understanding under our belt because we’ll make use of several of these features. Here are five concrete things we’ll see:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre5 c23"><span class="c2">A convenience in definitions</span></li><li class="pcalibre5 c23"><span class="c2">A major and critical macro feature</span></li><li class="pcalibre5 c23"><span class="c2">An important idiom in truthy/falsy languages</span></li><li class="pcalibre5 c23"><span class="c2">A peril in macro definitions</span></li><li class="pcalibre5 c23"><span class="c2">A push to generalize definitions</span></li></ul></div>

<div class="c" id="calibre_link-360">
<h2 class="c21" id="calibre_link-151"><span class="c2">A Definitional Convenience</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Supposing we want to define a “one-armed </span><span class="c25">if</span><span class="calibre3">” (e.g., useful for checking erroneous conditions and proceeding only if the coast is clear): this is commonly called </span><span class="c25">unless</span><span class="calibre3">. We can write it this way:</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c34">(define-syntax unless</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_ cond body ...)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(if (not cond)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;body</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(void))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">For instance, we can use it this way:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(unless false</span></p><p class="c4"><span class="c34">&nbsp; (println 1)</span></p><p class="c4"><span class="c34">&nbsp; (println 2))</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c2">Notice that in the pattern, we don’t have to repeat the `unless`; we can just use an `_` instead.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;The full truth is, this isn’t just a </span><span class="c6">convenience</span><span class="calibre3">. They actually do slightly different things that you can detect in subtle situations. You can safely, and should, just use </span><span class="c25">_</span><span class="c2">&nbsp;instead of repeating the name of the macro.</span></p></div>

<div class="c" id="calibre_link-365">
<h2 class="c21" id="calibre_link-152"><span class="c2">Name Capture</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But now, what if we use the above code in this kind of context:</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c34">(let ([not (λ (v) v)])</span></p><p class="c4"><span class="c34">&nbsp; (unless false</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (println 1)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; (println 2)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This seems problematic: it seems to expand into</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([not (λ (v) v)])</span></p><p class="c4"><span class="c34">&nbsp; (if (not false)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (println 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (println 2))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (void)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">which is pretty much the opposite of what we want. That’s because the </span><span class="c25">not</span><span class="calibre3">&nbsp;outside the macro seems to have captured the </span><span class="c25">not</span><span class="c2">&nbsp;inside the macro. This is roughly analogous to dynamic scope: any use context can modify what happens inside the abstraction. If this were true, it would be terrifying to be a macro writer!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;Run both versions. Do they produce the same answer?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But running the macro version makes clear that the name </span><span class="c25">not</span><span class="calibre3">&nbsp;is </span><span class="c6">not</span><span class="calibre3">&nbsp;being captured. Most of all, use the Macro Stepper to see how the expansion works. The important thing is that variables are more than just </span><span class="c6">names</span><span class="c2">; they record binding information, which keeps names introduced in different settings separate. They may print the same way, but internally Racket keeps them separate (and shows this separation in the Macro Stepper using colors). That is, it’s as if we start with this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c61">(let ([not (λ (v) v)])</span></p><p class="c4"><span class="c61">&nbsp; (unless false</span></p><p class="c4"><span class="c61">&nbsp; &nbsp; (println 1)</span></p><p class="c4"><span class="c62">&nbsp; &nbsp; (println 2)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which, after expansion, turns into this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c61">(let ([not (λ (v) v)])</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c63">(if (not false)</span></p><p class="c4"><span class="c63">&nbsp; &nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c63">&nbsp; &nbsp; &nbsp; &nbsp; (println 1)</span></p><p class="c4"><span class="c63">&nbsp; &nbsp; &nbsp; &nbsp; (println 2))</span></p><p class="c4"><span class="c64">&nbsp; &nbsp; &nbsp; (void))</span><span class="c61">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So now we can easily keep the identifiers apart: the red </span><span class="c62">not</span><span class="calibre3">&nbsp;is different from the blue </span><span class="c64">not</span><span class="calibre3">. The actual internal representation is an efficient analog to colors. If necessary, the macro expander can also use distinct </span><span class="c6">fresh</span><span class="calibre3">&nbsp;(i.e., previously unused) names&mdash;</span><span class="c25">not1</span><span class="calibre3">, </span><span class="c25">not2</span><span class="c2">, etc.&mdash;to represent the different variables of the same name.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This property, which recovers an analog of static scoping for macros, and is called </span><span class="c6">hygiene</span><span class="calibre3">. Hygiene is a critical feature for macros (and, notably, is one </span><span class="c6">not</span><span class="c2">&nbsp;given by the C pre-processor). It lets programmers use whatever name they want in the macro definition without worrying about what names will be bound in the use context; and similarly, lets users use whatever variable names they want without worrying about the macro’s code.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That said, you may wonder whether hygiene is just for built-in functions like </span><span class="c25">not</span><span class="c2">. We’ll see that it’s not. But to get there, we’ll work through some other idiomatic examples.</span></p></div>

<div class="c" id="calibre_link-69">
<h2 class="c21" id="calibre_link-153"><span class="c2">A Truthy/Falsy Idiom</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Unrelated to macros, here’s something we often see in truthy/falsy languages. Consider a two-arm </span><span class="c25">or</span><span class="calibre3">, which we can define as a macro:</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c34">(define-syntax or-2</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_ e1 e2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(if e1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;true</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e2)]))</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c2">This works well enough for</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c34">(or-2 true false)</span></p><p class="c4"><span class="c34">(or-2 false false)</span></p><p class="c4"><span class="c34">(or-2 false true)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, consider a function like </span><span class="c25">member</span><span class="c2">:</span></p><p class="c3"><span class="c60"></span></p><p class="c27"><span class="c34">(member 'y '(x y z))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">When it succeeds, it doesn’t just return </span><span class="c25">true</span><span class="calibre3">, it returns the entire rest of the list (which is a truthy value). But if we combine this with </span><span class="c25">or-2</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(or-2 (member 'y '(x y z)) "not found")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This is clearly not the result we want: we’ve lost the useful return value. Instead, here’s a different macro that returns rather than suppressing that result:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax or-2</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_ e1 e2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(if e1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;e2)]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This makes</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(or-2 (member 'y '(x y z)) "not found")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">work as expected. </span></p></div>

<div class="c" id="calibre_link-70">
<h2 class="c21" id="calibre_link-154"><span class="c2">A Macro Definition Peril</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">However, this macro contains a subtle (almost hidden), important peril. Consider this example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(or-2 (print "hello") "not found")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That also returns a truthy value, but now we see the print </span><span class="c6">twice</span><span class="c2">. So we need</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax or-2</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_ e1 e2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([v e1])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(if v v e2))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Confirm that this produces the correct answer.</span></p></div>

<div class="c" id="calibre_link-282">
<h2 class="c21" id="calibre_link-155"><span class="c2">Back to Hygiene</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This now works fine for the printing example. But now we have to worry about</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([v 1])</span></p><p class="c4"><span class="c34">&nbsp; (or-2 false v))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Using fresh names, there are two things this could expand into:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([v 1])</span></p><p class="c4"><span class="c34">&nbsp; (let ([v false])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (if v</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; v</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; v)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([v0 1])</span></p><p class="c4"><span class="c34">&nbsp; (let ([v1 false])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (if v1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; v1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; v0)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Which does the macro version produce? That’s right, the latter: the one corresponding to</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c61">(let ([v 1])</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c63">(let ([v false])</span></p><p class="c4"><span class="c63">&nbsp; &nbsp; (if v</span></p><p class="c4"><span class="c63">&nbsp; &nbsp; &nbsp; &nbsp; v</span></p><p class="c4"><span class="c64">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c62">v</span><span class="c64">))</span><span class="c61">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In other words, hygiene works just as well for local variables, not just for built-in functions! In other words, we have spent a whole bunch of time on something you </span><span class="c6">don’t</span><span class="c2">&nbsp;need to worry about. In return, it means you can use names with impunity in your macro programs, just as you do inside functions and methods because of static scoping.</span></p></div>

<div class="c" id="calibre_link-284">
<h2 class="c21" id="calibre_link-156"><span class="c2">Generalizing Macros</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, unlike the poor programmers stuck with their infix syntaxes and binary operators, parenthetical syntax programmers can generalize constructs to arbitrary arity. We’ve seen </span><span class="c25">…</span><span class="calibre3">&nbsp;already; let’s put it to work here to create an </span><span class="c6">n</span><span class="calibre3">-ary </span><span class="c25">or</span><span class="c2">. A natural first definition is</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax orN</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_ e1 e2 ...)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([v e1])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(if v v (orN e2 ...)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;However, &nbsp;see what happens when we try:</span></p><p class="c43"><span class="c2"></span></p><p class="c65"><span class="c34">(let ([v true])</span></p><p class="c65"><span class="c34">&nbsp; (orN false v))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, so that doesn’t work. It’s important to pay attention to the error message:</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="c66">orN: bad syntax in: (orN)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This highlights the need for a base case. The problem is our definition above requires one or more sub-expressions: </span><span class="c25">e1</span><span class="calibre3">&nbsp;is the first, and </span><span class="c25">e2 …</span><span class="calibre3">&nbsp;means </span><span class="c6">zero or more</span><span class="c2">&nbsp;from the second position onward. But nothing covers the case of no sub-terms. So we need</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-syntax orN</span></p><p class="c4"><span class="c34">&nbsp; (syntax-rules ()</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_) false]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(_ e1 e2 ...)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([v e1])</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp;(if v v (orN e2 ...)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and of course this works fine.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c33">Exercise: </span><span class="calibre3">The problem above appears to have been self-inflicted: why did we start with the pattern </span><span class="c25">(_ e1 e2 ...)</span><span class="calibre3">, which requires one-or-more (</span><span class="c25">e1</span><span class="calibre3">&nbsp;is the first, </span><span class="c25">e2 …</span><span class="calibre3">&nbsp;is zero or more)? We should have just written </span><span class="c25">(_ e...)</span><span class="calibre3">&nbsp;instead, which would be zero-or-more! Rewrite the </span><span class="c25">orN</span><span class="c2">&nbsp;macro using this pattern: can you make it work?</span></p></div>

<div class="c" id="calibre_link-289">
<h1 class="c26" id="calibre_link-395"><span class="c2"></span></h1><h1 class="c13" id="calibre_link-157"><span class="c2">•••••&nbsp;Objects •••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c28">Objects&mdash;the bundling of data with operations over them&mdash;are a generalization of closures. Many languages have objects, but in a variety of different forms.</span></p></div>

<div class="c" id="calibre_link-294">
<h1 class="c20" id="calibre_link-158"><span class="c2">A Standard Model of Objects</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we’re ready to start looking at our first major language feature that goes beyond SMoL: objects. Not all SMoL languages have objects; though many do, they have them in very different ways. Nevertheless, what we will see is that there is a fairly uniform way to think about objects across all these languages, and furthermore this way of thinking really builds on our understanding of SMoL.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">When building the essence of objects, though, we now have a choice: we can do it either in the core or through syntactic sugar. The former is frustrating in several ways:</span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">We have to do more low-level bookkeeping (e.g., with environments) that may not necessarily be </span><span class="c6">instructive</span><span class="c2">.</span></li><li class="pcalibre c23"><span class="c2">The interpreter gets larger and more unwieldy, because all the new constructs go in the same place rather than each being independent definitions.</span></li><li class="pcalibre c23"><span class="c2">Most of all: it becomes a lot harder to write illustrative programs and tests, because the core language may not have all the features we need to make this convenient.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In contrast, all these problems go away if we use syntactic sugar instead. Therefore, even though a real implementation may well have at least parts of objects (especially the parts needed for efficiency) in the core language, we are going to build objects entirely through desugaring, using macros. In fact, in this book, we will do something even simpler: we will give </span><span class="c6">concrete examples </span><span class="calibre3">of what programs desugar </span><span class="c6">to</span><span class="c2">. Figuring out the general desugaring will be left as an exercise for you. To aid in that process, we will write code in as stylized a form as possible, not using any short-cuts that might obscure the macro rules.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Note:</span><span class="calibre3">&nbsp;The programs in this section cannot be written in the language </span><span class="c25">plait</span><span class="calibre3">. Instead, we will use &nbsp;</span><span class="c25">#lang racket</span><span class="c2">, which does not perform static type-checking. Add the line</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c34">(require [only-in plait test print-only-errors])</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="calibre3">at the top to access the testing operator and printing control parameter from </span><span class="c25">plait</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Spot the point at which the type-checker would become problematic. </span><span class="c33">Hint:</span><span class="calibre3">&nbsp;The easiest way is, of course, to keep using </span><span class="c25">#lang plait</span><span class="c2">&nbsp;until you run into a problem. Make sure you understand what the problem is!</span></p></div>

<div class="c" id="calibre_link-361">
<h2 class="c21" id="calibre_link-159"><span class="c2">What is an Object?</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The central question we must answer, before we start thinking about implementations, is what an object is. There is a lot of variation between languages, but they all seem to agree that an object is</span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">a value, that</span></li><li class="pcalibre c23"><span class="c2">maps names to </span></li><li class="pcalibre c23"><span class="c2">stuff: either other values or “methods”.</span></li></ul><p class="c4"><span class="c2">From a minimalist perspective, methods seem to be just functions, and since we already have those in the language, we can put aside this distinction.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;We will use the term </span><span class="c6">member</span><span class="c2">&nbsp;to refer to a generic entry in an object, when we don’t want to make a distinction between fields and methods.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">How can we capture this? An object is just a value that dispatches on a given name. For simplicity, we’ll use </span><span class="c25">lambda</span><span class="calibre3">&nbsp;to represent the object and Racket’s </span><span class="c25">case</span><span class="c2">&nbsp;construct to implement the dispatching. Here’s an object that responds to either add1 or sub1, and in each case returns a function that either increments or decrements:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define o</span></p><p class="c4"><span class="c34">&nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(add1) (lambda (x) (+ x 1))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(sub1) (lambda (x) (- x 1))])))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We would use this as follows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test ((o 'add1) 5) 6)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Observe that basic objects are a generalization of </span><span class="c25">lambda</span><span class="calibre3">&nbsp;to have multiple “entry-points”. Conversely, a </span><span class="c25">lambda</span><span class="calibre3">&nbsp;is an object with only </span><span class="c6">one</span><span class="c2">&nbsp;entry-point; therefore, it doesn’t need a “method name” to disambiguate.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Of course, writing method invocations with these nested function calls is unwieldy (and is about to become even more so), so we’d be best off equipping ourselves with a convenient syntax for invoking methods:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (msg o m . a)</span></p><p class="c4"><span class="c34">&nbsp; (apply (o m) a))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This enables us to rewrite our test:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (msg o 'add1 5) 6)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;We’ve taken advantage of Racket’s variable-arity syntax: </span><span class="c25">. a</span><span class="calibre3">&nbsp;says “bind all the remaining&mdash;zero or more&mdash;arguments to a list named </span><span class="c25">a</span><span class="calibre3">”. The </span><span class="c25">apply</span><span class="c2">&nbsp;function “splices” in such lists of arguments to call functions.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe something very subtle about our language: nothing precludes us from writing an arbitrary expression in the second position of a call to </span><span class="c25">msg</span><span class="calibre3">. That is, we can </span><span class="c6">compute</span><span class="c2">&nbsp;which member we want to access. For instance:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (msg o (first '(add1)) 5) 6)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This is unlike many languages with objects, which force you to write the literal </span><span class="c6">name</span><span class="c2">&nbsp;of the member (e.g., in Java, in most cases). We’ll return to this later!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;This is a general problem with desugaring: the target language may allow expressions that have no counterpart in the source, and hence cannot be mapped back to it. Fortunately we don’t often need to perform this inverse mapping, though it does arise in some debugging and program comprehension tools. More subtly, however, we must ensure that the target language does not produce </span><span class="c6">values</span><span class="c2">&nbsp;that have no corresponding equivalent in the source.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now that we have basic objects, let’s start adding the kinds of features we’ve come to expect from most object systems.</span></p></div>

<div class="c" id="calibre_link-6">
<h2 class="c21" id="calibre_link-160"><span class="c2">The “Object” Pattern</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can consolidate what we have written above as the “object” pattern: code that looks like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; … dispatch on each of the members …))</span></p></div>

<div class="c" id="calibre_link-3">
<h2 class="c21" id="calibre_link-161"><span class="c2">Constructors</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A constructor is simply a function that is invoked at object construction time. We currently lack such a feature, but by turning an object from a literal into a function that takes constructor parameters, we achieve this effect:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (o-constr x)</span></p><p class="c4"><span class="c34">&nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(addX) (lambda (y) (+ x y))])))</span></p><p class="c4"><span class="c34">&nbsp;</span></p><p class="c4"><span class="c34">(test (msg (o-constr 5) 'addX 3) 8)</span></p><p class="c4"><span class="c34">(test (msg (o-constr 2) 'addX 3) 5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In the first example, we pass 5 as the constructor’s argument, so adding 3 yields 8. The second is similar, and shows that the two invocations of the constructors don’t interfere with one another (just as we would expect from static scope).</span></p></div>

<div class="c" id="calibre_link-4">
<h2 class="c21" id="calibre_link-162"><span class="c2">The “Class” Pattern</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We’ve actually made quite a momentous change with this small addition: we’ve gone from objects to functions-that-make-objects (notice the object pattern inside the function). But traditionally, what makes objects? Classes! And classes typically have constructors. So in the process of introducing constructors, we have actually also shifted from objects to classes. The “class” pattern, at its simplest, is:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (class constructor-params)</span></p><p class="c4"><span class="c34">&nbsp; … the object pattern …)</span></p></div>

<div class="c" id="calibre_link-5">
<h2 class="c21" id="calibre_link-163"><span class="c2">State</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Many people believe that objects primarily exist to encapsulate state.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Curiously, Alan Kay, who won a Turing Award for inventing Smalltalk and modern object technology, disagrees. In </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=http://worrydream.com/EarlyHistoryOfSmalltalk/&amp;sa=D&amp;source=editors&amp;ust=1695232021277736&amp;usg=AOvVaw2Jq9XZtuuo6438N_xh50ZK">The Early History of Smalltalk</a></span><span class="c2">, he says, “[t]he small scale [motivation for OOP] was to find a more flexible version of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate that much of what is called ‘object-oriented programming’ today is simply old style programming with fancier constructs. Many programs are loaded with ‘assignment-style’ operations now done by more expensive attached procedures.”</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We certainly haven’t lost that ability. If we desugar to a language with variables, we can easily have multiple methods mutate common state, such as a constructor argument:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (mk-o-state count)</span></p><p class="c4"><span class="c34">&nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(inc) (lambda () (set! count (+ count 1)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(dec) (lambda () (set! count (- count 1)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(get) (lambda () count)])))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We have changed the name to </span><span class="c25">mk-o-…</span><span class="calibre3">&nbsp;to reflect the fact that this is an object-</span><span class="c6">maker</span><span class="c2">, i.e., analogous to a class. For instance, we can test a sequence of operations:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (let ([o (mk-o-state 5)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (begin (msg o 'inc)</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;(msg o 'inc)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg o 'dec)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg o 'get)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 6)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and also notice that mutating one object doesn’t affect another:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (let ([o1 (mk-o-state 3)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [o2 (mk-o-state 3)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (begin (msg o1 'inc)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg o1 'inc)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(+ (msg o1 'get)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (msg o2 'get))))</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; (+ 5 3))</span></p></div>

<div class="c" id="calibre_link-7">
<h2 class="c21" id="calibre_link-164"><span class="c2">Private Members</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Another common object language feature is private members: ones that are visible only inside the object, not outside it. &nbsp;</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;Except that, in Java, instances of other classes of the same type are privy to “private” members. Otherwise, you would simply never be able to implement an Abstract Data Type. Note that classes are not Abstract Data Types!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These may seem like an additional feature we need to implement, but we already have the necessary mechanism in the form of locally-scoped, lexically-bound variables:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (mk-o-state/priv init)</span></p><p class="c4"><span class="c34">&nbsp; (let ([count init])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; [(inc) (lambda () (set! count (+ count 1)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; [(dec) (lambda () (set! count (- count 1)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; [(get) (lambda () count)]))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The code above uses lexical scoping to ensure that </span><span class="c25">count</span><span class="calibre3">&nbsp;remains hidden to the world. Trying to access </span><span class="c25">count</span><span class="c2">&nbsp;directly from the outside will fail.</span></p></div>

<div class="c" id="calibre_link-8">
<h2 class="c21" id="calibre_link-165"><span class="c2">A Refined “Class” Pattern</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With this change, we can now refine our pattern for classes:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (class-w/-private constructor-params)</span></p><p class="c4"><span class="c34">&nbsp; (let ([private-vars …] …)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; … the object pattern …))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which we can also write as:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define class-w/-private</span></p><p class="c4"><span class="c34">&nbsp; (lambda (constructor-params)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (let ([private-vars …] …)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; … the object pattern …)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We’ll see in a moment why we might want to do this.</span></p></div>

<div class="c" id="calibre_link-9">
<h2 class="c21" id="calibre_link-166"><span class="c2">Static Members</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Another feature often valuable to users of objects is static members: those that are common to all instances of the same type of object. This, however, is merely a lexically-scoped identifier (making it private) that lives outside the constructor (making it common to all uses of the constructor).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Suppose we want to keep a count of how many instances of a kind of object are created. This count cannot be inside any one of those objects, because they would not “know” about each other; rather, the constructor needs to keep track of this. This is the role of static members, and the variable </span><span class="c25">counter</span><span class="c2">&nbsp;plays this role in the following example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define mk-o-static</span></p><p class="c4"><span class="c34">&nbsp; (let ([counter 0])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (lambda (amount)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (set! counter (+ 1 counter))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(inc) (lambda (n) (set! amount (+ amount n)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(dec) (lambda (n) (set! amount (- amount n)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(get) (lambda () amount)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(count) (lambda () counter)]))))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We’ve written the counter increment where the “constructor” for this object would go, though it could just as well be manipulated inside the methods.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To test it, we should make multiple objects and ensure they each affect the global count:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (let ([o (mk-o-static 1000)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (msg o 'count))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 1)</span></p><p class="c4"><span class="c34">&nbsp;</span></p><p class="c4"><span class="c34">(test (let ([o (mk-o-static 0)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (msg o 'count))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It is productive to see how this program runs through the Stacker. For simplicity, we can ignore most of the details and focus just on the core static pattern. Here is a Stacker-friendly translation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang stacker/smol/hof</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(defvar mk-o-static</span></p><p class="c4"><span class="c34">&nbsp; (let ([counter 0])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (lambda (amount)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (set! counter (+ 1 counter))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (equal? m "get")</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda () amount)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (equal? m "count")</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counter</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (error "no such member"))))))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(defvar o1 (mk-o-static 1000))</span></p><p class="c4"><span class="c34">(defvar o2 (mk-o-static 0))</span></p><p class="c4"><span class="c34">(o1 "count")</span></p><p class="c4"><span class="c34">(o2 "count")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Run this and see how the static member works!</span></p></div>

<div class="c" id="calibre_link-10">
<h2 class="c21" id="calibre_link-167"><span class="c2">A Re-Refined “Class” Pattern</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we can refine our pattern for classes even further:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define class-w/-private&amp;static</span></p><p class="c4"><span class="c34">&nbsp; (let ([static-vars …] …)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (lambda (constructor-params)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (let ([private-vars …] …)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; … the object pattern …))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Put differently:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define class-w/-private&amp;static</span></p><p class="c4"><span class="c34">&nbsp; (let ([static-vars …] …)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; … the class-w/-private pattern …))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="calibre3">Statics, as defined here, are accessed through </span><span class="c6">objects</span><span class="calibre3">. However, statics by definition belong to a </span><span class="c6">class</span><span class="calibre3">, not to objects, and hence should be accessible through the class itself&mdash;for instance, even if no instances of the class have ever been created. (In the working example above, one should be able to access the count when it is still </span><span class="c25">0</span><span class="calibre3">.) Modify the pattern above to respect this by making static members be accessible directly through the </span><span class="c6">class</span><span class="c2">&nbsp;rather than through objects.</span></p></div>

<div class="c" id="calibre_link-11">
<h2 class="c21" id="calibre_link-168"><span class="c2">Objects with Self Reference</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Until now, our objects have simply been packages of named functions: functions with multiple named entry-points, if you will. We’ve seen that many of the features considered important in object systems are actually simple patterns over functions and scope, and have indeed been used&mdash;without names assigned to them&mdash;for decades by programmers armed with lambdas.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What this means is that the different members are actually independent of each other: they can’t, for instance, directly reference one another. This is too limiting for a true object system, where a method has a way of referencing the object it is part of so that it can use other members of that object. To enable this, many object systems automatically equip each object with a reference to itself, often called </span><span class="c25">self</span><span class="calibre3">&nbsp;or </span><span class="c25">this</span><span class="c2">. Can we implement this?</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside</span><span class="c2">: I prefer this slightly dry way of putting it to the anthropomorphic “knows about itself” terminology often adopted by object advocates. Indeed, note that we have gotten this far into object system properties without ever needing to resort to anthropomorphism. </span></p><h3 class="c67" id="calibre_link-169"><span class="c68">Self-Reference Using Mutation</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Yes, we can! This relies on a pattern that sets up the name for the recursive reference, then uses that to create the body that will employ the recursion, and finally uses mutation to make the name refer to the defined body. For simplicity, we will go back to the</span><span class="c6">&nbsp;object</span><span class="c2">&nbsp;pattern, ignoring the class-related features:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define o-self!</span></p><p class="c4"><span class="c34">&nbsp; (let ([self 'dummy])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! self</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(first) (lambda (x) (msg self 'second (+ x 1)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(second) (lambda (x) (+ x 1))])))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; self)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We can test it by having </span><span class="c25">first</span><span class="calibre3">&nbsp;invoke </span><span class="c25">second</span><span class="c2">. Sure enough, this produces the expected answer:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (msg o-self! 'first 5) 7)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here is the above program translated into the simpler smol/fun language. Once translated, we can run it in the Stacker:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang stacker/smol/hof</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(defvar o-self!</span></p><p class="c4"><span class="c34">&nbsp; (let ([self 0])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! self</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (equal? m "first")</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (x) ((self "second") (+ x 1)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (equal? m "second")</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (x) (+ x 1))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (error "no such member")))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; self)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">((o-self! "first") 5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Run it for yourself! What do you learn from it? Do you see how </span><span class="c25">self</span><span class="c2">&nbsp;works?</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;This change to the object pattern is essentially </span><span class="c6">independent</span><span class="c2">&nbsp;of the class pattern. Extend the class pattern to include self-reference.</span></p><h3 class="c67" id="calibre_link-170"><span class="c68">Self-Reference Without Mutation</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There’s another pattern we can use that avoids mutation, which is to send the object itself as a parameter:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define o-self-no!</span></p><p class="c4"><span class="c34">&nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(first) (lambda (self x) (msg/self self 'second (+ x 1)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(second) (lambda (self x) (+ x 1))])))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Each method now takes </span><span class="c25">self</span><span class="c2">&nbsp;as an argument. That means method invocation must be modified to follow this new pattern:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (msg/self o m . a)</span></p><p class="c4"><span class="c34">&nbsp; (apply (o m) o a))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, when invoking a method on </span><span class="c25">o</span><span class="calibre3">, we must pass </span><span class="c25">o</span><span class="c2">&nbsp;as a parameter to the method. Notice that we did not do any such thing when invoking a function! This distinguishes functions and methods.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Obviously, this approach is dangerous because we can potentially pass a different object as the “self”. Exposing this to the developer is therefore probably a bad idea; if this implementation technique is used, it should only be done in desugaring. (Unfortunately, Python exposes exactly this in its surface syntax.) Sure enough:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (msg/self o-self-no! 'first 5) 7)</span></p></div>

<div class="c" id="calibre_link-12">
<h2 class="c21" id="calibre_link-171"><span class="c2">Dynamic Dispatch</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Finally, we should make sure our objects can handle a characteristic attribute of object systems, which is the ability to invoke a method without the caller having to know or decide which object will handle the invocation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Suppose we have a binary tree data structure, where a tree consists of either empty nodes or leaves that hold a value. In traditional functions, we are forced to implement some form of conditional&mdash;such as a </span><span class="c25">type-case</span><span class="c2">&mdash;that exhaustively lists and selects between the different kinds of trees. If the definition of a tree grows to include new kinds of trees, each of these code fragments must be modified.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Dynamic dispatch solves this problem by making that conditional branch disappear from the user’s program and instead be handled by the method selection code built into the language. The key feature that this provides is an extensible conditional. This is one dimension of the extensibility that objects provide.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s first define our two kinds of tree objects:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (mt)</span></p><p class="c4"><span class="c34">&nbsp; (let ([self 'dummy])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! self</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(sum) (lambda () 0)])))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; self)))</span></p><p class="c4"><span class="c2">&nbsp;</span></p><p class="c4"><span class="c34">(define (node v l r)</span></p><p class="c4"><span class="c34">&nbsp; (let ([self 'dummy])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! self</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(sum) (lambda () (+ v</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg l 'sum)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg r 'sum)))])))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; self)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With these, we can make a concrete tree:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define a-tree</span></p><p class="c4"><span class="c34">&nbsp; (node 10</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (node 5 (mt) (mt))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (node 15 (node 6 (mt) (mt)) (mt))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">And finally, test it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (msg a-tree 'sum) (+ 10 5 15 6))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that both in the test case and in the </span><span class="c25">sum</span><span class="calibre3">&nbsp;method of </span><span class="c25">node</span><span class="calibre3">, there is a reference to </span><span class="c25">’sum</span><span class="calibre3">&nbsp;without checking whether the recipient is a </span><span class="c25">mt</span><span class="calibre3">&nbsp;or </span><span class="c25">node</span><span class="calibre3">. Instead, the </span><span class="c6">language’s run-time system</span><span class="calibre3">&nbsp;extracts the recipient’s </span><span class="c25">sum</span><span class="c2">&nbsp;method and invokes it. This conditional missing from the user’s program, and handled automatically by the language, &nbsp;is the essence of dynamic dispatch.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It’s worth noting that we didn’t have to change our pattern to add dynamic dispatch; </span><span class="c6">it simply followed as a result of the rest of the design</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;This property&mdash;which appears to make systems more black-box extensible because one part of the system can grow without the other part needing to be modified to accommodate those changes&mdash;is often hailed as a key benefit of object-orientation. While this is indeed an advantage objects have over functions, there is a dual advantage that functions have over objects, and indeed many object programmers end up contorting their code&mdash;using the Visitor pattern&mdash;to make it look more like a function-based organization. Read </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&amp;sa=D&amp;source=editors&amp;ust=1695232021299288&amp;usg=AOvVaw3CC6NAYK9gN3UxWzQtILYg">Synthesizing Object-Oriented and Functional Design to Promote Re-Use</a></span><span class="calibre3">&nbsp;for a running example that will lay out the problem in its full glory. Try to solve it in your favorite language, and see the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml&amp;sa=D&amp;source=editors&amp;ust=1695232021299768&amp;usg=AOvVaw1BZuSy7k1EJ8XRqphKUm57">Racket solution</a></span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-352">
<h1 class="c20" id="calibre_link-172"><span class="c2">What Else do Objects Have?</span></h1><h2 class="c21" id="calibre_link-173"><span class="c2">Member Name Design Space</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we will focus on the names of members (a term we use to not distinguish between fields and methods). Also, let’s set aside the distinction between classes and objects for a moment: whether through classes or not, we eventually end up with objects, which programs use. So the two questions are:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">Is the set of member names statically fixed, or can it be changed dynamically?</span></li><li class="pcalibre c23"><span class="c2">Is the member being accessed at a point statically fixed, or can it be computed dynamically?</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This gives us a 2x2 table, and it’s worthwhile to ask whether each cell makes sense (and whether we’ve seen it in any real languages). We get:</span></p><p class="c3"><span class="c2"></span></p><a id="calibre_link-396"></a><a id="calibre_link-397"></a><table class="c37"><tbody class="calibre13"><tr class="c38"><td class="c69" colspan="1" rowspan="1"><p class="c44"><span class="c2"></span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c7"><span class="c41">Name is Static</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c7"><span class="c41">Name is Computed</span></p></td></tr><tr class="c38"><td class="c69" colspan="1" rowspan="1"><p class="c70"><span class="c41">Fixed Set of Members</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c4"><span class="c2">As in base Java.</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c4"><span class="c2">As in Java with reflection to compute the name.</span></p></td></tr><tr class="c38"><td class="c69" colspan="1" rowspan="1"><p class="c70"><span class="c41">Variable Set of Members</span></p><p class="c71"><span class="c41"></span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c4"><span class="c2">Difficult to envision (what use would it be?).</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c4"><span class="c2">Most “scripting” languages.</span></p></td></tr></tbody></table><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Only one case does not quite make sense: if the member being accessed must be fixed in the source program, then the set of names is pre-decided, so it doesn’t seem to make sense to be able to dynamically change the set of members (new members would not be accessible, while deleted members would cause some existing accesses might fail). All other points in this design space have, however, been explored by languages.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The lower-right quadrant corresponds closely with languages that use hash-tables to represent objects. Then the name is simply the index into the hash-table. Some languages carry this to an extreme and use the same representation even for numeric indices, thereby (for instance) conflating objects with dictionaries and even arrays. Even when the object only handles “member names”, this style of object creates significant difficulty for type-checking and is hence not automatically desirable.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Therefore, in the rest of this section, we will stick with “traditional” objects that have a fixed set of names and even static member name references (the top-left quadrant). Even then, we will find there is much, much more to study.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-369">
<h2 class="c21" id="calibre_link-174"><span class="c2">What (Goes In) Else?</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Until now, our case statements have not had an </span><span class="c25">else</span><span class="calibre3">&nbsp;clause. One reason to do so would be if we had a variable set of members in an object, though that is probably better handled through a different representation than a conditional: a hash-table, for instance, as we’ve discussed above. In contrast, if an object’s set of members is fixed, desugaring to a conditional works well for the purpose of illustration (because it </span><span class="c6">emphasizes</span><span class="calibre3">&nbsp;the fixed nature of the set of member names, which a hash table leaves open to interpretation&mdash;and also error). There is, however, another reason for an </span><span class="c25">else</span><span class="calibre3">&nbsp;clause, which is to “chain” control to another, parent, object. This is called </span><span class="c6">inheritance</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s return to our model of desugared objects. To implement inheritance, the object must be given “something” to which it can delegate method invocations that it does not recognize. A great deal will depend on what that “something” is.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">One answer could be that it is simply another object:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(case m</span></p><p class="c4"><span class="c34">&nbsp; ...</span></p><p class="c4"><span class="c34">&nbsp; [else (parent-object m)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Due to our representation of objects, this application effectively searches for the member in the parent object (and, presumably, recursively in its parents). If a member matching the name is found, it returns through this chain to the original call in </span><span class="c25">msg</span><span class="c2">&nbsp;that sought the member. If none is found, the final object presumably signals a “message not found” error.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;If you know what an l-value is, then you might notice that the application </span><span class="c25">(parent-object m)</span><span class="calibre3">&nbsp;is like “half a </span><span class="c25">msg</span><span class="c2">”, just like an l-value was “half a value lookup”. Is there any connection?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Let’s try this by extending our trees to implement another method, </span><span class="c25">size</span><span class="calibre3">. We’ll write an “extension” (you may be tempted to say “sub-class”, but hold off for now!) for each </span><span class="c25">node</span><span class="calibre3">&nbsp;and </span><span class="c25">mt</span><span class="calibre3">&nbsp;to implement the </span><span class="c25">size</span><span class="calibre3">&nbsp;method. We intend these to extend the existing definitions of </span><span class="c25">node</span><span class="calibre3">&nbsp;and </span><span class="c25">mt</span><span class="c2">, so we’ll use the extension pattern described above. In other words, if we previously had the rough equivalent of this Java code:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Mt &nbsp; { … Mt() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ … } sum() { … } }</span></p><p class="c4"><span class="c34">class Node { … Node(v, l, r) { … } sum() { … } }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">now we want to extend it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class MtSize &nbsp; extends Mt &nbsp; { …&nbsp;size() { … } …&nbsp;}</span></p><p class="c4"><span class="c34">class NodeSize extends Node { … size() { … } … }</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;We’re not editing the existing definitions because that is supposed to be the whole point of object inheritance: to reuse code in a black-box fashion. This also means different parties, who do not know one another, can each extend the same base code. If they had to edit the base, first they have to find out about each other, and in addition, one might dislike the edits of the other. Inheritance is meant to sidestep these issues entirely.</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">Relatedly, read about the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Fragile_base_class&amp;sa=D&amp;source=editors&amp;ust=1695232021308845&amp;usg=AOvVaw0jUQoyWZ_AaVZEFstRRSte">fragile base class problem</a></span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-377">
<h2 class="c21" id="calibre_link-175"><span class="c2">A Java Excursion</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s first understand what’s going on in Java. For simplicity, let’s use a canonical “2d point” and “3d point” example. We’ll start with this class:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Pt2 {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt2(int x, int y) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pt2 with " + x + " and " + y);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can make instances of it easily enough:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; public static void main(String[] args) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pt2 p2 = new Pt2(1, 2);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c2">and this prints the expected output. Now suppose we extend this class:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Pt3 extends Pt2 {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt3(int x, int y, int z) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pt3 with " + z);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c6">This won’t even compile</span><span class="calibre3">. We will get a somewhat strange-looking error. The error is because Java is expecting to make an instance of </span><span class="c25">Pt2</span><span class="calibre3">&nbsp;as well, but we have not told it how to. In the absence of anything else, it invokes a “default constructor”, which takes </span><span class="c6">no</span><span class="calibre3">&nbsp;parameters (because Java has no way of knowing which parameters to pass). If we modify </span><span class="c25">Pt2</span><span class="c2">&nbsp;to instead be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Pt2 {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;Pt2() {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;System.out.println("default constructor");</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;}</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt2(int x, int y) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pt2 with " + x + " and " + y);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">then we find that the program compiles and, if we change </span><span class="c25">Main</span><span class="c2">&nbsp;suitably,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp; public static void main(String[] args) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt3 p3 = new Pt3(1, 2, 3);</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">it runs, but perhaps without the effect we were expecting. The solution, in Java terms, is to explicitly invoke the constructor of the super-class:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Pt3 extends Pt2 {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt3(int x, int y, int z) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pt3 with " + z);</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(x, y);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">but this won’t work either: Java expects the </span><span class="c25">super</span><span class="calibre3">&nbsp;invocation to be the </span><span class="c6">first</span><span class="c2">&nbsp;thing in the sub-class’s constructor.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As the error message above reveals, hidden in the constructor of the extended class is lurking something important: it tries to </span><span class="c6">create an instance</span><span class="calibre3">&nbsp;of the super-class, just as if we had written </span><span class="c25">new Pt2</span><span class="calibre3">. This is entirely masked by the syntactic sugar of </span><span class="c25">super</span><span class="calibre3">. The actual </span><span class="c25">Pt2</span><span class="c2">&nbsp;instance is hidden out of sight, and it takes a little effort to coax it into view.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To see it, let’s first add some instance variables:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Pt2 {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; public int x;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt2(int x, int y) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x = x - 3;</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pt2 with " + x + " and " + y);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">class Pt3 extends Pt2 {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; public int x;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; Pt3(int x, int y, int z) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(x, y);</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x = x + 7;</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Pt3 with " + z);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c2">We’ve purposely made the instance variables have values that look different from those of the parameters, so that when we try to examine them, we can tell them apart. Now let’s modify the constructor to make two objects:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; public static void main(String[] args) {</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pt3 p3345 = new Pt3(3, 4, 5);</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pt3 p3678 = new Pt3(6, 7, 8);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c6">Two</span><span class="calibre3">&nbsp;objects…how many objects did we really make? Well, we made </span><span class="c6">at least</span><span class="c2">&nbsp;two, because adding</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(p3345.x);</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(p3678.x);</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">to the constructor shows that there are two different objects with two different values for </span><span class="c25">x</span><span class="c2">. So far, so unsurprising.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, I’ve claimed that there are two more objects, of type </span><span class="c25">Pt2</span><span class="calibre3">. Can we </span><span class="c6">see</span><span class="calibre3">&nbsp;them? Yes, in fact, we can. The problem is that they’re of type </span><span class="c25">Pt2</span><span class="calibre3">, and what we have are </span><span class="c25">Pt3</span><span class="calibre3">&nbsp;objects. We can’t just make a </span><span class="c25">Pt2</span><span class="calibre3">, because that doesn’t reveal the </span><span class="c6">hidden</span><span class="calibre3">&nbsp;</span><span class="c25">Pt2</span><span class="calibre3">. But in fact the Java type system lets us get to the </span><span class="c25">Pt2</span><span class="calibre3">&nbsp;by </span><span class="c6">casting</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(((Pt2)p3345).x);</span></p><p class="c4"><span class="c34">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(((Pt2)p3678).x);</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">And that’s how we can see that there are actually two </span><span class="c25">Pt2</span><span class="c2">&nbsp;objects lurking as well!</span></p></div>

<div class="c" id="calibre_link-13">
<h2 class="c21" id="calibre_link-176"><span class="c2">Extending Classes</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we have to port all this code over to our world of desugaring. Is this the constructor pattern?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (node/size parent-object v l r)</span></p><p class="c4"><span class="c34">&nbsp; ...)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That suggests that the parent is at the “same level” as the object’s constructor fields. That seems reasonable, in that once all these parameters are given, the object is “fully defined”. However, we also still have</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (node v l r)</span></p><p class="c4"><span class="c34">&nbsp; ...)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The crucial issue here is that we need to make </span><span class="c6">two</span><span class="calibre3">&nbsp;objects: one of </span><span class="c25">node/size</span><span class="calibre3">&nbsp;and one more of </span><span class="c25">node</span><span class="calibre3">. We could imagine a protocol where the user of </span><span class="c25">node/size</span><span class="calibre3">&nbsp;constructs a </span><span class="c25">node</span><span class="calibre3">&nbsp;object and passes it to </span><span class="c25">node/size</span><span class="calibre3">, but in doing so, they could make any number of mistakes. Alternatively, we can leave it to </span><span class="c25">node/size</span><span class="calibre3">&nbsp;to invoke node, and keep track of the object constructed through this process. That is, </span><span class="c25">node/size</span><span class="calibre3">’s parent parameter should not be the parent </span><span class="c6">object</span><span class="calibre3">&nbsp;but rather the parent object’s </span><span class="c6">maker</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (node/size parent-maker v l r)</span></p><p class="c4"><span class="c34">&nbsp; (let ([parent-object (parent-maker v l r)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; [self 'dummy])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! self</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(size) (lambda () (+ 1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg l 'size)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(msg r 'size)))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (parent-object m)])))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; self)))</span></p><p class="c4"><span class="c34">&nbsp;</span></p><p class="c4"><span class="c34">(define (mt/size parent-maker)</span></p><p class="c4"><span class="c34">&nbsp; (let ([parent-object (parent-maker)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; [self 'dummy])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! self</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (m)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (case m</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [(size) (lambda () 0)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [else (parent-object m)])))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; self)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Then the object constructor must remember to pass the parent-object maker on every invocation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define a-tree/size</span></p><p class="c4"><span class="c34">&nbsp; (node/size node</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(node/size node 5 (mt/size mt) (mt/size mt))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(node/size node 15</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node/size node 6 (mt/size mt) (mt/size mt))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mt/size mt))))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Note the repeated pattern of invoking the “super” class: e.g., </span><span class="c25">(mt/size mt)</span><span class="calibre3">. We would instead want to do this just once. Essentially, this binding of </span><span class="c25">mt/size</span><span class="calibre3">&nbsp;to </span><span class="c25">mt</span><span class="calibre3">&nbsp;is precisely what the </span><span class="c25">extends</span><span class="c2">&nbsp;clause of Java does. We could simulate that here, but later in this chapter we’ll see a much more elegant way of achieving this end while also making programming with classes much more flexible.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can confirm that both the old and new tests still work:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (msg a-tree/size 'sum) (+ 10 5 15 6))</span></p><p class="c4"><span class="c34">(test (msg a-tree/size 'size) 4)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Rewrite this block of code using self-application instead of mutation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What we have done is capture the essence of a class. Each function parameterized over a parent is...well, it’s a bit tricky, really. Let’s call it a </span><span class="c6">class extension</span><span class="c2">&mdash;we’ll soon see why. A class extension corresponds to what a Java programmer defines when they write:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class NodeSize extends Node { ... }</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;So why are we going out of the way to not call it a “class”?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">When a developer invokes a Java class’s constructor, it in effect constructs objects all the way up the inheritance chain (in practice, a compiler might optimize this to require only one constructor invocation and one object allocation). These are effectively “personal” copies of the objects corresponding to the parent classes (personal, that is, up to the presence of static members). There is, however, a question of how much of these objects is visible. Java chooses that&mdash;unlike in our implementation above&mdash;only one method of a given name (and signature) remains, no matter how many there might have been on the inheritance chain, whereas every field remains in the result, and can be accessed by casting. The latter makes some sense because each field presumably has invariants governing it, so keeping them separate (and hence all present) is wise. In contrast, it is easy to imagine an implementation that also makes all the methods available, not only the ones lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages take the latter approach.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;The code above is not what we would </span><span class="c6">really</span><span class="calibre3">&nbsp;want as programmers. The self-reference is to the same syntactic object, whereas it needs to refer to the most-refined object: this is known as open recursion. Modify the object representations so that self always refers to the most refined version of the object. </span><span class="c33">Hint:</span><span class="c2">&nbsp;You will find the self-application method (Self-Reference Without Mutation) of recursion handy.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;This demonstrates the other form of extensibility we get from traditional objects: </span><span class="c6">extensible recursion</span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-18">
<h2 class="c21" id="calibre_link-177"><span class="c2">Extending Prototypes</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In our description above, we’ve supplied each class with a description of its parent </span><span class="c6">class</span><span class="calibre3">. Object construction then makes instances of each as it goes up the inheritance chain. There is another way to think of the parent: not as a class to be instantiated but, instead, directly as an object itself. Then all children with the same parent would observe the very same object, which means changes to it from one child object would be visible to another child. The shared parent object is known as a </span><span class="c6">prototype</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;The archetypal prototype-based language is </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=http://selflanguage.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021325680&amp;usg=AOvVaw34T7y09URpNkHh7uTLFlXk">Self</a></span><span class="c2">. Though you may have read that languages like JavaScript are “based on” Self, there is value to studying the idea from its source, especially because Self presents these ideas in their purest form.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Some language designers have argued that prototypes are more primitive than classes in that, with other basic mechanisms such as functions, one can recover classes from prototypes&mdash;but not the other way around. That is essentially what we have done above: each “class” function contains inside it an object description, so a class is an object-returning-function. Had we exposed these as two different operations and chosen to inherit directly an object, we would have something akin to prototypes.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Modify the inheritance pattern above to implement a Self-like, prototype-based language, instead of a class-based language. Because classes provide each object with distinct copies of their parent objects, a prototype-language might provide a “clone” operation to simplify creation of the operation that simulates classes atop prototypes.</span></p></div>

<div class="c" id="calibre_link-323">
<h2 class="c21" id="calibre_link-178"><span class="c2">Multiple Inheritance</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now you might ask, why is there only one fall-through option? It’s easy to generalize this to there being many, which leads naturally to </span><span class="c6">multiple inheritance</span><span class="c2">. In effect, we have multiple objects to which we can chain the lookup, which of course raises the question of what order in which we should do so.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It would be bad enough if the ascendants were arranged in a tree, because even a tree does not have a canonical order of traversal: take just breadth-first and depth-first traversal, for instance (each of which has compelling uses). Worse, suppose a blob A extends B and C; but now suppose B and C each extend D. Now we have to confront this question: will there be one or two D objects in the instance of A? Having only one saves space and might interact better with our expectations, but then, will we visit this object once or twice? Visiting it twice should not make any difference, so it seems unnecessary. But visiting it once means the behavior of one of B or C might change. And so on. As a result, virtually every multiple-inheritance language is accompanied by a subtle algorithm merely to define the lookup order.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This infamous situation is called the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Multiple_inheritance&amp;sa=D&amp;source=editors&amp;ust=1695232021327121&amp;usg=AOvVaw33E5ifiPPmd1ChrRegan9z">“diamond problem”</a></span><span class="c2">&nbsp;(or even, “the Deadly Diamond of Death”!). If you choose to include multiple inheritance in your language you can lose yourself for days in design decisions on this. Because it is highly unlikely you will find a canonical answer, your pain will have only begun. Multiple inheritance is only attractive until you’ve thought it through.</span></p></div>

<div class="c" id="calibre_link-324">
<h2 class="c21" id="calibre_link-179"><span class="c2">Class Extensions: Mixins and Traits</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">When we write </span><span class="c25">class</span><span class="calibre3">&nbsp;in Java, what are we really defining between the opening and closing braces? It is not the entire class: that depends on the parent that it extends, and so on recursively. Rather, what we define inside the braces is a class </span><span class="c6">extension</span><span class="c2">. It only becomes a full-blown class because we also identify the parent class in the same place.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Naturally, we should ask: Why? Why not separate the act of </span><span class="c6">defining</span><span class="calibre3">&nbsp;an extension from </span><span class="c6">applying</span><span class="c2">&nbsp;the extension to a base class? That is, suppose instead of</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class C extends B { ... }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">we instead write:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">classext E { ... }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and separately</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class C = E(B)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c25">B</span><span class="c2">&nbsp;is some already-defined class?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Thus far, it looks like we’ve just gone to great lengths to obtain what we had before. However, the function-application-like syntax is meant to be suggestive: we can “apply” this extension to several different base classes. Thus:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class C1 = E(B1);</span></p><p class="c4"><span class="c34">class C2 = E(B2);</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and so on. What we have done by separating the definition of </span><span class="c25">E</span><span class="calibre3">&nbsp;from that of the class it extends is to liberate class extensions from the tyranny of the fixed base class. We have a name for these extensions: they’re called </span><span class="c6">mixins</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Mixins make class definition more compositional. They provide many of the benefits of multiple-inheritance (reusing multiple fragments of functionality) but within the aegis of a single-inheritance language (i.e., no complicated rules about lookup order). Observe that when desugaring, it’s actually quite easy to add mixins to the language. A mixin is just a “function over classes”. Because we have already determined how to desugar classes, and our target language for desugaring also has functions, and classes desugar to expressions that can be nested inside functions, it becomes almost trivial to implement a simple model of mixins.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;This is a case where the greater generality of the target language of desugaring can lead us to a </span><span class="c6">better</span><span class="c2">&nbsp;construct, if we reflect it back into the source language.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In a typed language, a good design for mixins can actually improve object-oriented programming practice. Suppose we’re defining a mixin-based version of Java. If a mixin is effectively a class-to-class function, what is the “type” of this “function”? Clearly, mixins ought to use </span><span class="c6">interfaces</span><span class="calibre3">&nbsp;to describe what they expect and what they provide. Java already enables (but does not require) the latter, namely classes can say what interfaces they provide. However, it does not enable the former, namely specifying its parent as an </span><span class="c6">interface</span><span class="calibre3">: a class (extension) in Java extends its parent class&mdash;with all the parent’s members visible to the extension&mdash;rather than an interface that </span><span class="c6">stands for</span><span class="calibre3">&nbsp;the parent (or any </span><span class="c6">other</span><span class="c2">&nbsp;class that matches that same interface). That means it obtains all of the parent’s behavior, not a specification thereof. In turn, if the parent changes, the class might break. Mixins help break this asymmetry between extension and provision.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In a mixin language, we can instead write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">mixin M extends I1 implements I2 { ... }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c25">I1</span><span class="calibre3">&nbsp;and </span><span class="c25">I2 </span><span class="calibre3">are interfaces. Then </span><span class="c25">M</span><span class="calibre3">&nbsp;can only be applied to a class that satisfies the interface </span><span class="c25">I1</span><span class="calibre3">, and in turn the language can ensure that only members specified in</span><span class="c25">&nbsp;I1</span><span class="calibre3">&nbsp;are visible in </span><span class="c25">M</span><span class="calibre3">. This becomes directly analogous to how a client of </span><span class="c25">M</span><span class="calibre3">&nbsp;can only see what is provided by </span><span class="c25">I2</span><span class="c2">, and follows one of the important principles of good software design:</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Quote:</span><span class="calibre3">&nbsp;“Program to an interface, not an implementation.” &mdash;</span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Design_Patterns&amp;sa=D&amp;source=editors&amp;ust=1695232021331399&amp;usg=AOvVaw0oLqFKll63oSL1E3kTxWev">Design Patterns</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In short, a mixin is a class that has been turned into a function over parent classes:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">M :: I1 -&gt; I2</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">A good design for mixins can go even further. A class can only be used once in an inheritance chain, by definition (if a class eventually referred back to itself, there would be a cycle in the inheritance chain, causing potential infinite loops). In contrast, when we compose functions, we have no qualms about using the same function twice (e.g.: </span><span class="c25">(map ... (filter ... (map ...))))</span><span class="c2">. Is there value to using a mixin twice?</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;There certainly is! See sections 3 and 4 of </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/&amp;sa=D&amp;source=editors&amp;ust=1695232021332340&amp;usg=AOvVaw2wOohANSHEwTtdW3WtYZHP">Classes and Mixins</a></span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Mixins solve an important problem that arises in the design of libraries. Suppose we have a dozen different features which can be combined in different ways. How many classes should we provide? Furthermore, not all of these can be combined with each other. It is obviously impractical to generate the entire combinatorial explosion of classes. It would be better if the developer could pick and choose the features they care about, with some mechanism to prevent unreasonable combinations. This is precisely the problem that mixins solve: they provide the class extensions, which the developers can combine, in an interface-preserving way, to create just the classes they need.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Mixins are used extensively in the Racket GUI library. For instance, </span><span class="c25">color:text-mixin</span><span class="c2">&nbsp;consumes basic text editor interfaces and implements the colored text editor interface. The latter is itself a basic text editor interface, so additional basic text mixins can be applied to the result.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;How does the analogous library in your favorite object-oriented language solve this same problem?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Mixins do have one limitation: they enforce a linearity of composition. This strictness is sometimes misplaced, because it puts a burden on programmers that may not be necessary. A generalization of mixins called </span><span class="c6">traits</span><span class="c2">&nbsp;says that instead of extending a single mixin, we can extend a set of them. Of course, the moment we extend more than one, we must again contend with potential name-clashes. Thus traits must be equipped with mechanisms for resolving name clashes, often in the form of some name-combination algebra. Traits thus offer a nice complement to mixins, enabling programmers to choose the mechanism that best fits their needs. As a result, Racket provides both mixins and traits.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-325">
<h1 class="c13" id="calibre_link-53"><span class="c2">•••••&nbsp;Types •••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c28">Types that are checked before program execution&mdash;what are known as static types&mdash;are a vital part of programming, and a growing number of languages either have them from the start or, realizing their importance, are adding them in various forms. Types are a common first step towards proving properties about programs. If you use a typed language, you write small proofs about your programs every day, whether you realize it or not.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-326">
<div id="calibre_link-398" class="calibre6"></div><h1 class="c26" id="calibre_link-399"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-180"><span class="c2">Introduction to Types</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We’re done with objects. Why weren’t objects in SMoL?</span></p><ol class="c72" start="1"><li class="pcalibre18 pcalibre19"><span class="c2">Not all languages have them.</span></li><li class="pcalibre18 pcalibre19"><span class="c2">The ones that do have them can’t seem to agree on the details (classes versus prototypes, single- versus multiple-inheritance, classes versus traits and mixins, etc.). There’s very little “standard” there.</span></li><li class="pcalibre18 pcalibre19"><span class="c2">We can add most notions through desugaring!</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we move on to types. We will always use the term </span><span class="c6">type</span><span class="calibre3">&nbsp;to refer to a </span><span class="c6">static</span><span class="c2">&nbsp;check, i.e., one that can be done purely with the program source. This means types cannot refer to dynamic conditions, and may suffer from either false-positive or false-negative errors (e.g., something that is in the code but can never run in practice may still cause a type error); in return, they give us guarantees without ever having to run the program. This is important when the program is expensive to run, impossible (e.g., it depends on conditions that can’t be reproduced by the developer), or dangerous.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Types aren’t really a part of SMoL either, but not because we can add them through desugaring (which we can’t); rather, it’s for the first two reasons: many languages don’t have them, and those that do don’t often agree on their form (in large part because of their disagreement over the nature of objects). However, there are parts they </span><span class="c6">do</span><span class="c2">&nbsp;(largely) agree on, which we will begin with.</span></p></div>

<div class="c" id="calibre_link-327">
<h2 class="c21" id="calibre_link-181"><span class="c2">A Standard Model of Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Types can be thought of as abstractions of run-time values. That is, whereas at run-time we can have a very large number of numbers and strings and images (and two Booleans), we will collapse the distinctions </span><span class="c6">within</span><span class="calibre3">&nbsp;these and preserve only the distinctions </span><span class="c6">between</span><span class="c2">&nbsp;them. Therefore, it is instructive to start with a basic interpreter and try to build a type checker from there:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type BinOp</span></p><p class="c4"><span class="c34">&nbsp; [plus])</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define-type Expr</span></p><p class="c4"><span class="c34">&nbsp; [binE (operator : BinOp)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (left &nbsp;: Exp)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (right : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [numE (value : Number)])</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(calc : (Exp -&gt; Number))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(binE o l r)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case BinOp o</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(plus) (+ (calc l) (calc r))])]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE v) v]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c25">(test (calc (binE (plus) (numE 5) (numE 6))) 11)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s see what needs to happen with a type-checker. The label on the tin says “checker”: that is, the job of a type-checker is to </span><span class="c6">pass judgment</span><span class="c2">&nbsp;on programs, i.e., to determine whether or not they are type-correct. Thus, a natural type (for the type checker) would be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(tc : (Exp -&gt; </span><span class="c53">Boolean</span><span class="c34">))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">(In practice, of course, we would want more information in case the program is not type-correct, i.e., we’d like an error diagnostic. But we’re ignoring human factors considerations here.) With this type, we can now rewrite the relevant parts of the interpreter above:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(define (</span><span class="c53">tc</span><span class="c34">&nbsp;e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(binE o l r)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case BinOp o</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp;[(plus) (</span><span class="c53">and</span><span class="c25">&nbsp;(</span><span class="c53">tc</span><span class="c25">&nbsp;l) (</span><span class="c53">tc</span><span class="c34">&nbsp;r))])]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; [(numE v) </span><span class="c53">#true</span><span class="c34">]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c25">(test (</span><span class="c53">tc</span><span class="c25">&nbsp;(binE (plus) (numE 5) (numE 6))) </span><span class="c53">#true</span><span class="c34">)</span></p><p class="c3"><span class="c60"></span></p><p class="c4"><span class="calibre3">Actually, let’s peer at this for a moment. Given a number, the type-checker returns </span><span class="c25">#true</span><span class="calibre3">. In the recursive cases, it computes the </span><span class="c25">and</span><span class="calibre3">&nbsp;of type-checking the pieces. And that’s it. Since there is no way to return </span><span class="c25">#false</span><span class="calibre3">, the entire type-checker must always only return </span><span class="c25">#true</span><span class="c2">. That is, every program is type-correct.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The problem is because we have only one type, numbers, and only one operation, also on numbers, so what could possibly go wrong? We need to extend the types and operations so that there are meaningful possibilities for errors. Therefore, suppose we add a </span><span class="c25">++</span><span class="c2">&nbsp;operation that concatenates strings.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type BinOp</span></p><p class="c4"><span class="c25">&nbsp; [plus] </span><span class="c53">[++]</span><span class="c34">)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define-type Expr</span></p><p class="c4"><span class="c34">&nbsp; [binE (operator : BinOp)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (left &nbsp;: Exp)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (right : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [numE (value : Number)]</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c53">[strE (value : String)]</span><span class="c34">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Various things break, and need to be fixed. How about this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (tc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(binE o l r)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case BinOp o</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(plus) (and (tc l) (tc r))]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c53">[(++) &nbsp; (and (tc l) (tc r))]</span><span class="c34">)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE v) #true]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; </span><span class="c53">[(strE v) #true]</span><span class="c34">))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c54">(test (tc (binE (++) (strE "hello") (strE "world"))) #true)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So this looks pretty good, right?</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;This is not at all what we want! Write a test case that demonstrates that.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here are two tests that demonstrate </span><span class="c6">desirable</span><span class="c2">&nbsp;behavior:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (tc (binE (++) (numE 5) (numE 6))) #false)</span></p><p class="c4"><span class="c34">(test (tc (binE (plus) (strE "hello") (strE "world"))) #false)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The first string-concatenates two numbers, the second adds two strings. Therefore, both should be rejected by the type-checker. Yet both of them pass (i.e., the tests above fail).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What is the core problem here? It’s that, given an expression, we only know </span><span class="c6">whether</span><span class="calibre3">&nbsp;its sub-expressions typed correctly, but not </span><span class="c6">what</span><span class="calibre3">&nbsp;their types are. &nbsp;That is insufficient to determine whether the current expression is type-correct. For instance, the </span><span class="c25">++</span><span class="c2">&nbsp;operator needs to check not only whether its two sub-expressions are well-typed, but also whether they produced strings; if they did not, then the concatenation is erroneous.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What this shows is that we need the type-checker to have a richer type: it must instead be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(tc : (Exp -&gt; </span><span class="c53">Type</span><span class="c25">))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, the type “checker” must actually be a type </span><span class="c6">calculator</span><span class="calibre3">, i.e., it even more closely parallels the evaluator, just over the universe of abstracted values (types) rather than concrete ones. Following convention, however, we’ll continue to call it a checker, because it </span><span class="c6">also</span><span class="c2">&nbsp;checks in the process of calculating types.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In the type declaration above, </span><span class="c25">Type</span><span class="calibre3">&nbsp;is a new (</span><span class="c25">plait</span><span class="c2">&nbsp;type) definition that records the possible types:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(define-type Type [numT] [strT])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With this, we can rewrite our type-“checker”:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (tc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(binE o l r)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case BinOp o</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(plus) (if (and (numT? (tc l)) (numT? (tc r)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(numT)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'tc "not both numbers"))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(++) &nbsp; (if (and (strT? (tc l)) (strT? (tc r)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(strT)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'tc "not both strings"))])]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numE v) (numT)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(strE v) (strT)]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(test (tc (binE (plus) (numE 5) (numE 6))) (numT))</span></p><p class="c4"><span class="c34">(test (tc (binE (++) (strE "hello") (strE "world"))) (strT))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(test/exn (tc (binE (++) (numE 5) (numE 6))) "strings")</span></p><p class="c4"><span class="c34">(test/exn (tc (binE (plus) (strE "hello") (strE "world"))) "numbers")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There are three take-aways from this:</span></p><p class="c3"><span class="c2"></span></p><ol class="c73" start="1"><li class="pcalibre20 c74"><span class="c2">The type-checker follows the same implementation schema as the interpreter: an algebraic datatype to represent the AST, and structural recursion to process it. This is the schema we’re calling SImPl.</span></li><li class="pcalibre20 c74"><span class="calibre3">A type-checker, unlike an interpreter, operates with “weak” values: note, for instance, how the </span><span class="c25">numE</span><span class="c2">&nbsp;case ignores the actual numeric values. Both the strengths and weaknesses of traditional type-checking arise from this ignorance.</span></li><li class="pcalibre20 c74"><span class="calibre3">In mathematical terms, the upgrade we performed in going from a type-checker to a type-calculator was a process of strengthening the inductive hypothesis: instead of returning only a </span><span class="c25">Boolean</span><span class="calibre3">, we had to return the actual type of each expression. This may not seem like a literal strengthening; but it is inasmuch as the former </span><span class="c25">#true</span><span class="calibre3">&nbsp;has been replaced by a </span><span class="c25">Type</span><span class="calibre3">&nbsp;and the </span><span class="c25">#false</span><span class="c2">&nbsp;by an error.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Add division to the language and type-check it.</span></p></div>

<div class="c" id="calibre_link-328">
<h2 class="c21" id="calibre_link-42"><span class="c2">A Concise Notation</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">As we extend our type system, it is increasingly unwieldy to write everything out as code. Instead, we will adopt a notation commonly used in the world of types (though it can also be used for interpreters and other SImPl programs). We will write terms of the form</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- e : T</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where the </span><span class="c25">e</span><span class="calibre3">&nbsp;are expressions, </span><span class="c25">T</span><span class="calibre3">&nbsp;are types, and </span><span class="c25">:</span><span class="calibre3">&nbsp;is pronounced as “has type”: i.e., the notation above says “</span><span class="c25">e</span><span class="calibre3">&nbsp;has type </span><span class="c25">T</span><span class="calibre3">”. For now we won’t pronounce </span><span class="c25">|-</span><span class="c2">&nbsp;as anything at all; later, we will see that it should be read as “proves”.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First, we can very concisely say that all numeric expressions have numeric type and all string expressions have string type:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- n : Num</span></p><p class="c4"><span class="c34">|- s : Str</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c25">n</span><span class="calibre3">&nbsp;stands for all the syntactic terms with the syntax of numbers, and </span><span class="c25">s</span><span class="c2">&nbsp;likewise for strings. (We can think of this as an infinite number of rules, one for each number and each string. We’re in the realm of mathematics, so what’s an infinite number of rules between friends?) The former is exactly equivalent to writing</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(numC n) (numT)]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">but much more concisely.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">When we get to Booleans, we have a choice: we can either write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">|- b : Bool</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c25">b</span><span class="c2">&nbsp;stands for all the syntactic terms with the syntax of Booleans, or&mdash;because there are only two of them&mdash;just enumerate them explicitly:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- true : Bool</span></p><p class="c4"><span class="c34">|- false : Bool</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, so these correspond to the base cases of the type-checker. These are called </span><span class="c6">axioms</span><span class="calibre3">. Now let’s get to the </span><span class="c6">conditional</span><span class="calibre3">&nbsp;cases, which are called </span><span class="c6">(typing) rules</span><span class="c2">. Remember our code for typing addition:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(plus) (if (and (numT? (tc l)) (numT? (tc r)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(numT)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(error 'tc "not both numbers"))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can write it in this notation very concisely as follows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- e1 : Num &nbsp; &nbsp;|- e2 : Num</span></p><p class="c4"><span class="c34">--------------------------</span></p><p class="c4"><span class="c34">|- (+ e1 e2) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We read the line as “if (what’s above) then (what’s below)”, and the space as “and”. So this says: “if </span><span class="c25">e1</span><span class="calibre3">&nbsp;has type </span><span class="c25">Num</span><span class="calibre3">&nbsp;and </span><span class="c25">e2</span><span class="calibre3">&nbsp;has type </span><span class="c25">Num</span><span class="calibre3">, then </span><span class="c25">(+ e1 e2)</span><span class="calibre3">&nbsp;has type </span><span class="c25">Num</span><span class="c2">”. This is of course the exact same thing the code says, but with rather less noise.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology:</span><span class="calibre3">&nbsp;The part above is called the </span><span class="c6">antecedent</span><span class="calibre3">&nbsp;(that which goes before) and the part below is called the </span><span class="c6">consequent</span><span class="c2">&nbsp;(that which comes after). Don’t call these the numerator and denominator!</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-329">
<h1 class="c26" id="calibre_link-400"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-182"><span class="c2">Growing Types: Division, Conditionals</span></h1><h2 class="c21" id="calibre_link-183"><span class="c2">Handling Division</span></h2><p class="c4"><span class="calibre3">Addition, multiplication, and subtraction are </span><span class="c6">total</span><span class="calibre3">&nbsp;functions over numbers: they consume two numbers and produce one. In contrast, division is a </span><span class="c6">partial</span><span class="c2">&nbsp;function: it isn’t defined when the denominator is zero. Therefore, we need a strategy for handling it. There are several available strategies:</span></p><p class="c3"><span class="c2"></span></p><ol class="c75" start="1"><li class="c76 pcalibre21"><span class="calibre3">We can declare that division doesn’t </span><span class="c6">return</span><span class="calibre3">&nbsp;a number but instead something else that captures its partiality, such as </span><span class="c25">(Optionof Number)</span><span class="c2">. This can work just fine. However, it means every single use of division will need to check whether it obtained a proper number or not. This can get quite onerous.</span></li><li class="c76 pcalibre21"><span class="calibre3">We can declare that division only </span><span class="c6">consumes</span><span class="calibre3">&nbsp;non-zero numbers in its second argument. This is a major change to our type system, because until now we had lumped all numbers together into a single numeric type. This now affects all callers of division, who must now prove that they are not calling it on zero as the second argument. This is onerous in a different way. Observe that the type checker cannot automatically prove that a value is non-zero without error, because this is not decidable (see </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&amp;sa=D&amp;source=editors&amp;ust=1695232021350115&amp;usg=AOvVaw1sfdnpfOgVLtiDbnXxEjlG">Rice’s Theorem</a></span><span class="c2">).</span></li><li class="c76 pcalibre21"><span class="c2">We give it the same type as other binary numeric operations, and declare that the exceptional case will be handled by an exception or error. This implicitly puts the burden on the rest of the program, which must be aware of this possibility and handle it.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">For more about general strategies for handling partial functions, see</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&amp;sa=D&amp;source=editors&amp;ust=1695232021350790&amp;usg=AOvVaw1xa-O5dafyrpg45paMpzmj">https://dcic-world.org/2022-08-28/partial-domains.html</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Most programming languages have taken the third option above, which seems the most pragmatic. However, a growing number of languages are exploring the first two options. They get around Rice’s Theorem in the second case by trying to prove non-zero-ness and, when they cannot, putting the burden on the programmer. While this creates more effort for the programmer, it increases the program’s robustness.</span></p></div>

<div class="c" id="calibre_link-330">
<h2 class="c21" id="calibre_link-184"><span class="c2">Another Perspective on Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We have already seen how we can think of types as abstractions of values, and type-checking as running a program over these abstract values. As we’ll soon see, the analogy will break down a bit.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Another perspective is to think of types as a </span><span class="c6">static discipline</span><span class="calibre3">: a way of statically making judgments about programs. In a way, we have already been doing just this: it’s called </span><span class="c6">parsing</span><span class="c2">. A parser statically (i.e., before the program runs) passes judgment (i.e., decides that some programs are good and others are bad). Types can be viewed as an extension of this idea.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;In computability theory terms, parsers are usually </span><span class="c6">context-free</span><span class="calibre3">, whereas types usually reflect </span><span class="c6">context-sensitive</span><span class="calibre3">&nbsp;constraints. Computability theory then helps us understand why we might separate these checks into two separate phases, and in particular why we might do one before the other. Essentially, the type-checker only needs to deal with programs that have already passed the parsing, i.e., context-free check, so it has much less complexity than if it had to do everything. We already saw this: our previous checker only consumed </span><span class="c25">Expr</span><span class="c2">s, which are produced by the parser.</span></p></div>

<div class="c" id="calibre_link-41">
<h2 class="c21" id="calibre_link-185"><span class="c2">From Axioms and Rules to Judgments</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">When we need to apply type rules to a program, we compose them recursively, just as the type-checker runs. Consider this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 5 (+ 6 7))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">To decide its type, we will use our current rules [</span><span class="c15"><a class="c10" href="#calibre_link-42">👉</a></span><span class="calibre3">]. Observe that it does not fit any axiom, because the program does not match the syntax of a single number or string. Therefore, we have to use a conditional rule. We have seen only one so far, and fortunately this term does match the consequent: it requires two terms, and we have two terms, so </span><span class="c25">e1</span><span class="calibre3">&nbsp;is </span><span class="c25">5</span><span class="calibre3">&nbsp;and </span><span class="c25">e2</span><span class="calibre3">&nbsp;is </span><span class="c25">(+ 6 7)</span><span class="c2">. Therefore, applying this conditional rule, we get:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- 5 : Num &nbsp; &nbsp;|- (+ 6 7) : Num</span></p><p class="c4"><span class="c34">----------------------</span></p><p class="c4"><span class="c34">|- (+ 5 (+ 6 7)) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So far, so good. Now let’s look at the two terms in the antecedent. The first one now actually matches to an axiom; therefore, we’ll mark that in green and can stop with that:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- 5 : Num</span><span class="c34">&nbsp; &nbsp; |- (+ 6 7) : Num</span></p><p class="c4"><span class="c34">----------------------</span></p><p class="c4"><span class="c34">|- (+ 5 (+ 6 7)) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp;For the other, we have to apply the same conditional rule again:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |- 6 : Num &nbsp; &nbsp;|- 7 : Num</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ------------------------</span></p><p class="c4"><span class="c77">|- 5 : Num</span><span class="c34">&nbsp; &nbsp; |- (+ 6 7) : Num</span></p><p class="c4"><span class="c34">----------------------</span></p><p class="c4"><span class="c34">|- (+ 5 (+ 6 7)) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These new terms also match the axiom for numbers, so we can mark them also in green:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c77">|- 6 : Num</span><span class="c25">&nbsp; &nbsp; </span><span class="c78">|- 7 : Num</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ------------------------</span></p><p class="c4"><span class="c77">|- 5 : Num</span><span class="c34">&nbsp; &nbsp; |- (+ 6 7) : Num</span></p><p class="c4"><span class="c34">----------------------</span></p><p class="c4"><span class="c34">|- (+ 5 (+ 6 7)) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Every part of the tree now terminates in an axiom. We therefore consider this program to have successfully type-checked. This tree is called a </span><span class="c6">judgment</span><span class="calibre3">, because it passes judgment on the initial term: in this case, judging it to have type-checked and to produce a value of type </span><span class="c25">Num</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Observe closely that this is the same pattern of execution we had with the type-checker! The difference is that we were able to skip the tedious details of passing and returning things, and instead simply used pattern-matching. This will save us a fair bit of work as we go forward.</span></p></div>

<div class="c" id="calibre_link-47">
<h2 class="c21" id="calibre_link-186"><span class="c2">Judgments and Errors</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s see another example, which will illustrate an important principle:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 5 (+ 6 "hi"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This proceeds analogously to the previous example. This leaves us with the following attempted judgment:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c77">|- 6 : Num</span><span class="c34">&nbsp; &nbsp; |- "hi" : Num</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------------------------</span></p><p class="c4"><span class="c77">|- 5 : Num</span><span class="c34">&nbsp; &nbsp; |- (+ 6 "hi") : Num</span></p><p class="c4"><span class="c34">-------------------------</span></p><p class="c4"><span class="c34">|- (+ 5 (+ 6 "hi")) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But now we have a problem: we need to type-check</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">|- "hi" : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">but </span><span class="c6">we don’t have a rule that matches</span><span class="calibre3">. Therefore, we </span><span class="c6">cannot</span><span class="c2">&nbsp;construct a successful tree:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c77">|- 6 : Num</span><span class="c25">&nbsp; &nbsp; </span><span class="c79">|- "hi" : Num</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ---------------------------</span></p><p class="c4"><span class="c77">|- 5 : Num</span><span class="c34">&nbsp; &nbsp; |- (+ 6 "hi") : </span></p><p class="c4"><span class="c34">-------------------------</span></p><p class="c4"><span class="c25">|- (+ 5 (+ 6 "hi")) : </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Remember the “if … and …&nbsp;then” interpretation. Because we cannot satisfy all the antecedents, we cannot prove anything about the consequents, leaving the tree incomplete.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">A type error is simply a failure to construct a judgment.</span><span class="c2">&nbsp;It may not be the most satisfying user feedback, but our concern here is with a concise way of expressing ideas; going from this to an implementation is not too hard, and the user interface details can be added to the latter.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This requires some clarification. We only call it a judgment if the tree is “checked off” completely: i.e., every antecedent is generated using given rules, and all the leaves are actual axioms. In this example, we are unable to check off the tree: there is no available rule </span><span class="c6">or</span><span class="calibre3">&nbsp;axiom that lets us conclude that </span><span class="c25">"hi"</span><span class="calibre3">&nbsp;is a </span><span class="c25">Num</span><span class="calibre3">. Therefore, we cannot “judge” the initial expression. This is a technical meaning of the word </span><span class="c6">judgment</span><span class="c2">, not to be confused with potentially colloquial interpretations of the term.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Similarly, imagine that we started with this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 5 (- 6 7))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We would get this far:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- 5 : Num</span><span class="c25">&nbsp; &nbsp; </span><span class="c79">|- (- 6 7) : Num</span></p><p class="c4"><span class="c34">----------------------</span></p><p class="c4"><span class="c34">|- (+ 5 (- 6 7)) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Again we would fail, this time because we haven’t provided a (conditional) rule for </span><span class="c25">(- e1 e2)</span><span class="c2">. Obviously it’s not difficult to define one; we just haven’t done so yet, so our pattern-matcher would fail.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Construct the conditional rule for </span><span class="c25">++</span><span class="c2">&nbsp;(string concatenation). Compare it to the code in the type-checker.</span></p></div>

<div class="c" id="calibre_link-51">
<h2 class="c21" id="calibre_link-187"><span class="c2">Typing Conditionals</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we’re ready to add a rule for </span><span class="c25">if</span><span class="c2">. As we have seen, different languages have different rules for what can go in the conditional clause. Since the goal of a type-checker is to catch type errors, it is common for languages with type-checkers to demand that the conditional be a Boolean (without a truthy/falsy set of Boolean values). Our goal here is not to make a value judgment but rather to illustrate how we would add a type rule for it.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">By now, we can see that we will need a conditional rule (because we want to type-check more than just constants); following SImPl, and we will need the antecedent to say something about the sub-expressions. Clearly, we need at least:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- C : Bool &nbsp; &nbsp;…</span></p><p class="c4"><span class="c34">------------------</span></p><p class="c4"><span class="c34">|- (if C T E) : …</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, what now? What is the type of the entire conditional expression? Technically, it should be whatever type is returned by the branch that was executed. However, a type-checker can’t know which branch will be executed; over time, both might. So we have to somehow capture the </span><span class="c6">uncertainty</span><span class="c2">&nbsp;in this situation. There are two common solutions:</span></p><p class="c3"><span class="c2"></span></p><ol class="c80" start="1"><li class="c81 pcalibre22"><span class="calibre3">Introduce a new kind of type that stands for “this type </span><span class="c6">or</span><span class="calibre3">&nbsp;that type” (a </span><span class="c6">union</span><span class="c2">). This is easy to introduce but creates a burden for every piece of code that will consume such a value.</span></li><li class="c81 pcalibre22"><span class="c2">Just rule that both branches should have the same type.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The latter is a very elegant solution, because it eliminates the uncertainty entirely.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Okay, so we need to do the following things:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">Compute the type of T.</span></li><li class="pcalibre c23"><span class="c2">Compute the type of E.</span></li><li class="pcalibre c23"><span class="c2">Make sure T and E have the same type.</span></li><li class="pcalibre c23"><span class="c2">Make this (same) type the result of the conditional.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That seems like a lot: how will we express all that? Very easily, actually:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- C : Bool &nbsp; &nbsp;|- T : U &nbsp; &nbsp;|- E : U</span></p><p class="c4"><span class="c34">-----------------------------------</span></p><p class="c4"><span class="c34">|- (if C T E) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here, </span><span class="c25">U</span><span class="calibre3">&nbsp;is a placeholder: it isn’t a concrete type but rather </span><span class="c6">stands for</span><span class="calibre3">&nbsp;whatever type might go in that place. The repeated use of </span><span class="c25">U</span><span class="calibre3">&nbsp;accomplishes all of our goals above. Read this as: “if </span><span class="c25">C </span><span class="calibre3">has type </span><span class="c25">Bool</span><span class="calibre3">&nbsp;and </span><span class="c25">T</span><span class="calibre3">&nbsp;has type </span><span class="c25">U</span><span class="calibre3">&nbsp;and </span><span class="c25">E</span><span class="calibre3">&nbsp;has [</span><span class="c6">the </span><span class="c82">same</span><span class="calibre3">] type </span><span class="c25">U</span><span class="calibre3">, then </span><span class="c25">(if C T E)</span><span class="calibre3">&nbsp;has [the same] type </span><span class="c25">U</span><span class="c2">”.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s see this in action on the following program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(if true 1 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We get:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- true : Bool</span><span class="c34">&nbsp; &nbsp; |- 1 : U &nbsp; &nbsp;|- 2 : U</span></p><p class="c4"><span class="c34">--------------------------------------</span></p><p class="c4"><span class="c25">|- (if true 1 2) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Either of the axioms for the other two antecedents tells us what U must be, which lets us fill in the result of U everywhere:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- true : Bool</span><span class="c34">&nbsp; &nbsp; |- 1 : Num &nbsp; &nbsp;|- 2 : Num</span></p><p class="c4"><span class="c34">------------------------------------------</span></p><p class="c4"><span class="c25">|- (if true 1 2) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Fortunately, the other two antecedents are also axioms:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- true : Bool</span><span class="c25">&nbsp; &nbsp; </span><span class="c77">|- 1 : Num</span><span class="c25">&nbsp; &nbsp; </span><span class="c78">|- 2 : Num</span></p><p class="c4"><span class="c34">------------------------------------------</span></p><p class="c4"><span class="c25">|- (if true 1 2) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This lets us conclude that the overall term is well-typed, and that it has type </span><span class="c25">Num</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s look at:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(if 4 1 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Applying the conditional rule gives us:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- 4 : Bool &nbsp; &nbsp;|- 1 : U &nbsp; &nbsp;|- 2 : U</span></p><p class="c4"><span class="c34">-----------------------------------</span></p><p class="c4"><span class="c34">|- (if 4 1 2) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, we do not have any axiom or conditional rule that lets us conclude that </span><span class="c25">4</span><span class="calibre3">&nbsp;has type </span><span class="c25">Bool</span><span class="c2">&nbsp;(because, in fact, it does not). Therefore, we cannot complete the judgment:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c83">|- 4 : Bool</span><span class="c34">&nbsp; &nbsp; |- 1 : U &nbsp; &nbsp;|- 2 : U</span></p><p class="c4"><span class="c34">-----------------------------------</span></p><p class="c4"><span class="c25">|- (if 4 1 2) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and the program is (rightly) judged to have a type error.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">One last example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(if true 1 "hi")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Again, applying the conditional rule and checking off the first antecedent:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- true : Bool</span><span class="c34">&nbsp; &nbsp; |- 1 : U &nbsp; &nbsp;|- "hi" : U</span></p><p class="c4"><span class="c34">-----------------------------------------</span></p><p class="c4"><span class="c25">|- (if true 1 "hi") : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But now we have a problem. If we apply the axiom for numbers, we replace all instances of </span><span class="c25">U</span><span class="calibre3">&nbsp;with </span><span class="c25">Num</span><span class="c2">&nbsp;to get:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- true : Bool</span><span class="c25">&nbsp; &nbsp; </span><span class="c77">|- 1 : Num</span><span class="c25">&nbsp; &nbsp; </span><span class="c79">|- "hi" : Num</span></p><p class="c4"><span class="c34">---------------------------------------------</span></p><p class="c4"><span class="c25">|- (if true 1 "hi") : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Maybe we just tried the wrong axiom? We do have one more option! However, it ends up with the same net effect:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c77">|- true : Bool</span><span class="c25">&nbsp; &nbsp; </span><span class="c83">|- 1 : Str</span><span class="c25">&nbsp; &nbsp; </span><span class="c78">|- "hi" : Str</span></p><p class="c4"><span class="c34">---------------------------------------------</span></p><p class="c4"><span class="c25">|- (if true 1 "hi") : Str</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Because there is </span><span class="c6">no</span><span class="c2">&nbsp;way to construct a judgment for this program, it too has a type error.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Let’s now add functions. We need two new constructs: one to introduce them (</span><span class="c25">lambda</span><span class="calibre3">) and one to use them (function application). Write down judgments for each. </span><span class="c33">Hint:</span><span class="c2">&nbsp;You may need to revisit the set of types, too.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that because </span><span class="c25">let</span><span class="calibre3">&nbsp;desugars into </span><span class="c25">lambda</span><span class="calibre3">, once we have this, in principle we also have a conditional rule for </span><span class="c25">let</span><span class="calibre3">. (For more sophisticated language constructs this is not so straightforward; </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pk-resuarging-types/&amp;sa=D&amp;source=editors&amp;ust=1695232021368048&amp;usg=AOvVaw3PHiJldDLQfYPUNuwxOBi_">this paper</a></span><span class="c2">&nbsp;works out&nbsp;some of the details.)</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Add desugaring to the type-checker.</span></p></div>

<div class="c" id="calibre_link-16">
<h2 class="c21" id="calibre_link-188"><span class="c2">Where Types Diverge from Evaluation</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Something very important, and subtle, happened above. Compare the </span><span class="c6">type rule</span><span class="calibre3">&nbsp;for a conditional with the </span><span class="c6">evaluation</span><span class="calibre3">&nbsp;process [</span><span class="c15"><a class="c10" href="#calibre_link-17">👉</a></span><span class="calibre3">]. If the rule is too abstract, just look at the example judgments (or failed judgments) above. The evaluator evaluates only </span><span class="c6">one</span><span class="calibre3">&nbsp;branch out of </span><span class="c25">T</span><span class="calibre3">&nbsp;and </span><span class="c25">E</span><span class="calibre3">; indeed, that is the </span><span class="c6">entire point</span><span class="calibre3">&nbsp;of a conditional. The type-checker, in contrast, traverses </span><span class="c6">both</span><span class="calibre3">&nbsp;branches! In other words, it looks at code that </span><span class="c6">might</span><span class="calibre3">&nbsp;evaluate, not only code that absolutely </span><span class="c6">does</span><span class="c2">&nbsp;evaluate.<br class="calibre" /></span></p><p class="c4"><span class="calibre3">In other words, the idea that a type-checker is like an “evaluator that runs over simple values” is a convenient starting analogy, but it is in fact false. An evaluator and type-checker follow different traversal strategies. That is why a program like </span><span class="c25">(if true 1 "hi")</span><span class="c2">&nbsp;might run without any difficulty but is rejected by a type-checker. While this particular example may make the type-checker look overly pedantic, what if the same program were</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(if (is-full-moon) 1 "hi")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What now? Should the type-checker pass the program every month? Should it consider the moon’s phase at the time of type-checking or at execution? Unfortunately, the type-checker doesn’t know when the program will run; indeed, the program is type-checked once but may run an arbitrary number of times. Therefore, a type-checker must necessarily be </span><span class="c6">conservative</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This also lets us relate type-checking to </span><span class="c33">testing</span><span class="calibre3">. In software testing, making sure that all branches are visited is called </span><span class="c6">branch coverage</span><span class="calibre3">, and making sure all branches have coverage is both important and very difficult (because each branch may have additional branches which in turn may have even more branches which…). In contrast, a type-checker effortlessly covers both branches. The trade-off is that it does so only at the </span><span class="c6">type</span><span class="c2">&nbsp;level (and indeed, the abstraction of values to types is precisely what enables it to do this).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Thus, testing and type-checking are complementary. Type-checking provides code coverage at a lightweight level; testing typically provides only partial coverage but at the deep level of specific values. In recent years, people have invented a notion of </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Concolic_testing&amp;sa=D&amp;source=editors&amp;ust=1695232021370424&amp;usg=AOvVaw1QJrbACLLfoZOf01gPppBi">concolic</a></span><span class="c2">&mdash;i.e., “concrete” + “symbolic”&mdash;testing to try to create the best of both worlds.</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-298">
<h1 class="c26" id="calibre_link-401"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-66"><span class="c2">Growing Types: Typing Functions</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we’re ready to grow our language further, to include functions. As we’ve noted before, concepts like functions come in pairs: a way to introduce them and a way to use (“eliminate”) them. As in our interpreter, we’ll use a </span><span class="c25">lambda</span><span class="calibre3">&nbsp;form to represent the former and application for the latter. We’ve already seen that once we have </span><span class="c25">lambda</span><span class="calibre3">, we use syntactic sugar to obtain other forms like </span><span class="c25">let</span><span class="c2">, so this suffices for our core language. (Mostly, as we’ll see…)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So we have to come up with typing rules for application and </span><span class="c25">lambda</span><span class="c2">. Let’s do them in that order.</span></p></div>

<div class="c" id="calibre_link-299">
<h2 class="c21" id="calibre_link-189"><span class="c2">Typing Function Applications</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A function application expression has two parts: the function and the arguments. For simplicity, we’re going to assume that we’re working with single-argument functions.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Extend the rules below to deal with functions of arbitrary number of parameters (formally called </span><span class="c6">arity</span><span class="c2">).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Because functions are first-class values, the function position is itself an expression. We have to check each sub-expression before we can type the whole expression. Therefore, function applications are conditional rules with two terms in the antecedent:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- F : ??? &nbsp; &nbsp;|- A : ???</span></p><p class="c4"><span class="c34">------------------------</span></p><p class="c4"><span class="c34">|- (F A) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">First, let’s notice that functions are different kinds of values than other values: a function is not itself a number, or string, or Boolean&mdash;it may </span><span class="c6">produce</span><span class="calibre3">&nbsp;one of those, but it is not </span><span class="c6">itself</span><span class="calibre3">&nbsp;one of those (an important distinction). Therefore, we need a different type for functions, which reflects what functions consume and what they produce. A natural idea is to assume functions have some “function” type, here called </span><span class="c25">Fun</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- F : Fun &nbsp; &nbsp;|- A : ???</span></p><p class="c4"><span class="c34">------------------------</span></p><p class="c4"><span class="c34">|- (F A) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What do we know about the argument expression (the actual parameter)? It had better match the type demanded by the formal parameter. But how do we check that here? We’ve collapsed </span><span class="c6">all</span><span class="calibre3">&nbsp;functions in the world into a single type, </span><span class="c25">Fun</span><span class="c2">. That’s far too coarse.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Instead, following convention, we’ll use the “arrow” syntax for functions:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- F : (??? -&gt; ???) &nbsp; &nbsp;|- A : ???</span></p><p class="c4"><span class="c34">---------------------------------</span></p><p class="c4"><span class="c25">|- (F A) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(Technically, the arrow is a </span><span class="c6">constructor</span><span class="c2">&nbsp;of function types. It’s a two-place constructor, for reasons we will see below.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">With this, we can now say that the function’s formal parameter’s type had better match up with the type of the actual argument. Which type, exactly? Functions could consume numbers, strings, even other functions…all we know is that these should be </span><span class="c6">consistent</span><span class="c2">. Notice that this is very similar to the consistency we expected of the branches of a conditional. We can again encode this by using the same placeholder in both places:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- F : (T -&gt; ???) &nbsp; &nbsp;|- A : T</span></p><p class="c4"><span class="c34">-----------------------------</span></p><p class="c4"><span class="c25">|- (F A) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now, what about what the function returns? Again, it could return values of any type. Whatever that type is, that is what the entire application produces. Again, we use a common placeholder to reflect this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- F : (T -&gt; U) &nbsp; &nbsp;|- A : T</span></p><p class="c4"><span class="c34">---------------------------</span></p><p class="c4"><span class="c25">|- (F A) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So here’s how we read this:</span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">Type-check the </span><span class="c25">F</span><span class="calibre3">&nbsp;position. Make sure it’s a function type (</span><span class="c25">-&gt;</span><span class="calibre3">). Assuming it is, call the formal parameter’s type </span><span class="c25">T</span><span class="calibre3">&nbsp;and the return type </span><span class="c25">U</span><span class="c2">.</span></li><li class="pcalibre c23"><span class="c2">Type-check the actual parameter (the argument). Make sure it has the same type as what the function is expecting in its formal parameter.</span></li><li class="pcalibre c23"><span class="c2">If both of those hold, then the function’s return type is the type of the entire application.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This list of steps is what a conventional type-checker would implement. Observe that again, a type error is the result of a failure to construct a judgment. If, for instance, the actual argument’s type doesn’t match that of the formal parameter, then </span><span class="c6">the conditional rule above doesn’t apply</span><span class="calibre3">&nbsp;(it applies only when we can write the same type for the </span><span class="c25">T</span><span class="c2">&nbsp;placeholder), which is how we learn that the program has a type error.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Construct an example to illustrate the above type-error case.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;We intentionally don’t use a </span><span class="c6">numbered</span><span class="calibre3">&nbsp;list because formally, the semantics of judgments doesn’t say that these steps have to occur in this order! For instance, the argument can be type-checked before the function; if so, that determines what the placeholder </span><span class="c25">T</span><span class="calibre3">&nbsp;stands for, and the checking of </span><span class="c25">F</span><span class="calibre3">&nbsp;confirms that </span><span class="c25">F</span><span class="c2">’s type matches that.</span></p><p class="c27"><span class="calibre3">Even more perversely, you can imagine checking the application, determining&mdash;from the context&mdash;what its type </span><span class="c6">needs</span><span class="calibre3">&nbsp;to be (e.g., if it’s in an addition, it had better produce a number), and using that to drive the checking of </span><span class="c25">F</span><span class="calibre3">. In fact, all of these things can happen if instead of a </span><span class="c6">checker</span><span class="calibre3">, we implement type-</span><span class="c6">inference</span><span class="c2">&mdash;as we will soon see.</span></p></div>

<div class="c" id="calibre_link-300">
<h2 class="c21" id="calibre_link-190"><span class="c2">Typing Function Definitions</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we’re ready to type </span><span class="c25">lambda</span><span class="calibre3">. Here, we have to be careful about how many sub-expressions there are. Given </span><span class="c25">(lambda V B)</span><span class="calibre3">, it is tempting to think that there are two: </span><span class="c25">V</span><span class="calibre3">&nbsp;(the formal parameter) and </span><span class="c25">B</span><span class="calibre3">&nbsp;(the body). This is wrong! The formal parameter is a literal name, </span><span class="c6">not</span><span class="calibre3">&nbsp;an expression: we can’t replace that name with some larger expression, which is what it would mean for it to be an expression. Furthermore, we can’t evaluate it: it would (most likely) produce an unbound variable error, because its whole job is to </span><span class="c6">bind</span><span class="calibre3">&nbsp;that variable, so it can’t assume it has already been bound. Therefore, there is only </span><span class="c6">one</span><span class="c2">&nbsp;sub-expression, the body.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Therefore, we expect to end up with a conditional rule that looks like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- B : ???</span></p><p class="c4"><span class="c34">---------------------</span></p><p class="c4"><span class="c25">|- (lambda V B) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If we think about this for a moment, we can see that there’s going to be a problem. &nbsp;We just said that the </span><span class="c25">lambda</span><span class="calibre3">&nbsp;introduces a binding for the variable in the </span><span class="c25">V</span><span class="calibre3">&nbsp;position. This is precisely so that the body, </span><span class="c25">B</span><span class="c2">, can make use of that variable. So let’s imagine the simplest function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">|- x : ???</span></p><p class="c4"><span class="c34">---------------------</span></p><p class="c4"><span class="c25">|- (lambda x x) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But we don’t have any typing rule that covers variables! Furthermore, we have no way of knowing what the type of any old variable will be. So we have a problem.</span></p></div>

<div class="c" id="calibre_link-14">
<h2 class="c21" id="calibre_link-191"><span class="c2">Typing Variables</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Remember how we addressed this problem in our interpreter: we had an </span><span class="c6">environment</span><span class="calibre3">&nbsp;for recording the value bound to each variable. We will use this same idea again: we’ll have a </span><span class="c6">type environment</span><span class="calibre3">&nbsp;for recording the </span><span class="c6">type</span><span class="c2">&nbsp;of each variable. That is, just as our interpreter had the type</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(interp : (Exp Env -&gt; Value))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">our type-checker will have the type</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(tc : (Exp TEnv -&gt; Type))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In our type-checker notation, we will use a slightly different way of writing it, which will finally make make </span><span class="c25">|-</span><span class="c2">&nbsp;stop being silent and take it proper pronounciation, “proves”: all type rules will have the form</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c34">|- e : T</span></p><p class="c3"><span class="c85"></span></p><p class="c4"><span class="calibre3">where </span><span class="c84">Γ</span><span class="calibre3">, the capital Greek letter gamma, is conventionally used for the environment. We read this as “the environment </span><span class="c84">Γ</span><span class="calibre3">&nbsp;proves that </span><span class="c25">e</span><span class="calibre3">&nbsp;has type </span><span class="c25">T</span><span class="c2">”. So in fact there’s been an environment hiding in all our judgments, but we didn’t have to worry about it when we didn’t have variables; but now we do, so from now on we have to make it explicit. Fortunately, in most cases the environment is unchanged, and just passes recursively to the sub-terms, as you would expect from writing the interpreter.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">With this, we can write a type for variables. What is the type of a variable? It’s whatever the environment says it is! We’ll treat the environment as a function, so we can just write the following axiom (where </span><span class="c25">v</span><span class="c2">&nbsp;stands for all the syntactically valid variable names):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- v : </span><span class="c84">Γ</span><span class="c25">(v)</span></p></div>

<div class="c" id="calibre_link-286">
<h2 class="c21" id="calibre_link-192"><span class="c2">Back to Typing Function Definitions</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we’re in a position to fill in the holes. When we check the body of the function, we should do it in an </span><span class="c6">extended</span><span class="c2">&nbsp;environment:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ</span><span class="c86">[V &lt;- ???]</span><span class="c84">&nbsp;</span><span class="c34">|- B : ???</span></p><p class="c4"><span class="c34">-----------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (lambda V B) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c84">Γ[V &lt;- _] </span><span class="calibre3">is how we write “</span><span class="c84">Γ</span><span class="calibre3">&nbsp;is extended with </span><span class="c25">V</span><span class="c2">&nbsp;bound to _”: this is the same environment-extension function that we’ve written before, for type environments instead of value environments, but operationally the same.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, but two questions: extend </span><span class="c6">which</span><span class="calibre3">&nbsp;environment, and extend it with </span><span class="c6">what</span><span class="c2">?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Which is easy: it’s the environment of the function definition (static scope!). The repetition of </span><span class="c84">Γ</span><span class="c2">&nbsp;in both the consequent and antecedent accomplishes that.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In terms of what: &nbsp;We need to provide a type for the variable so that, when we try to look up its type, the environment can return something. But we don’t know what to extend it with! The type-checker needs the </span><span class="c6">programmer to tell it</span><span class="c2">&nbsp;what type the function is expecting. This is one of the reasons why programming languages expect annotations in function and method definitions. (Another&mdash;equally good&mdash;reason is because it better documents the function for people who have to use it and maintain it.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Therefore, we have to extend the syntax of functions to include a type annotation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(lambda V : T B)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">which says that </span><span class="c25">V</span><span class="calibre3">&nbsp;is expecting to be bound to a value of type </span><span class="c25">T</span><span class="calibre3">&nbsp;in body </span><span class="c25">B</span><span class="c2">. Once we accept this modification, we can make progress on the conditional rule:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ[V &lt;- </span><span class="c86">T</span><span class="c84">] </span><span class="c34">|- B : ???</span></p><p class="c4"><span class="c34">---------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (lambda V : </span><span class="c53">T</span><span class="c25">&nbsp;B) : ???</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What type are we expecting for the function definition? Clearly it must be a function type:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ[V &lt;- T] </span><span class="c34">|- B : ???</span></p><p class="c4"><span class="c34">------------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (lambda V : T B) : </span><span class="c53">(??? -&gt; ???)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Furthermore, we know that the type expected by the function must be </span><span class="c25">T</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ[V &lt;- T] </span><span class="c34">|- B : ???</span></p><p class="c4"><span class="c34">----------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (lambda V : T B) : (</span><span class="c53">T</span><span class="c25">&nbsp;-&gt; ???)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Given a value of type </span><span class="c25">T</span><span class="c2">, the function will return whatever the body produces:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ[V &lt;- T] </span><span class="c25">|- B : </span><span class="c54">U</span></p><p class="c4"><span class="c34">--------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (lambda V : T B) : (T -&gt; </span><span class="c53">U</span><span class="c25">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">And that gives us our final rule for function definitions.</span></p></div>

<div class="c" id="calibre_link-311">
<h2 class="c21" id="calibre_link-193"><span class="c2">More Divergence Between Types and Evaluation</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It is interesting to contrast the above pair of typing rules with the corresponding evaluation rules. In the evaluator, we visit the body of the function on every </span><span class="c6">application</span><span class="calibre3">&mdash;which could be as many as an infinite number of times in a program. In contrast, we visit the body of the function on </span><span class="c6">definition</span><span class="c2">, which happens only once. Therefore, even if the program runs forever, the type-checker is guaranteed to terminate!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Why can we get away with this? The evaluator has to run the body with the </span><span class="c6">specific</span><span class="c2">&nbsp;value it was given. The type-checker, however, has abstracted the concrete values away. Therefore, it only needs to make one pass through the body with the “abstract value”, the type.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">Earlier, when we proposed the type </span><span class="c25">Fun</span><span class="calibre3">, we said that it collapsed all functions in the world into one type. This was too coarse, and we had to refine the type of a function. However, we are </span><span class="c6">still</span><span class="calibre3">&nbsp;collapsing an infinite number of functions into each of those function types&mdash;just as we collapse an infinite number of strings into </span><span class="c25">Str</span><span class="c2">, and so on. Both the strength and weakness of type-checking lies in this collapsing.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">For the same reason, observe that a function application rule only cares about the </span><span class="c6">type</span><span class="calibre3">&nbsp;of the function, not </span><span class="c6">which</span><span class="calibre3">&nbsp;specific function is being applied. Therefore, any function that has that type can be used. For that same reason, the type-checker </span><span class="c6">cannot</span><span class="c2">&nbsp;traverse the function’s body at application time&mdash;it doesn’t even know which function might be used! All communication between the function body and application must happen entirely through the type boundary.</span></p></div>

<div class="c" id="calibre_link-301">
<h2 class="c21" id="calibre_link-194"><span class="c2">Assume-Guarantee Reasoning</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There is a delicate dance going on between these typing rules for application and definition (now updated to have the environment). We’ll use colors to highlight this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- F : </span><span class="c87">(T -&gt; U)</span><span class="c25">&nbsp; &nbsp; Γ |- A : </span><span class="c88">T</span></p><p class="c4"><span class="c34">-------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (F A) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ[V &lt;- </span><span class="c89">T</span><span class="c84">] </span><span class="c34">|- B : U</span></p><p class="c4"><span class="c34">--------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (lambda V : T B) : </span><span class="c87">(T -&gt; U)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The rule for </span><span class="c25">lambda</span><span class="calibre3">&nbsp;</span><span class="c6">assumes</span><span class="calibre3">&nbsp;the parameter will be given a value of type </span><span class="c90">T</span><span class="calibre3">; the application rule </span><span class="c6">guarantees</span><span class="calibre3">&nbsp;that that the actual parameter will indeed have the expected type. The application rule </span><span class="c6">assumes</span><span class="calibre3">&nbsp;that the function, if given a </span><span class="c25">T</span><span class="calibre3">, will produce a </span><span class="c25">U</span><span class="calibre3">&nbsp;(because the type is </span><span class="c87">(T -&gt; U)</span><span class="calibre3">); the </span><span class="c25">lambda</span><span class="calibre3">&nbsp;rule </span><span class="c6">guarantees</span><span class="c2">&nbsp;that the function will indeed perform that way.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;The notation </span><span class="c25">(T -&gt; U)</span><span class="calibre3">&nbsp;is not chosen at random. The </span><span class="c25">-&gt;</span><span class="calibre3">&nbsp;may remind you of the notation for implication in mathematics. That’s intentional. We can read the type as “giving the function a </span><span class="c25">T</span><span class="calibre3">&nbsp;implies that it will produce a </span><span class="c25">U</span><span class="calibre3">” (not giving it a </span><span class="c25">T</span><span class="calibre3">&nbsp;implies nothing about what it will do…). It is that </span><span class="c6">implication</span><span class="c2">&nbsp;that is assumed in the application rule, and that is guaranteed by the rule for lambda.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This assume-guarantee reasoning shows up in many places, so look out for this pattern in other places as well.</span></p></div>

<div class="c" id="calibre_link-28">
<h2 class="c21" id="calibre_link-195"><span class="c2">Recursion and Infinite Loops</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We alluded, earlier, to how we can desugar more interesting features into functions and application. Let’s take a look at a very specific feature: an infinite loop. Let’s first confirm that we can write an infinite loop. Here’s a program that does it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">fun f():</span></p><p class="c4"><span class="c34">&nbsp; f()</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">f()</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But this assumes we already have recursion. Can we write it without recursion? Actually we can! We’ll use historical names (</span><span class="c91">ω</span><span class="c2">&nbsp;is the lower-case Greek omega):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(let ([</span><span class="c91">ω</span><span class="c34">&nbsp;(lambda (x) (x x))])</span></p><p class="c4"><span class="c25">&nbsp; (</span><span class="c91">ω</span><span class="c25">&nbsp;</span><span class="c91">ω</span><span class="c34">))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Run this in Racket and confirm that it runs forever!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="calibre3">&nbsp;Write a conditional type rule for </span><span class="c25">let</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s see what happens when we try to type this. We have to provide a type annotation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(let ([</span><span class="c91">ω</span><span class="c34">&nbsp;(lambda (x : ???) (x x))])</span></p><p class="c4"><span class="c25">&nbsp; (</span><span class="c91">ω</span><span class="c25">&nbsp;</span><span class="c91">ω</span><span class="c34">))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Historically, the overall term is called </span><span class="c91">Ω</span><span class="c2">&nbsp;(the capital Greek omega).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, so what is the annotation? To determine a type for </span><span class="c25">x</span><span class="calibre3">, we have to see how it’s used. It’s used twice. One use is in a function application position, so we know that the type must be of the form </span><span class="c25">(T -&gt; U)</span><span class="calibre3">; now we have to determine what </span><span class="c25">T</span><span class="calibre3">&nbsp;and </span><span class="c25">U</span><span class="calibre3">&nbsp;are. Let’s focus on the parameter type, </span><span class="c25">T</span><span class="calibre3">. But what are we passing in? We’re passing in </span><span class="c25">x</span><span class="calibre3">, whose type is </span><span class="c25">(T -&gt; U)</span><span class="c2">. So we need a solution to the equation</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">T</span><span class="calibre3">&nbsp;= </span><span class="c34">(T -&gt; U)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">with one coming from the application position and the other from the argument position. Of course, there is no finite type that can fit this equation! Therefore, it appears that this program cannot be typed!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Of course, this is not a proof. However, there is a formal property associated with this programming language, which is called the Simply Typed Lambda Calculus (STLC): the property is called </span><span class="c6">strong normalization</span><span class="calibre3">, and it means that </span><span class="c6">all programs in this language terminate</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;If you have heard about the Halting Problem, how does that square with what you just read?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It may seem rather useless to have a language in which all programs terminate&mdash;you can’t write an operating system, or Web server, or many other programs in such a language. However, that misses two things.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">First, there are many cases where we </span><span class="c6">want</span><span class="calibre3">&nbsp;programs to always terminate. You don’t want a network packet filter or a device driver or a compiler or a type-checker or … to run forever. Of course we also want them to run quickly, but it would be nice if we had a guarantee that no matter what we did, we </span><span class="c6">cannot</span><span class="c2">&nbsp;create an infinite loop. The STLC is very useful in some of these settings. Another example of a place where we want guaranteed termination is in program linking, and the module language of Standard ML is therefore built atop the STLC: it lets you even write higher-order programs, but the type language guarantees that all module compositions (linkages) will terminate.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Second, many long-running programs are actually a composition of an infinite loop and a short-running program. Think about an operating system with device drivers, a Web server with a Web application, a GUI with callbacks, etc. In each case, there is a “spine” of an infinite loop that simply keeps the program reactive, and “ribs” of short computations that do a little specific work and terminate. In fact, on the Web these programs </span><span class="c6">must</span><span class="calibre3">&nbsp;terminate quickly, otherwise the Web browser thinks the server has hung and offers to kill the window! These kinds of </span><span class="c6">reactive systems</span><span class="c2">&nbsp;are therefore a composition of a very generic infinite loop calling out to specific programs for which a termination guarantee will often be very useful.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, observe that we’ve learned something profound. Until now, we have probably thought of types as just a convenience or as a way of eliminating basic errors. However, we have just now seen that adding a type system can </span><span class="c6">change the expressive power of a language</span><span class="c2">. That is, these types are “semantic”.</span></p></div>

<div class="c" id="calibre_link-1">
<h2 class="c21" id="calibre_link-196"><span class="c2">Typing Recursion</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What went wrong above? The problem is that each application “uses up an arrow” in a function type; because a program text must be finite, it can contain at most a finite number of “arrows”, so eventually the program must terminate. To get around this, we need a way to effectively have an “infinite quiver”.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We typically do this by adding a recursive function construct to the language, and create a custom type for it. Let’s start with a type rule for the analogous, but simpler, </span><span class="c25">let</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- E : T &nbsp; &nbsp;</span><span class="c84">Γ[V &lt;- T] </span><span class="c34">|- B : U</span></p><p class="c4"><span class="c34">--------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (let V : T E B) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Note that we’re going to expect an annotation in </span><span class="c25">let</span><span class="calibre3">&nbsp;for the same reason we do for function definitions. So this says that we’ll check that </span><span class="c25">E</span><span class="calibre3">&nbsp;actually does have the type promised in the declaration, </span><span class="c25">T</span><span class="calibre3">; when we extend the type environment with the </span><span class="c25">V</span><span class="calibre3">&nbsp;having type </span><span class="c25">T</span><span class="calibre3">, if the body </span><span class="c25">B</span><span class="calibre3">&nbsp;produces type </span><span class="c25">U</span><span class="c2">, then that’s the type of the whole expression.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;Notice that there’s an assume-guarantee pair in the antecedent: the first term is guaranteeing the annotation, which the second term is assuming.</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Technically, the type of </span><span class="c25">E</span><span class="calibre3">&nbsp;could be </span><span class="c6">calculated</span><span class="calibre3">. Therefore, the </span><span class="c25">T</span><span class="c2">&nbsp;annotation is not strictly necessary.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that this is basically the type rule we would get from expanding the syntactic sugar for </span><span class="c25">let</span><span class="calibre3">. Therefore, this still doesn’t let us write a recursive definition. We need something more. Let’s introduce a new construct, </span><span class="c25">rec</span><span class="calibre3">, for recursive definitions. An example of a </span><span class="c25">rec</span><span class="c2">&nbsp;(in an untyped setting) might be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(rec ([inf-loop (lambda (n) (inf-loop n))])</span></p><p class="c4"><span class="c34">&nbsp; (inf-loop 0))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(rec ([fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))])</span></p><p class="c4"><span class="c34">&nbsp; (fact 10))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In the typed world, we’ll want rec to have the form</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(rec V : T E B)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">so we’d instead have to write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(rec inf-loop : (Number -&gt; Number)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(lambda (n) (inf-loop n))</span></p><p class="c4"><span class="c34">&nbsp; (inf-loop 0))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(rec fact : (Number -&gt; Number)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))</span></p><p class="c4"><span class="c25">&nbsp; (fact 10))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c25">V</span><span class="calibre3">&nbsp;is </span><span class="c25">fact</span><span class="calibre3">, </span><span class="c25">T</span><span class="calibre3">&nbsp;is </span><span class="c25">(Number -&gt; Number)</span><span class="calibre3">, </span><span class="c25">E</span><span class="calibre3">&nbsp;is the big </span><span class="c25">lambda</span><span class="calibre3">&nbsp;term, and </span><span class="c25">B</span><span class="calibre3">&nbsp;is </span><span class="c25">(fact 10)</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So this introduces a recursive definition, and then uses it. How might we type this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">???</span></p><p class="c4"><span class="c34">------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Well, clearly one part of it must be the same: we have to type the body in the extended environment, and the environment must be extended with the annotated type:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">??? &nbsp; &nbsp;Γ[V &lt;- T] </span><span class="c34">|- B : U</span></p><p class="c4"><span class="c34">-------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We also know that we need to confirm that the annotation is correct:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">??? </span><span class="c25">|- E : T</span><span class="c84">&nbsp; &nbsp; Γ[V &lt;- T] </span><span class="c34">|- B : U</span></p><p class="c4"><span class="c34">----------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But clearly, </span><span class="c6">something</span><span class="calibre3">&nbsp;needs to be different, otherwise we’ve just reproduced </span><span class="c25">let</span><span class="calibre3">. Look at the example use of </span><span class="c25">rec</span><span class="calibre3">: the </span><span class="c25">E</span><span class="calibre3">&nbsp;term also needs to have </span><span class="c25">V</span><span class="calibre3">&nbsp;bound in it! In other words, both </span><span class="c25">E</span><span class="calibre3">&nbsp;and </span><span class="c25">B</span><span class="c2">&nbsp;are typed in the same environment:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ[V &lt;- T] </span><span class="c25">|- E : T</span><span class="c84">&nbsp; &nbsp; Γ[V &lt;- T] </span><span class="c34">|- B : U</span></p><p class="c4"><span class="c34">----------------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (rec V : T E B) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">From the type, we can read off how the recursion happens: the extended environment for </span><span class="c25">B</span><span class="calibre3">&nbsp;</span><span class="c6">initiates</span><span class="calibre3">&nbsp;the recursion, while that for </span><span class="c25">E</span><span class="calibre3">&nbsp;</span><span class="c6">sustains</span><span class="calibre3">&nbsp;it. Essentially, the environment of </span><span class="c25">E</span><span class="c2">&nbsp;enables arbitrary recursive depth.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In short, to obtain arbitrary recursion&mdash;and hence infinite loops&mdash;we have to add a special construct to the language and its type-checker; we cannot obtain it just through desugaring. Once we add </span><span class="c25">rec</span><span class="c2">&nbsp;to the STLC, however, we obtain a conventional programming language again.</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-33">
<h1 class="c26" id="calibre_link-402"><span class="c2"></span></h1><h1 class="c20" id="calibre_link-197"><span class="c2">Safety and Soundness</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">A critical component of SMoL is the concept of </span><span class="c6">safety</span><span class="calibre3">: that some operations are </span><span class="c6">partial</span><span class="calibre3">&nbsp;over the set of all values, and that a SMoL language enforces this by reporting violations. Typical examples of partiality may include </span><span class="c25">+</span><span class="calibre3">&nbsp;applying only to certain types of values. However, I intentionally write “operations” rather than, say, “functions”, because these could be primitive operations like application (expecting the first position to be a function or method) as well. In fact, in some languages like JavaScript, there are very few violations, as the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://www.destroyallsoftware.com/talks/wat&amp;sa=D&amp;source=editors&amp;ust=1695232021400146&amp;usg=AOvVaw1NOpkYKNjpy6IwTp-vrqEQ">Wat talk</a></span><span class="c2">&nbsp;shows.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">How must these be enforced? It can be either statically or dynamically. In Python and JavaScript, for instance, all safety violations are reported dynamically. In Java or OCaml, most of them are reported statically. Either way, safety means that </span><span class="c6">data have integrity</span><span class="calibre3">: there is some notion of “what they are”, and that identity is respected by operations. Put differently, data are not </span><span class="c6">misinterpreted</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These are all very abstract statements, which we will soon concretize.</span></p></div>

<div class="c" id="calibre_link-64">
<h2 class="c21" id="calibre_link-198"><span class="c2">Revisiting the Basic Calculator</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We will start with a very basic calculator that has two types, numbers and strings, and an operation (addition and concatenation, respectively) on them. Note that it helps to have more than one type if we want to talk about safety. We will skip most of the boilerplate code and focus on the core of the calculator:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type Exp</span></p><p class="c4"><span class="c34">&nbsp; [num (n : Number)]</span></p><p class="c4"><span class="c34">&nbsp; [str (s : String)]</span></p><p class="c4"><span class="c34">&nbsp; [plus (l : Exp) (r : Exp)]</span></p><p class="c4"><span class="c34">&nbsp; [cat (l : Exp) (r : Exp)])</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define-type Value</span></p><p class="c4"><span class="c34">&nbsp; (numV (n : Number))</span></p><p class="c4"><span class="c34">&nbsp; (strV (s : String)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(calc : (Exp -&gt; Value))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (calc e)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Exp e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(num n) (numV n)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(str s) (strV s)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(plus l r) (num+ (calc l) (calc r))]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(cat l r) (str++ (calc l) (calc r))]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (num+ lv rv)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Value lv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; ((numV ln)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case Value rv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;((numV rn) (numV (+ ln rn)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(else (error '+ "right not a number"))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (else (error '+ "left not a number"))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (str++ lv rv)</span></p><p class="c4"><span class="c34">&nbsp; (type-case Value lv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; ((strV ls)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(type-case Value rv</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;((strV rs) (strV (string-append ls rs)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(else (error '++ "right not a string"))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (else (error '++ "left not a string"))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c2">You might have imagined the latter two functions to be merely convenient helpers, and hence wonder why they are part of the “core”. You will soon see why!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With a suitable parser, we can run tests such as the following:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (calc (plus (num 1) (num 2))) (numV 3))</span></p><p class="c4"><span class="c34">(test (calc (plus (num 1) (plus (num 2) (num 3)))) (numV 6))</span></p><p class="c4"><span class="c34">(test (calc (cat (str "hel") (str "lo"))) (strV "hello"))</span></p><p class="c4"><span class="c34">(test (calc (cat (cat (str "hel") (str "l")) (str "o"))) (strV "hello"))</span></p><p class="c4"><span class="c34">(test/exn (calc (cat (num 1) (str "hello"))) "left")</span></p><p class="c4"><span class="c34">(test/exn (calc (plus (num 1) (str "hello"))) "right")</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">The last two, in particular, show that the language is safe. The checks inside the primitives&mdash;in </span><span class="c25">num+</span><span class="calibre3">, for instance&mdash;are called </span><span class="c6">safety checks</span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-287">
<h2 class="c21" id="calibre_link-199"><span class="c2">Making Memory Explicit (Unsafely)</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we’re going to do something fun: we’re going to make the memory allocation of values explicit. As we go through this, remember what we’ve said before: a value in SMoL is just a memory address.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s do this in stages. First, we’ll use a vector to represent memory:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define MEMORY (make-vector 100 -1))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The value </span><span class="c25">-1</span><span class="calibre3">&nbsp;is useful for identifying parts of memory that have not yet been touched (assuming, of course, we don’t write a program that produces </span><span class="c25">-1</span><span class="c2">&mdash;which we can avoid doing easily enough in this illustration).</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;To run the code below, you will need to import some Racket primitives into plait:</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c34">(require (typed-in racket/base</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[char-&gt;integer : (Char -&gt; Number)]</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[integer-&gt;char : (Number -&gt; Char)]</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[number-&gt;string : (Number -&gt; String)]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It will be useful to have a helper to use the next available bit of memory:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define next-addr 0)</span></p><p class="c4"><span class="c34">(define (write-and-bump v)</span></p><p class="c4"><span class="c34">&nbsp; (let ([n next-addr])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (vector-set! MEMORY n v)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! next-addr (add1 next-addr))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; n)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">Now let’s say we want to store a number in memory. We put it in the next available memory place, and return the </span><span class="c6">address</span><span class="calibre3">&nbsp;of the place where the number was stored. Be careful here: the number we return is a memory address (which, here, is represented as an array index), which is not at all necessarily the same as the </span><span class="c6">numeric value</span><span class="c2">&nbsp;being stored.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (store-num n)</span></p><p class="c4"><span class="c34">&nbsp; (write-and-bump n))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Correspondingly, when we want to read a number, we simply return what is at the address corresponding to the number.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (read-num a)</span></p><p class="c4"><span class="c34">&nbsp; (vector-ref MEMORY a))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We want the property that when we </span><span class="c25">read-num</span><span class="calibre3">&nbsp;from the address where we </span><span class="c25">store-num</span><span class="calibre3">&nbsp;a number, we get back that same number: for all </span><span class="c25">N</span><span class="c2">,</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="c25">(read-num (store-num N))</span><span class="calibre3">&nbsp;is </span><span class="c34">N</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;This is not quite exactly how numbers are stored in most languages. As we will see when we update the calculator below, this means every time we produce a particular number&mdash;</span><span class="c25">1730</span><span class="calibre3">, say&mdash;we store it afresh in memory. That would be extremely wasteful. Rather, language implementations use representation tricks to make sure there is only one copy of numbers and that they don’t need to take up space on the heap at all, as we describe below [</span><span class="c15"><a class="c10" href="#calibre_link-204">👉</a></span><span class="calibre3">]. However, we will continue to work with this simple model because this optimization is not the focus of this chapter. In addition, </span><span class="c6">some</span><span class="calibre3">&nbsp;numbers&mdash;that don’t fit in a small amount of space&mdash;</span><span class="c6">do</span><span class="c2">&nbsp;need to be stored on the heap.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s look at strings. We are going to convert the string into a sequence of character codes, and store those codes explicitly:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (store-str s)</span></p><p class="c4"><span class="c34">&nbsp; (let ([a0 (write-and-bump (string-length s))])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (map write-and-bump</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map char-&gt;integer (string-&gt;list s)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; a0)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In particular, the value stored at the address representing the string is the </span><span class="c6">length</span><span class="c2">&nbsp;of the string, followed by the individual characters. (Endless blood has been spent over whether strings should store their lengths at the front, or whether they should only be delimited by a special value, or both. The question is uninteresting here.) Thus, suppose with a fresh memory we run</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(store-str "hello")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">this would return the address </span><span class="c25">0</span><span class="c2">. The resulting value of MEMORY would be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">'#(5</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;104</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;101</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;108</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;108</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;111</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;-1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;-1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;-1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;…)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, at address </span><span class="c25">0</span><span class="calibre3">&nbsp;we have the length of the string, followed by five character codes; these six memory entries together constitute the five-character string </span><span class="c25">"hello"</span><span class="c2">. The rest of the memory remains untouched. To read a string we have to reassemble it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (read-str a)</span></p><p class="c4"><span class="c34">&nbsp; (letrec ([loop</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (count a)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (zero? count)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cons (vector-ref MEMORY a)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (loop (sub1 count) (add1 a)))))])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (list-&gt;string</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(map integer-&gt;char</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (loop (vector-ref MEMORY a) (add1 a))))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Once again, we want the result of reading a written string to give us the same string.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s update the calculator. First, we’re in for a surprise: we no longer need (or </span><span class="c6">want</span><span class="c2">) a fancy Racket datatype to track values, because values are just addresses (i.e., array indices)! So:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type-alias Value Number)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The </span><span class="c6">type</span><span class="calibre3">&nbsp;of the calculator doesn’t change; it still produces values. It’s just that the representation of values has changed…dramatically. (Recall, again, that these </span><span class="c25">Number</span><span class="calibre3">s are addresses, not numeric values </span><span class="c6">in</span><span class="c2">&nbsp;the interpreted language.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The calculator remains the same. What has changed is in the helper functions. In the primitive value cases, we have to explicitly allocate them&mdash;which is what we were doing when we called the previous definitions of </span><span class="c25">numV</span><span class="calibre3">&nbsp;and </span><span class="c25">strV</span><span class="c2">&nbsp;(which store data on the heap), except it may not have been so evident. We will make it explicit as follows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define numV store-num)</span></p><p class="c4"><span class="c34">(define strV store-str)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Okay, now to update the helper functions. Let’s focus on </span><span class="c25">num+</span><span class="c2">. The core logic is currently</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(numV rn) (numV (+ ln rn))]</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that now we’re calling it on the result of calling </span><span class="c25">calc</span><span class="calibre3">, i.e., on </span><span class="c25">Value</span><span class="calibre3">s. That means </span><span class="c25">num+</span><span class="c2">&nbsp;is going to get two addresses as arguments, and it needs to look up the corresponding numbers in memory, and then produce the resulting number:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (num+ la ra)</span></p><p class="c4"><span class="c34">&nbsp; (numV (+ (read-num la) (read-num ra))))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="c2">In case you’re wondering: yes, we’re cheating a tiny bit. We’re using Racket numbers rather than dealing with even lower-level representations. We’ll give ourselves this little bit of leeway since this is not the point we’re trying to illustrate.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Analogously, we can define concatenation as well:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (str++ la ra)</span></p><p class="c4"><span class="c34">&nbsp; (strV (string-append (read-str la) (read-str ra))))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">Yes, we’re cheating again, and quite a bit. If we were less lazy, we’d write a big loop over </span><span class="c25">MEMORY</span><span class="c2">&nbsp;that copies all the values from the first and second strings into a new, third string, explicitly. But we’re lazy.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, we have to update our tests as well. Because </span><span class="c25">calc</span><span class="calibre3">&nbsp;now returns </span><span class="c6">addresses</span><span class="calibre3">, all our answers appear to be incorrect. Instead, we have to obtain the corresponding numbers or strings at those addresses. Once we do so, </span><span class="c25">calc</span><span class="c2">&nbsp;passes the tests:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (read-num (calc (plus (num 1) (num 2)))) 3)</span></p><p class="c4"><span class="c34">(test (read-num (calc (plus (num 1) (plus (num 2) (num 3))))) 6)</span></p><p class="c4"><span class="c34">(test (read-str (calc (cat (str "hel") (str "lo")))) "hello")</span></p><p class="c4"><span class="c34">(test (read-str (calc (cat (cat (str "hel") (str "l")) (str "o")))) "hello")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Except…does it? These two tests do not pass:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test/exn (calc (cat (num 1) (str "hello"))) "left")</span></p><p class="c4"><span class="c34">(test/exn (calc (plus (num 1) (str "hello"))) "right")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In fact, how </span><span class="c6">can</span><span class="c2">&nbsp;they? In all the above code, there are no errors left! Rather, when we run</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(calc (cat (num 1) (str "hello")))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">we get an address back (maybe </span><span class="c25">69</span><span class="calibre3">; it depends on what you ran earlier and hence what is in </span><span class="c25">MEMORY</span><span class="c2">). In fact, we can decide how we want to treat this: as a number?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (read-num 69)</span></p><p class="c4"><span class="c34">- Number</span></p><p class="c4"><span class="c34">6</span></p><p class="c4"><span class="c34">&gt; (read-str 69)</span></p><p class="c4"><span class="c34">- String</span></p><p class="c4"><span class="c34">"\u0005hello"</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">How can something be both a number and a string? Well, actually, the situation is a bit more confusing than that: </span><span class="c25">69</span><span class="calibre3">&nbsp;above is just an address in memory from which we can read off whatever we want </span><span class="c6">however we want it</span><span class="calibre3">&nbsp;(i.e., the content of that address is </span><span class="c6">interpreted</span><span class="c2">&nbsp;by the function that reads from it), which can result in garbage. It can get even worse:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (read-num (calc (plus (num 1) (str "hello"))))</span></p><p class="c4"><span class="c34">- Number</span></p><p class="c4"><span class="c34">6</span></p><p class="c4"><span class="c34">&gt; (read-str (calc (plus (num 1) (str "hello"))))</span></p><p class="c4"><span class="c34">- String</span></p><p class="c4"><span class="c61">. . integer-&gt;char: contract violation</span></p><p class="c4"><span class="c61">&nbsp; expected: valid-unicode-scalar-value?</span></p><p class="c4"><span class="c61">&nbsp; given: -1</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, we’ve tried to read “off the end of memory”. It was dumb luck that we had a </span><span class="c25">-1</span><span class="calibre3">&nbsp;as the initial value; the </span><span class="c25">-1</span><span class="calibre3">&nbsp;triggered an error when we tried to convert it to a character </span><span class="c6">because Racket’s primitives are safe</span><span class="calibre3">, which halted the program. If </span><span class="c25">integer-&gt;char</span><span class="c2">&nbsp;did not have a safety check, we would have gotten some garbled string instead.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In short, what we have created is an </span><span class="c6">unsafe</span><span class="c2">&nbsp;language. Data have no integrity. Any value can be treated as any kind of datum. This, in short, is the memory model of C, and it’s largely proven to be a disaster for modern programming, which is why SMoL languages evolved.</span></p></div>

<div class="c" id="calibre_link-313">
<h2 class="c21" id="calibre_link-200"><span class="c2">Recovering Safety</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Fortunately, it does not take too much work to make the language safe again. What we’ve just written holds the key: every value needs to record what kind of value it is. And any use of that value needs to check that it’s the right kind of value. This information is called a </span><span class="c6">tag</span><span class="calibre3">; it takes a fixed amount of space, and represents </span><span class="c6">metadata</span><span class="c2">&nbsp;about the subsequent datum. All subsequent values are interpreted in accordance with the tag.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We need two tags for the two kinds of values. Let’s use</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define NUMBER-TAG 1337)</span></p><p class="c4"><span class="c34">(define STRING-TAG 5712)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It’s important that the two tags be different, so they are unambiguous. However, we don’t need to worry about the tags themselves being confused with other data (e.g., numbers), because the tags will never be processed directly as program data (unless, of course, there is a bug in our implementation that accidentally does so…which is why language implementations need to be tested extensively).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now, when we allocate a number, we write its </span><span class="c6">tag</span><span class="c2">&nbsp;into the first address, followed by the actual numeric value:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (store-num n)</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c54">(let ([a0 (write-and-bump NUMBER-TAG)])</span></p><p class="c4"><span class="c54">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (write-and-bump n)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; </span><span class="c53">a0))</span><span class="c34">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">And when we try to read a number, we </span><span class="c6">first</span><span class="calibre3">&nbsp;check that it really </span><span class="c6">is</span><span class="c2">&nbsp;a number, and only then obtain the actual numeric value:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (safe-read-num a)</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c54">(if (= (vector-ref MEMORY a) NUMBER-TAG)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; (vector-ref MEMORY </span><span class="c53">(add1 </span><span class="c25">a</span><span class="c53">)</span><span class="c34">)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; </span><span class="c53">(error 'number (number-&gt;string a)))</span><span class="c34">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Strings are analogous:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (store-str s)</span></p><p class="c4"><span class="c25">&nbsp; (let ([a0 (write-and-bump </span><span class="c53">STRING-TAG</span><span class="c34">)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; </span><span class="c54">(write-and-bump (string-length s))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (map write-and-bump</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map char-&gt;integer (string-&gt;list s)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; a0)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (safe-read-str a)</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c54">(if (= (vector-ref MEMORY a) STRING-TAG)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (letrec ([loop</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lambda (count a)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (if (zero? count)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; empty</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cons (vector-ref MEMORY a)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (loop (sub1 count) (add1 a)))))])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (list-&gt;string</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map integer-&gt;char</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (loop (vector-ref MEMORY </span><span class="c53">(add1 </span><span class="c25">a</span><span class="c53">)</span><span class="c25">) (+ a </span><span class="c53">2</span><span class="c34">)))))</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; </span><span class="c53">(error 'string (number-&gt;string a)))</span><span class="c34">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So now, starting from a fresh memory, running</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(store-str "hello")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">still produces </span><span class="c25">0</span><span class="calibre3">, but the content of </span><span class="c25">MEMORY</span><span class="c2">&nbsp;looks a bit different:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">'#(</span><span class="c54">5712</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;5</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;104</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;101</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;108</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;108</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;111</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;-1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;-1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;-1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;…)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, at address </span><span class="c25">0</span><span class="calibre3">&nbsp;we first encounter the tag for strings. Only then do we get the string’s length, followed by its contents. Observe that now, storing the length up front makes even more sense: the first two locations contain the tag and the length, both of which are metadata that help us interpret what comes later, with the second (the length) </span><span class="c6">refining</span><span class="c2">&nbsp;the first (the tag).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">With this change, the interpreter stays unchanged, and effectively so do the helpers, other than using the new names we’ve chosen:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (num+ la ra)</span></p><p class="c4"><span class="c25">&nbsp; (store-num (+ (</span><span class="c53">safe-</span><span class="c25">read-num la) (</span><span class="c53">safe-</span><span class="c34">read-num ra))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (str++ la ra)</span></p><p class="c4"><span class="c25">&nbsp; (store-str (string-append (</span><span class="c53">safe-</span><span class="c25">read-str la) (</span><span class="c53">safe-</span><span class="c34">read-str ra))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">All our “good” tests still pass, but interestingly, our “bad” tests now fail:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test/exn (calc (cat (num 1) (str "hello"))) "string")</span></p><p class="c4"><span class="c34">(test/exn (calc (plus (num 1) (str "hello"))) "number")</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="c2">You may notice the error message strings above have changed slightly. Why?</span></p></div>

<div class="c" id="calibre_link-335">
<h2 class="c21" id="calibre_link-201"><span class="c2">What Price Safety?</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Our safe evaluator has, however, come at a price relative to the unsafe evaluator. In terms of running </span><span class="c33">time</span><span class="calibre3">, we are now clearly paying for the overhead of safety checks. In terms of </span><span class="c33">space</span><span class="calibre3">, we are paying for the tags. Thus, we have had to get worse space </span><span class="c6">and</span><span class="c2">&nbsp;time.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Nevertheless, the price of unsafe languages is so high&mdash;e.g., in the form of security problems&mdash;and the cost of safety is often so low, that programmers gladly pay this price (or do so without even particularly noticing it).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Still, it would be nice if we didn’t have to pay the price at all. And there is a way to accomplish that: </span><span class="c6">types</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Look at our “bad” programs. These are programs that can </span><span class="c6">statically</span><span class="calibre3">&nbsp;be rejected by a type-checker. If we could reject all such programs, then&mdash;since no “bad” programs would be left&mdash;we can then run the program on the </span><span class="c6">unsafe</span><span class="c2">&nbsp;evaluator without worrying about negative consequences. This, in effect, is what most typed languages, like Java and OCaml, do. Thus we find another use for types: to improve program performance. But this requires care.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Usually, in computer science, we talk about a space-time </span><span class="c6">tradeoff</span><span class="calibre3">. Yet here we seem to have a situation where we’ve improved (i.e., reduced the use of) both the space </span><span class="c6">and</span><span class="c2">&nbsp;the time! How is that possible?</span></p></div>

<div class="c" id="calibre_link-302">
<h2 class="c21" id="calibre_link-202"><span class="c2">Soundness</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Running on an unsafe evaluator is, as the name suggests, dangerous. Therefore, we should only do it if we can be sure that nothing can go wrong. That means that our type system needs to come with a </span><span class="c6">guarantee</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The way this guarantee is usually formulated is as follows. Suppose we have</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">e : t</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and suppose we evaluate it and find that</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">e -&gt; v</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The latter&mdash;its value&mdash;is the ground truth. The type checker’s job is to make sure it matches what the evaluator produces. That is, we would ideally like that</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">e : t</span><span class="calibre3">&nbsp;if and only if </span><span class="c25">e -&gt; v</span><span class="calibre3">&nbsp;and </span><span class="c34">v : t</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This says that the type checker's job is to perfectly mirror the evaluator: whatever type the program’s result value has is the same type the type-checker says it has.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Unfortunately, for a Turing-complete language, this full guarantee is impossible to obtain, because of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Rice%2527s_theorem&amp;sa=D&amp;source=editors&amp;ust=1695232021427399&amp;usg=AOvVaw1_99VdJEVQ2qFHhOKxeYso">Rice’s Theorem</a></span><span class="c2">. Instead, we have to compromise and see if we can get at least one of the two directions. When we think about it, we realize that, in a typed language, we’re only really interested in programs that pass the type-checker (i.e., have a type). Therefore, we expect that</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If </span><span class="c25">e : t</span><span class="c2">&nbsp;then</span></p><p class="c4"><span class="calibre3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if </span><span class="c25">e -&gt; v</span><span class="calibre3">, then </span><span class="c34">v : t</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This says that whatever type the type-checker predicted is exactly the type that the program has. That means we can rely on the type-checker’s prediction. Which in turn means that we can be sure there are no type violations. Which tells us we can safely run the program atop an unsafe evaluator! This property is called </span><span class="c6">type soundness</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Note that soundness is not a given: it’s a property that must be formally, mathematically </span><span class="c6">proven</span><span class="calibre3">&nbsp;of a given type-checker and evaluator. The proof can be quite complex. This is because the “shape” of program evaluation and that of type-checking can be very different, as we have seen before for conditionals [</span><span class="c15"><a class="c10" href="#calibre_link-187">👉</a></span><span class="calibre3">] and functions [</span><span class="c15"><a class="c10" href="#calibre_link-66">👉</a></span><span class="c2">]. And failure to prove it correctly&mdash;i.e., claiming it holds when in fact it doesn’t&mdash;means we’ve allowed a vulnerability to slip through. This can manifest as uncaught exceptions, crashes, segmentation faults, etc. In addition, a clever attacker can construct a program that exploits the vulnerability, and our system can be subjected to a security or other attack. Thus, any soundness violations are emergencies and result in panic.</span></p></div>

<div class="c" id="calibre_link-29">
<h2 class="c21" id="calibre_link-203"><span class="c2">Generic Printing</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">One of the consequences of our tagged representation is that when extracting a value from memory, we don’t </span><span class="c6">have</span><span class="calibre3">&nbsp;to know whether to use </span><span class="c25">safe-read-num</span><span class="calibre3">&nbsp;or </span><span class="c25">safe-read-str</span><span class="c2">; the tag at the address can tell us which to use. That is, we can define</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (generic-read a)</span></p><p class="c4"><span class="c34">&nbsp; (let ([tag (vector-ref MEMORY a)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(= tag NUMBER-TAG) (safe-read-num a)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [(= tag STRING-TAG) (safe-read-str a)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; [else (error 'generic-print "invalid tag")])))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Unfortunately, this code can’t be typed by plait because the two branches return different types. We can solve this in two ways:</span></p><p class="c3"><span class="c2"></span></p><ol class="c92" start="1"><li class="pcalibre23 c93"><span class="calibre3">We can use a hack: use </span><span class="c25">#lang plait #:untyped</span><span class="calibre3">, which provides the same syntactic language, features, and run-time behavior, but turns off the type-checker. (Curiously, we were using the type-checker to keep us disciplined: so that the only values we could store in </span><span class="c25">MEMORY</span><span class="c2">&nbsp;would be numbers! Therefore, it’s good to not use the untyped version often.)</span></li><li class="pcalibre23 c93"><span class="calibre3">Notice that in the end, what printers do is essentially print a string. Therefore, we just need to return a string in all cases:<br class="calibre" /><br class="calibre" /></span><span class="c34">(define (generic-read a)</span></li></ol><p class="c27"><span class="c34">&nbsp; (let ([tag (vector-ref MEMORY a)])</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; (cond</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp; [(= tag NUMBER-TAG) (number-&gt;string (safe-read-num a))]</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp; [(= tag STRING-TAG) (safe-read-str a)]</span></p><p class="c27"><span class="c34">&nbsp; &nbsp; &nbsp; [else (error 'generic-print "invalid tag")])))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A consequence of having this function is that we can rewrite our tests to be more proper:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(test (generic-read (calc (plus (num 1) (num 2)))) "3")</span></p><p class="c4"><span class="c34">(test (generic-read (calc (plus (num 1) (plus (num 2) (num 3))))) "6")</span></p><p class="c4"><span class="c34">(test (generic-read (calc (cat (str "hel") (str "lo")))) "hello")</span></p><p class="c4"><span class="c34">(test (generic-read (calc (cat (cat (str "hel") (str "l")) (str "o")))) "hello")</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">This is much closer to how we would write the test in the original interpreter; the only difference here is that the evaluator produces an address as the value, but we would like to inspect the value in a human-readable and -writable form, so we use </span><span class="c25">generic-read</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Alert:</span><span class="calibre3">&nbsp;If you run these tests in addition to the preceding ones, you may need to enlarge </span><span class="c25">MEMORY</span><span class="c2">.</span></p><a id="calibre_link-403"></a></div>

<div class="c" id="calibre_link-37">
<h2 class="c21" id="calibre_link-204"><span class="c2">The Representation of Numbers</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Examining the content of </span><span class="c25">MEMORY</span><span class="calibre3">&nbsp;gives the impression that every single number we compute is stored afresh on the heap, and furthermore, if we compute a certain number (say </span><span class="c25">3</span><span class="c2">) twice, each instance will be stored and hence take up space. However, this is not the space consumption model of real implementations.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">On most modern architectures, values are stored at </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Data_structure_alignment&amp;sa=D&amp;source=editors&amp;ust=1695232021431461&amp;usg=AOvVaw1zfmzCHLp7ziOLweunTDXZ">“word” boundaries</a></span><span class="c2">: depending on the machine, starting at addresses that are multiples of 4 or 8. For the purposes of illustration, let’s say we have a 32-bit machine, with 4-byte alignment. (The reasons for this are due to details of computer architecture that are outside the scope of this book.) That means every legal memory address, when viewed in binary, ends in …00. However, there are four legal values for those two bits, only one of which is being used. This creates an opportunity.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A common technique is to therefore use a pattern like …01 to be the tag for numbers. The actual number itself is stored in the remaining (say 30) bits of the “address”. That means, “addresses” that end in 01 are not true addresses, and must not be looked up; they are actually just numbers.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Thus, in principle, the first thing to do with a value (that is, an address) is to test its 0’th bit. If this is 1, then shift the value right by 2 places. This drops the 01 tag, </span><span class="c6">leaving the number in place</span><span class="c2">. Similarly, when a number is constructed, provided it fits in 30 bits, it is shifted left by two places, and the last bit is made 1 (resulting in the 01 tag).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As a consequence, every number has a tag; but every number is also stored in registers and on the stack, not on the heap. All numbers with the same value have the same bit-pattern representation (the 30-bit numeric value followed by 01). Thus, there will be </span><span class="c6">zero</span><span class="c2">&nbsp;instances of them on the heap, and they can be accurately compared for equality in constant time.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;Notice that the above technique only works for numbers that can fit in 30 bits (or about 60 bits in a 64-bit machine). Larger numbers have to still be stored on the heap.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As you might imagine, we have further room to play: we still have the patterns …10 and …11. Another good candidate for fitting entirely in the address is a Boolean, so the pattern …10 could be used for that. Very short strings might fit in a word. And so on. There are many architectural, instruction-set, and program considerations in designing these tags at the low level.</span></p></div>

<div class="c" id="calibre_link-65">
<h1 class="c20" id="calibre_link-32"><span class="c2">Type Inference</span></h1><h2 class="c21" id="calibre_link-205"><span class="c2">Unannotated Programs and Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider the following plait program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(lambda (x y)</span></p><p class="c4"><span class="c34">&nbsp; (if x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (+ y 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (+ y 2)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">If we enter this program into plait, e.g., as follows, something remarkable happens:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (lambda (x y)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (if x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (+ y 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (+ y 2)))</span></p><p class="c4"><span class="c34">- (Boolean Number -&gt; Number)</span></p><p class="c4"><span class="c34">#&lt;procedure&gt;</span></p><p class="c4"><span class="c2">&nbsp;</span></p><p class="c4"><span class="calibre3">In response, plait </span><span class="c6">figures out</span><span class="calibre3">&nbsp;the type of this function </span><span class="c6">without</span><span class="calibre3">&nbsp;our having to provide any annotations. This is in contrast to the type-checker we just wrote [</span><span class="c15"><a class="c10" href="#calibre_link-66">👉</a></span><span class="calibre3">], </span><span class="c2">which required us to extend the syntax just to provide (required) type annotations. That tells us that something different&mdash;and more&mdash;must be happening under plait. In contrast, consider another example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(lambda (x)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (if x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (+ x 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (+ x 2)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">This produces an error, observing that we are using </span><span class="c25">x</span><span class="calibre3">&nbsp;both in a position that requires it to be a Boolean (in </span><span class="c25">if</span><span class="c2">) and a number (in the two additions). Again, plait has figured this out without our having to write any annotations at all!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The algorithm that sits underneath plait is essentially the same algorithm under OCaml, Haskell, and several other programming languages. These languages provide </span><span class="c6">type inference</span><span class="c2">: figuring out (inferring) types automatically from the program source. Now we’re going to see how this works.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The key idea is to break this seemingly very complex problem into two rather simple parts. In the first, we recursively visit each sub-expression of the program (following SImPl) and generate a set of </span><span class="c6">constraints</span><span class="calibre3">&nbsp;that formally do what we’ve been doing informally above. The second phase </span><span class="c6">solves</span><span class="calibre3">&nbsp;this set of constraints, using a process that is a generalization of the process you used for solving “systems of simultaneous equations” in school. The solution is a </span><span class="c6">type</span><span class="c2">&nbsp;for each variable. That lets us fill in the annotations that the programmer left blank. </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The process of generation will also have applied the type constraints, so there will be no further need to type-check the program; but we can use the annotations, for instance, in an IDE for tool-tips, in a compiler for optimization, etc. That is, with inference, we can program as if we’re in a “scripty” language without annotations, yet achieve most of the benefits of types. (I say “most” because one of the benefits is documentation; leaving off all annotations makes programs harder to read and understand. For that reason, inference should be used sparingly.)</span></p></div>

<div class="c" id="calibre_link-290">
<h2 class="c21" id="calibre_link-206"><span class="c2">Imagining a Solution</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Until now, our type checker has required us to annotate the parameter of every function. But let’s imagine someone handed us a piece of code without annotations; can we figure out the type anyway? For instance, consider:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 1 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We clearly know the type of this; even our type-checker can calculate it for us without any annotations. But of course that’s not surprising: there are no variables to annotate. So now consider this expression:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(lambda (x : ___) (+ x 1))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">With a moment’s inspection, we can tell that the function has type </span><span class="c25">(Num -&gt; Num)</span><span class="calibre3">. But our type-checker couldn’t have calculated that, because it would have tripped on the empty annotation. So how can </span><span class="c6">we</span><span class="c2">&nbsp;figure it out?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Well, let’s see. First we have to figure out the type of </span><span class="c25">x</span><span class="calibre3">. To determine its type, we should look for </span><span class="c6">uses</span><span class="calibre3">&nbsp;of </span><span class="c25">x</span><span class="c2">. There is only one, and it’s used in an addition. But the rule for addition</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- e1 : Num &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c34">|- e2 : Num</span></p><p class="c4"><span class="c34">------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (+ e1 e2) : Num</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">tells us that the term in that position must have type </span><span class="c25">Num</span><span class="calibre3">. There is no additional information we have about </span><span class="c25">x</span><span class="calibre3">&nbsp;(this remark will become clearer in a moment). Therefore, we can determine that its type must be </span><span class="c25">Num</span><span class="calibre3">. Furthermore, we know that the result of an addition is also a </span><span class="c25">Num</span><span class="calibre3">. From that, we can conclude that the function has type </span><span class="c25">(Num -&gt; Num)</span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-317">
<h2 class="c21" id="calibre_link-207"><span class="c2">Unique Variable Names</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In what follows, we will assume that all variable names in the program are unique. That is, a given variable name is bound in at most one place in a program. This greatly simplifies the presentation below, because we can speak of the type of a variable and know </span><span class="c6">which</span><span class="c2">&nbsp;variable it refers to, instead of having to constantly qualify which variable of that name we mean.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This restriction does not actually preclude any programs in a language with static scope. Consider this program, which produces </span><span class="c25">7</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([x 3])</span></p><p class="c4"><span class="c34">&nbsp; (+ (let ([x 4])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;x)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;x))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We can just as well </span><span class="c6">consistently rename</span><span class="calibre3">&nbsp;one of the </span><span class="c25">x</span><span class="c2">s to something else (heck, we can even use the DrRacket interface to have Racket do the renaming for us), and leave the program meaning exactly the same:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([x 3])</span></p><p class="c4"><span class="c34">&nbsp; (+ (let ([y 4])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;y)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;x))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This renaming process is called </span><span class="c6">alpha conversion</span><span class="calibre3">&nbsp;or </span><span class="c6">alpha renaming</span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-336">
<h2 class="c21" id="calibre_link-208"><span class="c2">More Informal Examples</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">With that important detail out of the way, let’s return to our process of </span><span class="c6">inferring</span><span class="calibre3">&nbsp;or </span><span class="c6">reconstructing</span><span class="c2">&nbsp;the types of variables from the way they’re used in a program. Here’s another example with a two-parameter function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(lambda ((x : ___) (y : ___))</span></p><p class="c4"><span class="c34">&nbsp; (if x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (+ y 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (+ y 2)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Once again, we can’t just calculate its type with our type-checker; instead, we must reconstruct the type from the function body. Let’s do that. What can we tell? Let’s again refer to the conditional rule:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- C : Bool &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c25">|- T : U &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c34">|- E : U</span></p><p class="c4"><span class="c34">-----------------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (if C T E) : U</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This tells us that what’s in the </span><span class="c25">C</span><span class="calibre3">&nbsp;position&mdash;here, </span><span class="c25">x</span><span class="calibre3">&mdash;must be a </span><span class="c25">Bool</span><span class="calibre3">. Furthermore, both branches </span><span class="c25">(+ y 1)</span><span class="calibre3">&nbsp;and </span><span class="c25">(+ y 2)</span><span class="calibre3">&nbsp;must have the same type. That’s all we can learn from the rule for </span><span class="c25">if</span><span class="calibre3">! But now we can (and must) recur into the sub-expressions. Each one is an addition, and the addition rule tells us that both arguments must be </span><span class="c25">Num</span><span class="calibre3">s. Both of these indicate that the type of </span><span class="c25">y</span><span class="calibre3">&nbsp;must be </span><span class="c25">Num</span><span class="calibre3">. Furthermore, both indicate that the overall addition returns a </span><span class="c25">Num</span><span class="c2">. From that we can tell that the entire expression must have the type</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(Bool Num -&gt; Num)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">By this process, we can figure out what types to put in the missing annotations. More subtly, notice that by running through this process, we have effectively applied all the typing rules; therefore, if we have successfully reconstructed the type annotations, we need not bother type-checking the program with those annotations: it will have to type-check.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s consider a slight variation on the above program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(lambda (x : ___)</span></p><p class="c4"><span class="c34">&nbsp; (if x</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (+ x 1)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; (+ x 2)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s figure out everything we can learn about </span><span class="c25">x</span><span class="c2">&nbsp;from the function’s body:</span></p><ul class="c22"><li class="pcalibre c23"><span class="c25">x</span><span class="calibre3">&nbsp;is used in the conditional position of an </span><span class="c25">if</span><span class="calibre3">. Therefore, it must have type </span><span class="c25">Bool</span><span class="c2">.</span></li><li class="pcalibre c23"><span class="c25">x</span><span class="calibre3">&nbsp;is used as a parameter to </span><span class="c25">+</span><span class="calibre3">. Therefore, it must have type </span><span class="c25">Num</span><span class="c2">.</span></li><li class="pcalibre c23"><span class="c25">x</span><span class="calibre3">&nbsp;is again used as a parameter to </span><span class="c25">+</span><span class="calibre3">. Therefore, it must have type </span><span class="c25">Num</span><span class="c2">.</span></li></ul><p class="c4"><span class="calibre3">Notice that each of these conclusions is perfectly fine on its own. However, when we </span><span class="c6">put them together</span><span class="calibre3">&nbsp;(which is what we meant by “additional information” above), there’s a problem: </span><span class="c25">x</span><span class="calibre3">&nbsp;cannot be both of those. That is, we are unable to find a single type for </span><span class="c25">x</span><span class="calibre3">. This inability to find a type for </span><span class="c25">x</span><span class="calibre3">&nbsp;means that the program has a </span><span class="c6">type error</span><span class="calibre3">. And indeed, there </span><span class="c6">is</span><span class="c2">&nbsp;no type we could have given that would have enabled this program to execute safely.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe something subtle. While we can report that the program clearly has a type error, our error message must necessarily be much more ambiguous. Previously, when we had a type annotation on </span><span class="c25">x</span><span class="calibre3">, we could pinpoint where the error occurred. Now, all we can say is that the program is not type-</span><span class="c6">consistent</span><span class="calibre3">, but cannot blame one spot or the other without potentially misleading the programmer. Instead, we must report all these locations and let the programmer decide where the error is based on their </span><span class="c6">unstated intent</span><span class="c2">&nbsp;(in the form of a type annotation).</span></p></div>

<div class="c" id="calibre_link-45">
<h2 class="c21" id="calibre_link-209"><span class="c2">Algorithmic Details</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The details of this algorithm&mdash;called </span><span class="c6">Hindley-Milner inference</span><span class="calibre3">&mdash;are fascinating, and worked out in detail in both the first and second editions of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://www.plai.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021443495&amp;usg=AOvVaw1Jv2eQapvZVGeMGKdx7dFB">this book, PLAI</a></span><span class="c2">&nbsp;(Chapter 30 in the first edition and Chapter 15.3.2 in the second edition). For several worked examples of both constraint generation and constraint solving, refer to the first edition. The first edition has a more algorithmic presentation, while the second provides code (it may be useful to compare the two). The prose in the second is different from that in the first, so different readers may prefer one over the other.</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-303">
<h1 class="c20" id="calibre_link-74"><span class="c2">Algebraic Datatypes</span></h1><p class="c4"><span class="calibre3">We have written numerous </span><span class="c25">define-type</span><span class="c2">&nbsp;definitions so far, e.g., for expressions. Now we will study this mechanism, which is increasingly found in many new programming languages, in more detail.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To simplify things, consider a simple plait data definition of a binary tree of numbers:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type BT</span></p><p class="c4"><span class="c34">&nbsp; [mt]</span></p><p class="c4"><span class="c25">&nbsp; [node (v : Number) (l : BT) (r : BT)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The </span><span class="c25">define-type</span><span class="c2">&nbsp;construct here is doing three different things, and it’s worth teasing them apart:</span></p><p class="c3"><span class="c2"></span></p><ol class="c94" start="1"><li class="pcalibre24 pcalibre25"><span class="calibre3">Giving a </span><span class="c6">name</span><span class="calibre3">&nbsp;to a new type, </span><span class="c25">BT</span><span class="c2">.</span></li><li class="pcalibre24 pcalibre25"><span class="calibre3">Allowing the type to be defined by multiple cases or </span><span class="c6">variants</span><span class="calibre3">&nbsp;(</span><span class="c25">mt</span><span class="calibre3">&nbsp;and </span><span class="c25">node</span><span class="c2">).</span></li><li class="pcalibre24 pcalibre25"><span class="calibre3">Permitting a </span><span class="c6">recursive</span><span class="calibre3">&nbsp;definition (</span><span class="c25">BT</span><span class="calibre3">&nbsp;references </span><span class="c25">BT</span><span class="c2">).</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It’s worth asking whether all these pieces of functionality really have to be bundled together, or whether they can be handled separately. While they can indeed be separated, they often end up working in concert, especially when it comes to recursive definitions, which are quite common. A recursive definition needs a name for creating the recursion; therefore, the third feature requires the first. Furthermore, a recursive definition often needs a non-recursive case to “bottom out”; this requires there to be more than one variant, using the second feature. Putting the three together, therefore, makes a lot of sense.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This construct is called an </span><span class="c6">algebraic datatype</span><span class="calibre3">, sometimes also known as a “sum of products”. That is because the variants are read as an “or”: a </span><span class="c25">BT</span><span class="calibre3">&nbsp;is an </span><span class="c25">mt</span><span class="calibre3">&nbsp;</span><span class="c6">or</span><span class="calibre3">&nbsp;a </span><span class="c25">node</span><span class="calibre3">. Each variant is an “and” of its fields: a node has a </span><span class="c25">v</span><span class="calibre3">&nbsp;</span><span class="c6">and</span><span class="calibre3">&nbsp;an </span><span class="c25">l</span><span class="calibre3">&nbsp;</span><span class="c6">and</span><span class="calibre3">&nbsp;an </span><span class="c25">r</span><span class="c2">. In Boolean algebra, “or” is analogous to a sum and “and” is analogous to a product.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Sometimes, you will also see this referred to as a </span><span class="c6">tagged union</span><span class="calibre3">. The word “union” is because we can conceptually think of a </span><span class="c25">BT</span><span class="calibre3">&nbsp;as a union of </span><span class="c25">mt</span><span class="calibre3">s and </span><span class="c25">node</span><span class="calibre3">s. The tag is the constructor. This term makes more sense once we compare it against “untagged” union types [</span><span class="c15"><a class="c10" href="#calibre_link-214">👉</a></span><span class="c2">].</span></p></div>

<div class="c" id="calibre_link-30">
<h2 class="c21" id="calibre_link-210"><span class="c2">Generated Bindings</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now the question is, how do we type code that uses such a definition? First, let’s take an inventory of all the definitions that this might create. It at least creates two </span><span class="c6">constructors</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(mt : ( -&gt; BT))</span></p><p class="c4"><span class="c34">(node : (Number BT BT -&gt; BT))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We have been starting our interpretation and type-checking with the empty environment, but there is no reason we need to, nor do we do so in practice: the primordial environment can contain all kinds of pre-defined values and their types. Thus, we can imagine the </span><span class="c25">define-type</span><span class="calibre3">&nbsp;above adding the above two definitions to the initial type environment, enabling uses of </span><span class="c25">mt</span><span class="calibre3">&nbsp;and </span><span class="c25">node</span><span class="c2">&nbsp;to be type-checked.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This much is standard across various languages. But less commonly, in plait you get two more families of functions: </span><span class="c6">predicates</span><span class="c2">&nbsp;for distinguishing between the variants:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(mt? : (BT -&gt; Boolean))</span></p><p class="c4"><span class="c34">(node? : (BT -&gt; Boolean))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and </span><span class="c6">accessors</span><span class="c2">&nbsp;for getting the values out of fields:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(node-v : (BT -&gt; Number))</span></p><p class="c4"><span class="c34">(node-l : (BT -&gt; BT))</span></p><p class="c4"><span class="c25">(node-r : (BT -&gt; BT))</span></p></div>

<div class="c" id="calibre_link-312">
<h2 class="c21" id="calibre_link-211"><span class="c2">Static Type Safety</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We should be troubled by the types of these accessors. They seem to indiscriminately try to pull out field values, </span><span class="c6">whether the variant has them or not</span><span class="c2">. For instance, we can write and type-check this program, which is appealing:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(size-correct : (BT -&gt; Number))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (size-correct (t : BT))</span></p><p class="c4"><span class="c34">&nbsp; (if (mt? t)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 0</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (+ 1 (+ (size-correct (node-l t)) (size-correct (node-r t))))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(test (size-correct (mt)) 0)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">However, we can just as well type-check </span><span class="c6">this</span><span class="c2">&nbsp;program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-wrong (t : BT))</span></p><p class="c4"><span class="c34">&nbsp; (+ 1 (+ (size-wrong (node-l t)) (size-wrong (node-r t)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This should not type-check because it has a clear type-error. The type of </span><span class="c25">size-wrong</span><span class="c2">&nbsp;is</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(size-wrong : (BT -&gt; Number))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">so it is perfectly type-correct to write:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(size-wrong (mt))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But running this, of course, results in a run-time error, the very kind of error we might have hoped the type-checker would catch.</span></p></div>

<div class="c" id="calibre_link-309">
<h2 class="c21" id="calibre_link-212"><span class="c2">Pattern-Matching and Type-Checking</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This kind of error cannot occur naturally in languages like OCaml and Haskell. Instead of exposing all these predicates and accessors, instances of an algebraic datatype are deconstructed using pattern-matching. Thus, the size computation would be written as (</span><span class="c25">-pm</span><span class="c2">&nbsp;stands for “pattern matching”):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(size-pm : (BT -&gt; Number))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-pm t)</span></p><p class="c4"><span class="c34">&nbsp; (type-case BT t</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(mt) 0]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(node v l r) (+ 1 (+ (size-pm l) (size-pm r)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This might seem like a convenience&mdash;it certainly makes the code much more compact and perhaps also much more readable&mdash;but it’s also doing something more. The pattern-matcher is effectively baked into the way programs are type-checked. That is, the above algebraic datatype definition effectively adds the following typing rule to the type checker:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- e : </span><span class="c78">BT</span></p><p class="c4"><span class="c95">Γ</span><span class="c84">&nbsp;</span><span class="c25">|- e1 : </span><span class="c96">T</span></p><p class="c4"><span class="c84">Γ</span><span class="c97">[V &lt;- Number, L &lt;- BT, R &lt;- BT]</span><span class="c84">&nbsp;</span><span class="c25">|- e2 : </span><span class="c96">T</span></p><p class="c4"><span class="c34">-----------------------------------------</span></p><p class="c4"><span class="c95">Γ</span><span class="c84">&nbsp;</span><span class="c34">|- (type-case BT e</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;[(mt) e1]</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp;[(node V L R) e2]) : T</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The first antecedent is clear: we have to confirm that the expression </span><span class="c25">e</span><span class="calibre3">&nbsp;evaluates to a </span><span class="c77">BT</span><span class="calibre3">&nbsp;before we pattern-match </span><span class="c25">BT</span><span class="calibre3">&nbsp;patterns against it. The second type-checks </span><span class="c25">e1</span><span class="calibre3">&nbsp;in the </span><span class="c98">same</span><span class="calibre3">&nbsp;environment as in the consequent because the </span><span class="c25">mt</span><span class="calibre3">&nbsp;variant does not add any local bindings. The type of this expression needs to be the </span><span class="c99">same</span><span class="calibre3">&nbsp;as the type from the other branch, due to how we’re handling conditionals. Finally, to type-check </span><span class="c25">e2</span><span class="calibre3">, we have to </span><span class="c100">extend</span><span class="calibre3">&nbsp;the consequent’s type environment with the bound variables; their types we can read off directly from the data </span><span class="c6">definition</span><span class="c2">. In short, the above typing rule can be defined automatically by desugaring.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;Notice that there is also an assume-guarantee here: we type-check </span><span class="c25">e2</span><span class="calibre3">&nbsp;in an environment that </span><span class="c6">assumes</span><span class="calibre3">&nbsp;the annotated types; this is </span><span class="c6">guaranteed</span><span class="calibre3">&nbsp;by the </span><span class="c25">node</span><span class="c2">&nbsp;constructor.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In particular, observe what we </span><span class="c6">couldn’t</span><span class="calibre3">&nbsp;do! We didn’t have awkward selectors, like </span><span class="c25">node-v</span><span class="calibre3">, for which we had to come up with some type. By saying they consumed a </span><span class="c25">BT</span><span class="calibre3">, we had to let them statically consume any kind of </span><span class="c25">BT</span><span class="calibre3">, which caused a problem at run-time. Here, there is </span><span class="c6">no selector</span><span class="calibre3">: pattern-matching means we can only write pattern-variables in variants where the algebraic datatype definition permits it, and the variables automatically gets the right type. Thus, pattern-matching plays a crucial role in the </span><span class="c6">statically safe</span><span class="c2">&nbsp;handling of types.</span></p></div>

<div class="c" id="calibre_link-354">
<h2 class="c21" id="calibre_link-213"><span class="c2">Algebraic Datatypes and Space</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Earlier, we’ve seen that types can save us both time and space. We have to be a little more nuanced when it comes to algebraic datatypes.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The new type introduced by an algebraic datatype still enjoys the space saving. Because the type checker can tell a </span><span class="c25">BT</span><span class="calibre3">&nbsp;apart from every other type, at run-time we don’t need to record that a value is a </span><span class="c25">BT</span><span class="calibre3">: it doesn’t need a type-tag. However, we still need to tell apart the different </span><span class="c6">variants</span><span class="calibre3">: the function </span><span class="c25">size-pm</span><span class="calibre3">&nbsp;effectively desugars into (</span><span class="c25">-ds</span><span class="c2">&nbsp;stands for “desugared”):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-pm-ds (t : BT))</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(mt? t) 0]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(node? t)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(let ([v (node-v t)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[l (node-l t)]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[r (node-r t)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(+ 1 (+ (size-pm-ds l) (size-pm-ds r))))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(We’ve introduced the </span><span class="c25">let</span><span class="calibre3">&nbsp;to bind the names introduced by the pattern.) What this shows is that at run-time, there are conditional checks that need to know what kind of </span><span class="c25">BT</span><span class="calibre3">&nbsp;is bound to </span><span class="c25">t</span><span class="c2">&nbsp;on this iteration. Therefore, we need just enough tagging to tell the variants apart. In practice, this means we need as many bits as the logarithm of the number of variants; since this number is usually small, this information can often be squeezed into other parts of the data representation.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-319">
<h1 class="c20" id="calibre_link-214"><span class="c2">Union Types and Retrofitted Types</span></h1><p class="c4"><span class="calibre3">Typed Racket is an instance of a </span><span class="c6">retrofitted</span><span class="calibre3">&nbsp;type system: adding a type system to a language that did not previously have types. The original language, which does not have a static type system, is usually called </span><span class="c6">dynamic</span><span class="c2">. There are now numerous retrofitted type systems: e.g., TypeScript for JavaScript and Static Python for Python. There are even multiple retrofitted type systems for some languages: e.g., both TypeScript and Flow add types to JavaScript.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The goal of a retrofitted type system is to turn run-time errors into static type errors. Due to the Halting Problem, we cannot precisely turn every single run-time error into a static one, so the designer of the type system must make some decisions about which errors matter more than others. In addition, programmers have already written considerable code in many dynamic languages, so changes that require programmers to rewrite code significantly would not be adopted. Instead, as much as possible, type system designers need to accommodate </span><span class="c6">idiomatic type-safe programs</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Algebraic datatypes present a good example. Typically, they have tended to not be found in dynamic languages. Instead, these languages have some kind of structure definition mechanism (such as classes, or lightweight variants thereof, like Python’s </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://docs.python.org/3/library/dataclasses.html&amp;sa=D&amp;source=editors&amp;ust=1695232021455665&amp;usg=AOvVaw2l-qHVAvQWW6klXtg2zXhU">dataclasses</a></span><span class="c2">). Therefore, the elegant typing that goes with algebraic datatypes and their pattern-matching does not apply. Because it is not practical to force dynamic language programmers to wholesale change to this “new” (to that dynamic language) style of programming, type system designers must find the idioms they use (that happen to be type-safe) and try to bless them. We will look at some examples of this.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">A good working example of a retrofitted typed language is Typed Racket, which adds types to Racket while trying to preserve idiomatic Racket programs. (This is in contrast to plait, which is also a typed form of Racket but does </span><span class="c6">not</span><span class="calibre3">&nbsp;try very hard to preserve Racket idioms. The accessors we saw earlier, for algebraic datatypes [</span><span class="c15"><a class="c10" href="#calibre_link-74">👉</a></span><span class="c2">], are forgiving in what they accept, at the cost of static safety.)</span></p></div>

<div class="c" id="calibre_link-73">
<h2 class="c21" id="calibre_link-215"><span class="c2">You Get a Type! And You Get a Type! And You Get a Type!</span></h2><p class="c4"><span class="calibre3">Let’s return [</span><span class="c15"><a class="c10" href="#calibre_link-74">👉</a></span><span class="c2">] to our non-statically-type-safe accessors in plait: e.g.,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(node-v : (BT -&gt; Number))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In a way, it’s not fair to blame the accessor: the fault is really with the constructor, because</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(node : (Number BT BT -&gt; BT))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Once the </span><span class="c25">node</span><span class="calibre3">&nbsp;constructor creates a </span><span class="c25">BT</span><span class="calibre3">, the information about </span><span class="c25">node</span><span class="calibre3">-ness is lost, and there’s not much that the accessors can do. So perhaps the alternative is to </span><span class="c6">not</span><span class="calibre3">&nbsp;create a </span><span class="c25">BT</span><span class="calibre3">, but instead create a value of the </span><span class="c25">node</span><span class="c2">&nbsp;type.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So let’s start over. This time, we’ll use a different typed language, Typed Racket:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang typed/racket</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In Typed Racket, we can create products, called structures, which define a new type:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(struct mt ())</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This creates a constructor with the type we’d expect:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; mt</span></p><p class="c4"><span class="c34">- : (-&gt; mt)</span></p><p class="c4"><span class="c34">#&lt;procedure:mt&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It also creates a predicate, whose type is a bit different; previously we had a function that could only take a </span><span class="c25">BT</span><span class="calibre3">, because it didn’t make sense to apply </span><span class="c25">mt?</span><span class="calibre3">&nbsp;to any other type. Now, however, there isn’t even a concept of a </span><span class="c25">BT</span><span class="calibre3">&nbsp;(yet), so </span><span class="c25">mt?</span><span class="c2">&nbsp;will take values of any type:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; mt?</span></p><p class="c4"><span class="c34">- : (-&gt; Any Boolean : mt)</span></p><p class="c4"><span class="c34">#&lt;procedure:mt?&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(The additional text, </span><span class="c25">: mt</span><span class="c2">, is telling us when the Boolean is true; ignore this for now.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s try to define nodes. Here we run into a problem:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(struct node ([v : Number] [l : </span></p></div>

<div class="c" id="calibre_link-296">
<h2 class="c21" id="calibre_link-216"><span class="c2">Union Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Oops&mdash;what do we write here?!? We have to also introduce a notion of a binary tree. But we already have two existing types, </span><span class="c25">mt</span><span class="calibre3">&nbsp;and (in progress) </span><span class="c25">node</span><span class="calibre3">. Therefore, we need a way to define a binary tree that has a sum that combines these two existing types. This suggests that we have a way of describing a new type as a </span><span class="c6">union</span><span class="c2">&nbsp;of existing types:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type-alias BT (U mt node))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that in this case, there are no special constructors to distinguish between the two kinds of BT. Therefore, this is called an </span><span class="c6">untagged union</span><span class="calibre3">, in contrast to tagged unions [</span><span class="c15"><a class="c10" href="#calibre_link-74">👉</a></span><span class="c2">].</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we can go back and complete our definition of </span><span class="c25">node</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(struct node ([v : Number] [l : BT] [r : BT]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s look at what Typed Racket tells us are the types of </span><span class="c25">node</span><span class="c2">’s constructor, predicate, and selectors:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; node</span></p><p class="c4"><span class="c34">- : (-&gt; Number BT BT node)</span></p><p class="c4"><span class="c34">&gt; node-v</span></p><p class="c4"><span class="c34">- : (-&gt; node Number)</span></p><p class="c4"><span class="c34">&gt; node-l</span></p><p class="c4"><span class="c34">- : (-&gt; node BT)</span></p><p class="c4"><span class="c34">&gt; node-r</span></p><p class="c4"><span class="c34">- : (-&gt; node BT)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Using these definitions we can create trees: e.g.,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define t1</span></p><p class="c4"><span class="c34">&nbsp; (node 5</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (node 3</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node 1 (mt) (mt))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mt))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (node 7</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (mt)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (node 9 (mt) (mt)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But now let’s try to write a program to compute its size:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-tr [t : BT]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(mt? t) 0]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(node? t) (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It is not clear at all that this program should type-check. Consider the expression </span><span class="c25">(node-l t)</span><span class="calibre3">. The type of </span><span class="c25">node-l</span><span class="calibre3">&nbsp;expects its argument to be of type </span><span class="c25">node</span><span class="calibre3">. However, all we know is that </span><span class="c25">t</span><span class="calibre3">&nbsp;is of type </span><span class="c25">BT</span><span class="c2">. Yet this program type-checks!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The fact that this does type-check, however, should not fill us with too much joy. We saw how </span><span class="c25">size-wrong</span><span class="c2">&nbsp;type-checked, only to halt with an undesired run-time error. So what if we instead write its analog, which is this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-tr-wrong [t : BT]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (+ 1 (size (node-l t)) (size (node-r t))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">This program does </span><span class="c33">not</span><span class="calibre3">&nbsp;type-check! Instead, it gives us a type error of exactly the sort we would have expected: </span><span class="c25">node-l</span><span class="calibre3">&nbsp;and </span><span class="c25">node-r</span><span class="calibre3">&nbsp;both complain that they were expecting an </span><span class="c25">node</span><span class="calibre3">&nbsp;and were given a </span><span class="c25">BT</span><span class="calibre3">. So the wonder is not that </span><span class="c25">size-tr-wrong</span><span class="calibre3">&nbsp;has a type-error, but rather that </span><span class="c25">size-tr</span><span class="c2">&nbsp;does not!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To understand why it type-checks, we have to go back to the types of the predicates:</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&gt; mt?</span></p><p class="c4"><span class="c34">- : (-&gt; Any Boolean : mt)</span></p><p class="c4"><span class="c34">&gt; node?</span></p><p class="c4"><span class="c34">- : (-&gt; Any Boolean : node)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">Critically, the </span><span class="c25">: mt</span><span class="calibre3">&nbsp;and </span><span class="c25">: node</span><span class="calibre3">&nbsp;are Typed Racket’s way of saying that the Boolean will be true only when the input is an </span><span class="c25">mt</span><span class="calibre3">&nbsp;or </span><span class="c25">node</span><span class="calibre3">, respectively. This crucial </span><span class="c6">refinement</span><span class="calibre3">&nbsp;information is picked up by the type-checker. In the right-hand-side of the </span><span class="c25">cond</span><span class="calibre3">&nbsp;clauses, it </span><span class="c6">narrows</span><span class="calibre3">&nbsp;the type of </span><span class="c25">t</span><span class="calibre3">&nbsp;to be </span><span class="c25">mt</span><span class="calibre3">&nbsp;and </span><span class="c25">node</span><span class="calibre3">, respectively. Thus, </span><span class="c25">(node-l t)</span><span class="calibre3">&nbsp;is type-checked in a type environment where the type of </span><span class="c25">t</span><span class="calibre3">&nbsp;is </span><span class="c25">node</span><span class="calibre3">&nbsp;and not </span><span class="c25">BT</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To test this theory, we can try another wrong program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-tr-w2 [t : BT]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(node? t) 0]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(mt? t) (+ 1 (size-tr-w2 (node-l t)) (size-tr-w2 (node-r t)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here, we have swapped the predicates. It is not only important that this version produces a type error, it is also instructive to understand why, by reading the type error. This explicitly says that the program expected an </span><span class="c25">node</span><span class="calibre3">&nbsp;(for instance, in </span><span class="c25">node-l</span><span class="calibre3">) and was given an </span><span class="c25">mt</span><span class="calibre3">&nbsp;(based on the </span><span class="c25">mt?</span><span class="c2">). This confirms that Typed Racket is refining the types in branches based on predicates.</span></p></div>

<div class="c" id="calibre_link-304">
<h2 class="c21" id="calibre_link-217"><span class="c2">If-Splitting</span></h2><p class="c4"><span class="calibre3">To summarize, </span><span class="c25">size-tr</span><span class="c2">&nbsp;type-checks is because the type-checker is doing something special when it sees the pattern</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-tr [t : BT]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(mt? t) …]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(node? t) …]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It knows that every </span><span class="c25">BT</span><span class="calibre3">&nbsp;is related to </span><span class="c25">mt</span><span class="calibre3">&nbsp;and </span><span class="c25">node</span><span class="calibre3">&nbsp;through the union. When it sees the predicate, it </span><span class="c6">narrows</span><span class="calibre3">&nbsp;the type from the full union to the branch of the union that the predicate has checked. Thus, in the </span><span class="c25">mt?</span><span class="calibre3">&nbsp;branch, it narrows the type of </span><span class="c25">t</span><span class="calibre3">&nbsp;from </span><span class="c25">BT</span><span class="calibre3">&nbsp;to </span><span class="c25">mt</span><span class="calibre3">; in the </span><span class="c25">node?</span><span class="calibre3">&nbsp;branch, similarly, it narrows the type of </span><span class="c25">t</span><span class="calibre3">&nbsp;to just </span><span class="c25">node</span><span class="calibre3">. Now, </span><span class="c25">node-l</span><span class="calibre3">, say, gets confirmation that it is indeed processing a </span><span class="c25">node</span><span class="calibre3">&nbsp;value, and the program is statically type-safe. In the absence of those predicates, in </span><span class="c25">size-tr-wrong</span><span class="calibre3">, the type of </span><span class="c25">t</span><span class="calibre3">&nbsp;does not get narrowed, resulting in the error. In </span><span class="c25">size-tr-w2</span><span class="c2">, swapping the predicates also gives an error. Here is one more version:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (size-tr-else [t : BT]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (cond</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [(mt? t) 0]</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; [else (+ 1 (size-tr (node-l t)) (size-tr (node-r t)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This program could go either way! It just so happens that it does type-check in typed/racket, because typed/racket is “smart” enough to determine that there are only two kinds of </span><span class="c25">BT</span><span class="calibre3">&nbsp;and one has been excluded, so in the </span><span class="c25">else</span><span class="calibre3">&nbsp;case, it must be the other kind. But one could also imagine a less clever checker that expects to see an explicit test of </span><span class="c25">node?</span><span class="c2">&nbsp;to be able to bless the second clause.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In short, both the algebraic datatype and union type approaches need some special treatment of syntax by the type-checker to handle variants. In the former case it’s through pattern-matching. The narrowing technique above is sometimes called </span><span class="c6">if-splitting</span><span class="calibre3">, because an </span><span class="c25">if</span><span class="calibre3">&nbsp;(which </span><span class="c25">cond</span><span class="calibre3">&nbsp;and other conditional constructs desugar to) “splits” the union. You will sometimes also see the terms </span><span class="c6">occurrence typing</span><span class="calibre3">&nbsp;and </span><span class="c6">flow typing</span><span class="c2">&nbsp;to describe variants of the ideas in this chapter.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;This idea was invented by </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://docs.racket-lang.org/ts-guide/occurrence-typing.html&amp;sa=D&amp;source=editors&amp;ust=1695232021469775&amp;usg=AOvVaw0FOrR34cG9UC9PeiZoFxr8">Typed Racket</a></span><span class="c2">&nbsp;by studying how programmers write code in Scheme and Racket programs. It has later proved to be relevant to many real-world retrofitted type systems.</span></p></div>

<div class="c" id="calibre_link-305">
<h2 class="c21" id="calibre_link-218"><span class="c2">Introducing Union Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">As we discussed when evaluating conditionals [</span><span class="c15"><a class="c10" href="#calibre_link-17">👉</a></span><span class="c2">], union types can be useful to represent partial functions. There are several ways of handling them:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/partial-domains.html&amp;sa=D&amp;source=editors&amp;ust=1695232021470794&amp;usg=AOvVaw0tfeqewvVEB-EA9H442jKE">https://dcic-world.org/2022-08-28/partial-domains.html</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Using an option type avoids the need for ad-hoc type unions. If we have unions anyway, however, then we can give types to partial functions: e.g., </span><span class="c25">(V U Boolean)</span><span class="calibre3">&nbsp;in Racket or </span><span class="c25">(V U None)</span><span class="calibre3">&nbsp;in Python, respectively, where </span><span class="c25">V</span><span class="calibre3">&nbsp;is the normal return type. Thus, Racket’s </span><span class="c25">string-&gt;number</span><span class="calibre3">&nbsp;can be given the type </span><span class="c25">(Number U Boolean)</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What we’ve just seen is that with if-splitting, we can eliminate union types. That then raises the possibility that we can also introduce union types! One way is of course by giving union types to built-in functions, as above. But what about in user programs? Previously we had rejected such a solution: if we introduced a union, we had no way to deal with it. Now we can safely introduce them in languages that have solutions for deconstructing them.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">How do we introduce union types? Curiously, using the same construct that eliminates them! Observe that we no longer need both branches of a conditional to return the same type:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- C : Bool &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c25">|- T : V &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c34">|- E : W</span></p><p class="c4"><span class="c34">-----------------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (if C T E) : (U V W)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where our notation means “the union of the types represented by </span><span class="c25">V</span><span class="calibre3">&nbsp;and </span><span class="c25">W</span><span class="c2">”.</span></p></div>

<div class="c" id="calibre_link-31">
<h2 class="c21" id="calibre_link-219"><span class="c2">How Many Unions?</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">When we wrote an algebraic datatype, the variants “belonged” to the new type. We had no mechanism for mixing-and-matching variants.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In contrast, with union types, a new type is a collection of existing types. There’s nothing that prevents those existing types from engaging in several different unions. For instance, we had</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type-alias BT (U mt node))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But we could also write, say,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(struct link ((v : Number) (r : LinkedList)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and reusing mt to define</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type-alias LinkedList (U mt link))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Therefore, given an mt, what “is” it? Is it a </span><span class="c25">BT</span><span class="calibre3">? A </span><span class="c25">LinkedList</span><span class="calibre3">? It’s all those, but it’s also just an </span><span class="c25">mt</span><span class="calibre3">, which can participate in any number of unions. This provides a degree of flexibility that we don’t get with algebraic datatypes&mdash;since we can create ad-hoc unions of existing types&mdash;but that also means it becomes harder to tell all the ways a value might be used, and also complicates inferring types (if we see an </span><span class="c25">mt</span><span class="calibre3">&nbsp;constructed, are we also constructing a </span><span class="c25">BT</span><span class="calibre3">? a </span><span class="c25">LinkedList</span><span class="calibre3">?). The Hindley-Milner inference algorithm [</span><span class="c15"><a class="c10" href="#calibre_link-32">👉</a></span><span class="c2">] doesn’t cover these cases, though it can be extended to do so.</span></p></div>

<div class="c" id="calibre_link-19">
<h2 class="c21" id="calibre_link-220"><span class="c2">Union Types and Space</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Therefore, union types combined with if-splitting gives us an alternate approach of obtaining something akin to algebraic datatypes in our programming language. However, we don’t obtain the space benefits of the algebraic datatype definition. We created two distinct types; in principle, that’s not a problem. However, to write programs, we needed to have predicates (</span><span class="c25">mt?</span><span class="calibre3">&nbsp;and </span><span class="c25">node?</span><span class="calibre3">) that took </span><span class="c6">any</span><span class="calibre3">&nbsp;value. Therefore, those predicates need type-tags on the values to be able to tell what kind of value they are looking at. Observe that these are </span><span class="c6">type</span><span class="calibre3">&nbsp;tags, not </span><span class="c6">variant</span><span class="c2">&nbsp;tags, so the amount of space they need is proportional to the number of types in the whole program, not just the number of variants in that particular algebraic datatype definition.</span></p></div>

<div class="c" id="calibre_link-357">
<h2 class="c21" id="calibre_link-221"><span class="c2">If-Splitting with Control Flow</span></h2><p class="c4"><span class="c2">This pattern, of dispatching based on type-tests and values, is quite common in dynamic (or “scripting”) languages. These languages do not have a static type system, but they do have safe run-times, which attach type tags to values and provide predicates that can check them. Programmers then adopt programming patterns that take advantage of this.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;The term </span><span class="c6">dynamic</span><span class="calibre3">&nbsp;language seems to have no clear fixed definition. It means, at least, that the language doesn't have static types. Sometimes it's implicit that the language is nevertheless safe. But some people use it to mean that the language has features that let you do things like inspect or even modify the program as it's running (features like </span><span class="c25">eval</span><span class="c2">). In this book I use it in the second sense: not-statically typed, but still safe.</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;What, then, is a “scripting” language? I use the term to mean a dynamic language that is also very liberal with its types: e.g., many operations are either overloaded and/or very forgiving of what a statically-typed language would consider an error. Scripting languages tend to be dynamic in all three senses: they do not have a static type-system, they are safe, and they tend to have rich features for introspection and even modification. They are designed to maximize expressiveness and thus minimize just about any useful static analysis.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">For instance, here’s an example from JavaScript, of a serialization function. A serializer takes a value of (almost) </span><span class="c6">any</span><span class="c2">&nbsp;type and converts it into a string to be stored or transmitted. (This version is adapted from version 1.6.1 of Prototype.js.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3"></span><span class="c34">function serialize(val) {</span></p><p class="c4"><span class="c34">&nbsp; switch (typeof val) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; case "undefined":</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; case "function": </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; return false;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; case "boolean":</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; return val ? "true" :</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"false";</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; case "number":</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; return "" + val;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; case "string":</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; return val;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; if (val === null)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; { return "null"; } </span></p><p class="c4"><span class="c34">&nbsp; </span></p><p class="c4"><span class="c34">&nbsp; var fields = [ ];</span></p><p class="c4"><span class="c34">&nbsp; for (var p in val) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; var v = serialize(val[p]);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; if (typeof v === "string") {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; fields.push(p + ": " + v);</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; return "{ " + </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fields.join(", ") + </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;" }";</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now suppose we’re trying to retrofit a type system onto JavaScript. We would need to type-check such programs. But before we even ask </span><span class="c6">how</span><span class="c2">&nbsp;to do it, we should know what answer to expect: i.e., is this program even type-safe?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The answer is quite subtle. It uses JavaScript’s </span><span class="c25">typeof</span><span class="calibre3">&nbsp;operator to check the tags. For two kinds of values, it returns </span><span class="c25">false</span><span class="calibre3">&nbsp;(that is, the type of this function is not </span><span class="c25">Any -&gt; String</span><span class="calibre3">, it’s actually </span><span class="c25">Any -&gt; (String U Boolean)</span><span class="calibre3">, where the </span><span class="c25">false</span><span class="calibre3">&nbsp;value is used to signal that the value can’t be serialized&mdash;observe that an actual </span><span class="c25">false</span><span class="calibre3">&nbsp;value is serialized to </span><span class="c25">"false"</span><span class="calibre3">). For Booleans, numbers, and strings, it translates them appropriately into strings. In all these cases, execution returns. (Note, however, that the code also exploits JavaScript’s “fall-through” behavior in </span><span class="c25">switch</span><span class="calibre3">, so that </span><span class="c25">"undefined"</span><span class="calibre3">&nbsp;and </span><span class="c25">"function"</span><span class="c2">&nbsp;are treated the same without having to repeat code. The type-checker needs to understand this part of JavaScript semantics.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If none of these cases apply, then execution falls through; we need to know enough JavaScript to know that this corresponds to the one other return from </span><span class="c25">typeof</span><span class="calibre3">, namely objects. Now the code splits between objects that are and aren’t </span><span class="c25">null</span><span class="calibre3">. In the non-</span><span class="c25">null</span><span class="c2">&nbsp;case, it iterates through each field, serializing it in turn. Therefore, this program is actually type-safe…but for very complicated reasons!</span></p></div>

<div class="c" id="calibre_link-320">
<h2 class="c21" id="calibre_link-222"><span class="c2">If-Splitting with Control Flow and State</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here’s another program, taken from the Python 2.5.2 standard library:</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">def insort_right(a, x, lo=0, hi=None):</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; if hi is None:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; hi = len(a)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; while lo &lt; hi:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; mid = (lo+hi)//2</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; if x &lt; a[mid]: hi = mid</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; else: lo = mid+1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; a.insert(lo, x)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This function inserts an element (</span><span class="c25">x</span><span class="calibre3">) into an already-sorted list (</span><span class="c25">a</span><span class="calibre3">). It also takes a low search interval index (</span><span class="c25">lo</span><span class="calibre3">), which defaults to </span><span class="c25">0</span><span class="calibre3">, and a high interval (</span><span class="c25">hi</span><span class="calibre3">), which defaults to </span><span class="c25">None</span><span class="c2">. It inserts the element into the right place in the array.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s ask whether this is actually type-correct. Observe that </span><span class="c25">lo</span><span class="calibre3">&nbsp;and </span><span class="c25">hi</span><span class="c2">&nbsp;are used in several arithmetic operations. These are the ones we’re most interested in.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If it helps, here’s the code with type annotations in </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://github.com/facebookincubator/cinder&amp;sa=D&amp;source=editors&amp;ust=1695232021481698&amp;usg=AOvVaw2pIqSg2CpkTCGrPRBDemlf">Static Python</a></span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">from typing import Optional</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">def insort_right(a, x, lo: int = 0, hi: Optional[int] = None):</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; if hi is None:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; hi = len(a)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; while lo &lt; hi:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; mid = (lo+hi)//2</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; if x &lt; a[mid]:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hi = mid</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; else:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo = mid+1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; a.insert(lo, x)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(In Static Python, </span><span class="c25">Optional[T]</span><span class="calibre3">&nbsp;is an abbreviation for </span><span class="c25">(T U None)</span><span class="calibre3">. So the annotation on </span><span class="c25">hi</span><span class="calibre3">&nbsp;above allows the user to pass in either an </span><span class="c25">int</span><span class="calibre3">&nbsp;or </span><span class="c25">None</span><span class="calibre3">. What makes the last two arguments optional is (perhaps confusingly) not the type </span><span class="c25">Optional</span><span class="c2">&nbsp;but rather the fact that they have default values in the function header.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It’s easier to see what’s happening with </span><span class="c25">lo</span><span class="calibre3">: it’s allowed to be optional; if the optional argument is provided, it must be an </span><span class="c25">int</span><span class="calibre3">; and if it’s not provided, it has value </span><span class="c25">0</span><span class="calibre3">, which also has type </span><span class="c25">int</span><span class="calibre3">. So its type is effectively </span><span class="c25">(int U int)</span><span class="calibre3">, which is just </span><span class="c25">int</span><span class="calibre3">, so all uses of </span><span class="c25">lo</span><span class="calibre3">&nbsp;as an </span><span class="c25">int</span><span class="c2">&nbsp;are fine.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But now consider the type of </span><span class="c25">hi</span><span class="calibre3">. It is also optional. If it is provided, it has to be an </span><span class="c25">int</span><span class="calibre3">, which would be fine. But if it’s </span><span class="c6">not</span><span class="calibre3">&nbsp;provided, its value is </span><span class="c25">None</span><span class="calibre3">, which cannot be used in arithmetic. However, right at the top, the function checks whether it is </span><span class="c25">None</span><span class="calibre3">&nbsp;and, if so, </span><span class="c6">changes</span><span class="calibre3">&nbsp;it to the result of </span><span class="c25">len(a)</span><span class="calibre3">&mdash;which is an </span><span class="c25">int</span><span class="calibre3">. Therefore, once the if is done, no matter which path the program takes, </span><span class="c25">hi</span><span class="calibre3">&nbsp;is an </span><span class="c25">int</span><span class="c2">. Thus, the program is actually type-safe.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That’s all well and good for us to reason about by hand. However, our job is to build a type-checker that will neither reject programs needlessly nor approve type-incorrect programs. This balance is very hard to maintain.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This represents the challenge retrofitted type system designers face: they must either reject idiomatic programs or add complexity to the type system to handle them. If we reject the program, we reject many other programs like it, which are idiomatically found in many “scripting” languages. The result would be very safe, but also very useless&mdash;indeed, safe </span><span class="c6">because</span><span class="c2">&nbsp;it would be very useless&mdash;type-checker (a type-checker that rejects every program would be extremely safe…). Instead, we need an even more complicated solution than what we have seen until now.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;See </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/people/sk/Publications/Papers/Published/gsk-flow-typing-theory/&amp;sa=D&amp;source=editors&amp;ust=1695232021485488&amp;usg=AOvVaw2-6nKeOUE7cQ6F3KqzAJ7z">this paper</a></span><span class="calibre3">&nbsp;for how to type such programs.</span></p></div>

<div class="c" id="calibre_link-306">
<h2 class="c21" id="calibre_link-223"><span class="c2">The Price of Retrofitting</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Retrofitting a type-system onto an existing untyped language clearly puts a heavy burden on the creator of the type system. But it also puts a burden on developers. If the type system is to not reject a bunch of existing code, then it must be based on some heuristics about program structure. The more complex these heuristics grow (as we’ve seen hints of in this chapter), the stranger it will be when a program falls outside what they can handle.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">You might argue that it was ever thus: when type-checking algebraic datatypes, too, we had to use pattern-matching to help the type-checker. The difference there is that the type-checker was around at program </span><span class="c6">construction</span><span class="c2">&nbsp;time, so we adhered to its rules from the very start; we didn’t try to add types after the fact. The problem arises when programmers are allowed to write code however they like, and the type-checker must retroactively try to bless them.</span></p></div>

<div class="c" id="calibre_link-39">
<h2 class="c21" id="calibre_link-224"><span class="c2">Types and Tags</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, we should clarify something important about the </span><span class="c25">typeof</span><span class="calibre3">&nbsp;operator in JavaScript, which is analogous to the </span><span class="c25">type</span><span class="calibre3">&nbsp;function in Python. When we impose a type system on JavaScript, we expect, say, the type </span><span class="c25">(Number -&gt; String)</span><span class="calibre3">&nbsp;to be different from the type </span><span class="c25">(String -&gt; Boolean)</span><span class="calibre3">. Similarly, an object that contains only the fields </span><span class="c25">x</span><span class="calibre3">&nbsp;and </span><span class="c25">y</span><span class="calibre3">&nbsp;is very different from the object that contains only the method </span><span class="c25">draw</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, these nuances are lost on </span><span class="c25">typeof</span><span class="calibre3">, which is innocent to even the existence of any such type systems. Therefore, all those functions are lumped under one tag, </span><span class="c25">"function"</span><span class="calibre3">, and all those objects are similarly treated uniformly as one tag, </span><span class="c25">"object"</span><span class="calibre3">&nbsp;(and analogously in Python). This is because their names are misleading: what they are reporting are not the </span><span class="c6">types</span><span class="calibre3">&nbsp;but rather the run-time </span><span class="c6">tags</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The difference between types and tags can grow arbitrarily big. After all, the number of types in a program can grow without bound, and so can their size (e.g., you can have a list of lists of arrays of functions from …). But the set of tags is fixed in many languages, though in those that allow you to define new (data)classes, this set might grow. Nevertheless, tags are meant to take up a fixed amount of space and be checked in a small constant amount of time.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Of course, this difference is not inherently problematic. After all, even in statically-typed languages with algebraic datatypes, we still need space to track variants, which requires a kind of (intra-type) tag. The issue is rather with the choice of </span><span class="c6">name</span><span class="calibre3">: that </span><span class="c25">typeof</span><span class="calibre3">&nbsp;and </span><span class="c25">type</span><span class="calibre3">&nbsp;do not, actually, return “types”. A more accurate name for them would be something like </span><span class="c25">tagof</span><span class="c2">, leaving the term “type” free for actual static type systems.</span></p></div>

<div class="c" id="calibre_link-378">
<h1 class="c20" id="calibre_link-225"><span class="c2">Nominal Types, Structural Types, and Subtyping</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s go back to</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define-type BT</span></p><p class="c4"><span class="c34">&nbsp; [mt]</span></p><p class="c4"><span class="c25">&nbsp; [node (v : Number) (l : BT) (r : BT)])</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and ask how we could have represented this in Java.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now:</span><span class="c2">&nbsp;Represent this in Java!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">How did you do it? Did you create a single class with </span><span class="c25">null</span><span class="c2">&nbsp;for the empty case?</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;Why is that solution not object-oriented?</span></p></div>

<div class="c" id="calibre_link-334">
<h2 class="c21" id="calibre_link-226"><span class="c2">Algebraic Datatypes Encoded With Nominal Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We’ll take a different approach. Observe from the datatype definition that we have two constructors, and one type that represents their union. We can encode this in Java as:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">abstract class BT {</span></p><p class="c4"><span class="c34">&nbsp; abstract public int size();</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">class mt extends BT {</span></p><p class="c4"><span class="c34">&nbsp; public int size() {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">class node extends BT {</span></p><p class="c4"><span class="c34">&nbsp; int v;</span></p><p class="c4"><span class="c34">&nbsp; BT l, r;</span></p><p class="c4"><span class="c34">&nbsp; node(int v, BT l, BT r) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; this.v = v;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; this.l = l;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; this.r = r;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; public int size() {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return 1 + this.l.size() + this.r.size();</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp; public static void main(String[] args) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; BT t = new node(5, new node(3, new mt(), new mt()), new mt());</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; System.out.println(t.size());</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">How is the “if-splitting” addressed here? It’s done in a hidden way, through dynamic dispatch. When we invoke a method, Java makes sure we run the right method: there are actually two concrete </span><span class="c25">size</span><span class="calibre3">&nbsp;methods, and the run-time picks the right one. Once that choice is made, the class in which the method resides automatically determines what is bound. Thus, the </span><span class="c25">size</span><span class="calibre3">&nbsp;in </span><span class="c25">node</span><span class="calibre3">&nbsp;can safely use </span><span class="c25">this.l</span><span class="calibre3">&nbsp;and </span><span class="c25">this.r</span><span class="c2">, and the type-checker knows that those fields exist.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This is, then, similar to, yet different from, our two prior solutions: using algebraic datatypes and union types. The solutions are structurally different, but they are all similar in that some </span><span class="c6">syntactic</span><span class="c2">&nbsp;pattern must be used to make the program statically type-able. With algebraic datatypes, it was pattern-matching; with union types, it was if-splitting; in Java, it’s the splitting of the code into separate methods.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The algebraic datatype and Java solutions are even more connected than we might imagine. With algebraic datatypes, we fixed the set of variants; but we were free to add new functions </span><span class="c6">without having to edit existing code</span><span class="calibre3">. In Java, we fix the set of behaviors (above, one method), but can add new variants without having to edit existing code. Therefore, neither has an inherent advantage over the other, and one’s strengths are the other’s weakness. How to do </span><span class="c6">both</span><span class="calibre3">&nbsp;at once is the essence of the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Expression_problem&amp;sa=D&amp;source=editors&amp;ust=1695232021492211&amp;usg=AOvVaw3l4_wQP5pOCFZHndfQMdbX">Expression Problem</a></span><span class="calibre3">. See also the concrete examples and approaches given in these two papers, one focusing on a </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/&amp;sa=D&amp;source=editors&amp;ust=1695232021492633&amp;usg=AOvVaw2Xm1yq3fY2pVUVr5sWjXEr">Java-based approach</a></span><span class="calibre3">&nbsp;and another </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kf-ext-sw-def/&amp;sa=D&amp;source=editors&amp;ust=1695232021492914&amp;usg=AOvVaw0SbXWoMkkqB5ySEJa9jMG3">function-centric</a></span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-297">
<h2 class="c21" id="calibre_link-227"><span class="c2">Nominal Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The type system in Java is representative of an entire class of languages. These have </span><span class="c6">nominal</span><span class="calibre3">&nbsp;types, which means the </span><span class="c6">name</span><span class="calibre3">&nbsp;of a class matters. (“Nominal” comes from the Latin </span><span class="c6">nomen</span><span class="c2">, or name.) It’s easiest to explain with an example.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Above we have the following class:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class mt extends BT {</span></p><p class="c4"><span class="c34">&nbsp; public int size() {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s now suppose we create another class that is identical in every respect but its name:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class empty extends BT {</span></p><p class="c4"><span class="c34">&nbsp; public int size() {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Let’s say we have a method that takes </span><span class="c25">mt</span><span class="c2">&nbsp;objects:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp; static int m(mt o) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return o.size();</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; public static void main(String[] args) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; System.out.println(m(new mt()));</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But observe that </span><span class="c25">empty</span><span class="calibre3">&nbsp;is a perfectly good substitute for </span><span class="c25">mt</span><span class="calibre3">: it too has a </span><span class="c25">size</span><span class="calibre3">&nbsp;method, which too takes no arguments, and it too returns an </span><span class="c25">int</span><span class="c2">&nbsp;(in fact, the very same value). Therefore, we try:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp; static int m(mt o) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return o.size();</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; public static void main(String[] args) {</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; System.out.println(m(new </span><span class="c53">empty</span><span class="c34">()));</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But Java rejects this. That’s because it expects an object that was constructed by the actual class </span><span class="c25">mt</span><span class="calibre3">, not just one that “looks like” it. That is, what matters is which actual (named) class, not what </span><span class="c6">structure</span><span class="c2">&nbsp;of class, created the value.</span></p></div>

<div class="c" id="calibre_link-62">
<h2 class="c21" id="calibre_link-228"><span class="c2">Structural Types</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In contrast, we can imagine a different type system: one where the type of each of the above classes is not its name but rather a description of what fields and methods it has: i.e., it’s structure, or its “services”. For instance, we might have:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">mt : {size : ( -&gt; int)}</span></p><p class="c4"><span class="c34">node : {size : ( -&gt; int)}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, each of these is a collection of names (one name, to be precise), which is a method that takes no parameters and returns an </span><span class="c25">int</span><span class="c2">. Whenever two types are the same, objects of one can be used where objects of the other kind are expected. Indeed, it is unsurprising that both kinds of trees have the same type, because programs that process one will invariably also need to process the other because trees are a union of these two types. Similarly, we also have</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">empty : {size : ( -&gt; int)}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The above m method might be written as:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">static int m(o </span><span class="c53">: {size : (-&gt; int)}</span><span class="c34">) {</span></p><p class="c4"><span class="c34">&nbsp; return o.size();</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, it only indicates what shape of object it expects, and doesn’t indicate which constructor should have made it. This is called </span><span class="c6">structural</span><span class="calibre3">&nbsp;typing, though the Internet appears to have decided to call this “duck” typing (though it’s hard to be clear: there is no actual theory of duck typing to compare against well-defined theories of structural typing: </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://www.springer.com/gp/book/9780387947754&amp;sa=D&amp;source=editors&amp;ust=1695232021498288&amp;usg=AOvVaw3AweVzQ_7nSMI7klfzt2li">Abadi and Cardelli</a></span><span class="calibre3">&nbsp;represent a classical viewpoint, and here’s an </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pgk-sem-type-fc-member-name/&amp;sa=D&amp;source=editors&amp;ust=1695232021498703&amp;usg=AOvVaw2EFVs5AkPquJx2jsIUl9pQ">extension</a></span><span class="c2">&nbsp;for modern “scripting” languages).</span></p></div>

<div class="c" id="calibre_link-15">
<h2 class="c21" id="calibre_link-229"><span class="c2">Nominal Subtyping</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We’ve been writing a bit gingerly about Java above: because we know that the </span><span class="c25">m</span><span class="calibre3">&nbsp;method will accept not only </span><span class="c25">mt</span><span class="calibre3">’s but also anything that is a sub-class of </span><span class="c25">mt</span><span class="c2">. Let’s explore this further.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To simplify things, let’s make some basic classes:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class A { String who = "A"; }</span></p><p class="c4"><span class="c34">class B extends A { String who = "B"; }</span></p><p class="c4"><span class="c34">class C extends A { String who = "C"; }</span></p><p class="c4"><span class="c34">class D { String who = "D"; }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We’ll also create a shell “runner”:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">class Main {</span></p><p class="c4"><span class="c34">&nbsp;public static void main(String[] args) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;System.out.println((true ? _____ : _____).who);</span></p><p class="c4"><span class="c34">&nbsp;}</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and try filling in different values for the blanks and seeing what output we get:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">System.out.println((true ? </span><span class="c53">new B()</span><span class="c25">&nbsp;: </span><span class="c53">new B()</span><span class="c34">).who);</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Unsurprisingly, this prints </span><span class="c25">"B"</span><span class="c2">. What about:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">System.out.println((true ? </span><span class="c53">new B()</span><span class="c25">&nbsp;: </span><span class="c53">new A()</span><span class="c34">).who);</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">You might expect this to also print </span><span class="c25">"B"</span><span class="calibre3">, because that’s the value that we created. However, it actually prints </span><span class="c25">"A"</span><span class="c2">! Let’s see a few more examples:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">System.out.println((true ? </span><span class="c53">new B()</span><span class="c25">&nbsp;: </span><span class="c53">new C()</span><span class="c34">).who);</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Will this print </span><span class="c25">"B"</span><span class="calibre3">? No, in fact, this also prints </span><span class="c25">"A"</span><span class="c2">! How about:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">System.out.println((true ? </span><span class="c53">new B()</span><span class="c25">&nbsp;: </span><span class="c53">new D()</span><span class="c34">).who)</span></p><p class="c4"><span class="c25">System.out.println((true ? </span><span class="c53">new B()</span><span class="c25">&nbsp;: </span><span class="c53">3</span><span class="c34">).who)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Both of these produce a static error. It’s instructive to read the error message: in both cases they reference </span><span class="c25">Object</span><span class="calibre3">. In the former case, it’s because there is nothing else common to B and D. But in the latter case, the primitive value 3 was effectively converted into an object&mdash;</span><span class="c25">new Integer(3)</span><span class="c2">&mdash;and those two object types were compared.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What is happening in the type system that causes this error? The cause is documented here:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html%23jls-15.25.3&amp;sa=D&amp;source=editors&amp;ust=1695232021502810&amp;usg=AOvVaw13Y12I72q4_WhlbdEUkvSr">https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25.3</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Specifically, the document says:</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c2">The type of the conditional expression is the result of applying capture conversion (§5.1.10) to lub(T1, T2).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where “lub” stands for “least upper bound”: the “lowest” class “above” all the given ones. This type is determined </span><span class="c6">statically</span><span class="c2">. That is, the type rule is essentially:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- C : Bool &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c25">|- T : V &nbsp; &nbsp;</span><span class="c84">Γ </span><span class="c34">|- E : W &nbsp; &nbsp;X = lub(V, W)</span></p><p class="c4"><span class="c34">----------------------------------------------------------</span></p><p class="c4"><span class="c84">Γ </span><span class="c25">|- (if C T E) : X</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Contrast this to the other rules we’ve seen for conditionals! The first type rule we saw was the most rigid, but produced the most usable values (because there was no ambiguity). The second type rule, for union types, was less rigid, but as a result the output type could have a union that needed to be split. This type rule is even less rigid (in terms of what the two branches produce), but the result could be as general as </span><span class="c25">Object</span><span class="c2">, with which we can do almost nothing.</span></p></div>

<div class="c" id="calibre_link-349">
<h2 class="c21" id="calibre_link-230"><span class="c2">Subtyping</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The general principle here is called </span><span class="c6">subtyping</span><span class="calibre3">: we say that type </span><span class="c25">X</span><span class="calibre3">&nbsp;is a subtype of </span><span class="c25">Y</span><span class="calibre3">, written </span><span class="c25">X &lt;: Y</span><span class="calibre3">&nbsp;(read the </span><span class="c25">&lt;:</span><span class="calibre3">&nbsp;like a “less than” or “contained”), whenever </span><span class="c25">X</span><span class="calibre3">&nbsp;can be used wherever a </span><span class="c25">Y</span><span class="calibre3">&nbsp;was expected: i.e., </span><span class="c25">X</span><span class="calibre3">&nbsp;can </span><span class="c6">safely</span><span class="calibre3">&nbsp;be </span><span class="c6">substituted</span><span class="calibre3">&nbsp;for </span><span class="c25">Y</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Java chose to make sub-</span><span class="c6">classes</span><span class="calibre3">&nbsp;into sub-</span><span class="c6">types</span><span class="calibre3">. Not all object-oriented languages do this, and indeed many consider it to be a mistake, but that’s the design Java has. Therefore, a sub-class is expected to offer at least as many services as its super-class; and hence, it can be substituted where a super-class is expected. The lub computation above finds the </span><span class="c6">most specific</span><span class="c2">&nbsp;common super-type.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This is an account of how subtyping works for </span><span class="c6">nominal</span><span class="calibre3">&nbsp;systems. This has the virtue of being fairly easy to understand. We can also define subtyping for </span><span class="c6">structural</span><span class="calibre3">&nbsp;systems, but that is rather more complex: some parts are easy to follow, other parts are a bit more tricky (but essential to obtain a sound type system). For a detailed explanation, with an illustrative example, see </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://papl.cs.brown.edu/2020/objects.html%23%2528part._subtyping%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021505625&amp;usg=AOvVaw25ykJjwpXl83jpgPY6xeR9">section 33.6.1 of PAPL</a></span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-316">
<h1 class="c20" id="calibre_link-231"><span class="c2">Gradual Typing</span></h1><h2 class="c21" id="calibre_link-232"><span class="c2">From Scripts to Programs</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">As dynamic language programs grow, they become increasingly hard to maintain. Programmers use types to define interfaces, communicate expectations of behavior, document, and so on, and in their absence, we need several ad hoc tools. Put differently, we want “scripts” to grow up and become “programs”.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Thus, one of the most visible trends in programming languages over the past ten years is dynamic languages adding a static counterpart. In principle, this is as simple as adding a type-system to an existing language. As we’ve already seen when discussing retrofitted types [</span><span class="c15"><a class="c10" href="#calibre_link-214">👉</a></span><span class="c2">], however, such a type system needs to take into account the idiomatic style of programming in the language; otherwise it would report as erroneous too many programs that are actually type-correct, and this high false-positive rate would make people not use the type system at all. Therefore, we discussed some patterns of code that need to be supported.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Another major obstacle to adoption is that people often have a large amount of code lying around, and it is simply impractical to convert all of it to a typed language in one go. In fact, some of it may not even be typeable by most reasonable type systems: e.g., the </span><span class="c25">eval</span><span class="calibre3">&nbsp;construct, which takes a </span><span class="c6">dynamic</span><span class="c2">&nbsp;string (e.g., one that may be constructed on-the-fly during program execution) and runs it. By definition, we statically do not know what this string is; without knowing it, we can’t possibly type it statically.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In short, there are two reasons why we cannot expect the whole program to make an instant transition from untyped to typed:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">The program is too large, and programmers have other things to do with their time.</span></li><li class="pcalibre c23"><span class="c2">Some parts of the program may not even be typeable.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(You don’t need </span><span class="c25">eval</span><span class="c2">&nbsp;to make things hard to type. Many dynamic constructs that look at program behavior and modify it have the same flavor. They enter the language because it’s dynamic and doesn’t have to worry about a static type discipline, and then create an obstacle for later typing.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Despite this, type systems have been built for many real-world dynamic languages. These type systems exhibit a property called </span><span class="c6">gradual typing</span><span class="calibre3">: as the name suggests, you add types “gradually” to the program, hopefully making it more-and-more typed. What started out as an academic idea in the Scheme community (two papers in 2006 introduced gradual typing for Scheme) is now </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Gradual_typing&amp;sa=D&amp;source=editors&amp;ust=1695232021507601&amp;usg=AOvVaw0ZgqxCx2wfimBQuPFFxnVE">widely used in industry</a></span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-71">
<h2 class="c21" id="calibre_link-233"><span class="c2">Micro Versus Macro</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In gradual typing, we are going to add annotations to programs and then type-check the program. Within this broad principle, there are two schools of thought.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In “micro” gradual typing we can add annotations to any subset of the variables of the language. We saw this earlier in the Static Python example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">def insort_right(a, x, lo: int = 0, hi: Optional[int] = None):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here, we have annotations on </span><span class="c25">lo</span><span class="calibre3">&nbsp;and </span><span class="c25">hi</span><span class="calibre3">, but not on </span><span class="c25">a</span><span class="calibre3">&nbsp;and </span><span class="c25">x</span><span class="calibre3">. Ergonomically, this is very convenient for the programmer: use annotations for the parts you care about, and not for the parts you don’t. Unfortunately, this comes at a cost: there is now a much more complex language where any parts of a program can be static and any other parts dynamic, and they can freely commingle in the same body of code, even in a single expression or line (e.g., from the same example: </span><span class="c25">hi = len(a)</span><span class="calibre3">). The type system needs to somehow deal with constructs it cannot meaningfully type (like </span><span class="c25">eval</span><span class="c2">). Also, previously we had a clean and simple soundness result for the typed program; now it is rather unclear what soundness means. In turn, that means that programmers may put a lot of effort into annotations, but without a clear guarantee of what they are getting in return. (A large body of literature now tries to make sense of this.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In contrast, there is another approach, often called “macro” gradual typing. In the macro approach, there are </span><span class="c6">two languages</span><span class="calibre3">: the typed and the dynamic one. They are expected to be very similar&mdash;so similar that they have the same run-time system and can freely share values&mdash;so we’ll refer to them as “sibling” languages. However, they may not have the same constructs (e.g., the typed language would not contain </span><span class="c25">eval</span><span class="calibre3">). Instead of freely mixing code between typed and untyped, we only have to figure out what happens when values travel </span><span class="c6">between</span><span class="c2">&nbsp;the languages, not within each one. The expectation is that the programmer will gradually migrate part of their codebase from the dynamic to the typed language, typically a function at a time. Each language can import code from the other, but when importing into typed code, the programmer must specify a type for the imported code.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">A canonical example of this approach is Typed Racket. Because Typed Racket is one of the oldest and most developed gradually typed languages (technically, it’s the </span><span class="c6">combination</span><span class="c2">&nbsp;of Racket and Typed Racket that is gradually typed&mdash;Typed Racket itself is fully typed), and also offers some of the most interesting perspective on what happens when values travel between languages, we will use that as our exemplar for study.</span></p></div>

<div class="c" id="calibre_link-332">
<h2 class="c21" id="calibre_link-234"><span class="c2">Typed Racket at Work</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In what follows, it’s critical to pay attention to the exact details of error messages!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">First, let’s write the following function in </span><span class="c25">#lang racket</span><span class="c2">&nbsp;and test it out:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (g s)</span></p><p class="c4"><span class="c34">&nbsp; (+ 1 (or (string-&gt;number s) 0)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">As we would expect,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (g "5")</span></p><p class="c4"><span class="c34">6</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">because the string represents a valid number,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (g "hi")</span></p><p class="c4"><span class="c34">1</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">because the string doesn’t represent a valid number, and</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (g 5)</span></p><p class="c4"><span class="c61">string-&gt;number: contract violation</span></p><p class="c4"><span class="c61">&nbsp; expected: string?</span></p><p class="c4"><span class="c61">&nbsp; given: 5</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">because </span><span class="c25">5</span><span class="c2">&nbsp;isn’t a string at all.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s define it in Typed Racket:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3"></span><span class="c34">#lang typed/racket</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (f [s : String]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (+ 1 (or (string-&gt;number s) 0)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The type-checker confirms that this program is well-typed.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="c2">&nbsp;As a test, try</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c34">(define (f [s : String]) : Number</span></p><p class="c27"><span class="c34">&nbsp; (+ 1 (string-&gt;number s)))</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c2">and see what happens.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now suppose we export this function from Typed Racket:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(provide f)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and import it into the Racket module:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(require "typed.rkt") ;; or whatever filename you’ve chosen</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Let’s try the same three tests. Predictably, two of them work the same:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (f "5")</span></p><p class="c4"><span class="c34">6</span></p><p class="c4"><span class="c34">&gt; (f "hi")</span></p><p class="c4"><span class="c34">1</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The third still produces an error, but a rather different kind of error:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (f 5)</span></p><p class="c4"><span class="c61">f: contract violation</span></p><p class="c4"><span class="c61">&nbsp; expected: string?</span></p><p class="c4"><span class="c61">&nbsp; given: 5</span></p><p class="c4"><span class="c61">&nbsp; in: the 1st argument of</span></p><p class="c4"><span class="c61">&nbsp; &nbsp; &nbsp; (-&gt; string? any)</span></p><p class="c4"><span class="c61">&nbsp; contract from: typed.rkt</span></p><p class="c4"><span class="c61">&nbsp; blaming: untyped.rkt</span></p><p class="c4"><span class="c61">&nbsp; &nbsp;(assuming the contract is correct)</span></p><p class="c4"><span class="c61">&nbsp; at: typed.rkt:5:9</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here’s what is happening. When we export f from Typed Racket, we don’t just export the function in its raw form. Rather, Typed Racket wraps the function in </span><span class="c6">contracts</span><span class="c2">&nbsp;that “protect” it in a dynamic setting. Thus, it is as if the function that was exported was</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (wrapped-f s)</span></p><p class="c4"><span class="c34">&nbsp; (if (string? s)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (let ([b (+ 1 (or (string-&gt;number s) 0))])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (if (number? b)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (error 'contract "returned value was not a Number")))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (error 'contract "provided value was not a String")))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(with suitably different error messages). Notice that </span><span class="c25">wrapped-f</span><span class="calibre3">&nbsp;behaves exactly like our imported </span><span class="c25">f</span><span class="calibre3">&nbsp;does: the error when given </span><span class="c25">5</span><span class="c2">&nbsp;is from a contract check, rather than from an internal operation. Observe also that this wrapped version is quite easy to produce in a completely mechanical way, i.e., through desugaring:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(define (f [</span><span class="c101">s</span><span class="c25">&nbsp;: </span><span class="c102">String</span><span class="c25">]) : </span><span class="c88">Number</span></p><p class="c4"><span class="c25">&nbsp; </span><span class="c101">(+ 1 (or (string-&gt;number s) 0))</span><span class="c34">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">became</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(define (wrapped-f </span><span class="c101">s</span><span class="c34">)</span></p><p class="c4"><span class="c25">&nbsp; (if (</span><span class="c102">string?</span><span class="c25">&nbsp;</span><span class="c101">s</span><span class="c34">)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; (let ([b </span><span class="c101">(+ 1 (or (string-&gt;number s) 0))</span><span class="c34">])</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; (if (</span><span class="c90">number?</span><span class="c34">&nbsp;b)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (error 'contract "returned value was not a </span><span class="c90">Number</span><span class="c34">")))</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; (error 'contract "provided value was not a </span><span class="c102">String</span><span class="c34">")))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;Why do we bind </span><span class="c25">b</span><span class="c2">&nbsp;to the result of the body? Why not use the body expression directly?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The point of this wrapping is to put the type annotations to work in a dynamic setting. Essentially, the programmer who has put the effort to add annotations and get the program through the type-checker gets assurance that their function will not be abused through checks that are early and more informative than an internal error (that may not even occur, depending on the inputs, leaving the error to lurk!).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here is a more interesting example. We define the following typed function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (h [i : (-&gt; String Number)]) : Number</span></p><p class="c4"><span class="c34">&nbsp; (+ (i "5") 1))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here is its Racket counterpart:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (j i)</span></p><p class="c4"><span class="c34">&nbsp; (+ (i "5") 1))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s assume we are trying to use both of these from Racket. We first define a function that produces strings from strings, i.e., one that does </span><span class="c6">not</span><span class="calibre3">&nbsp;match the function expected by either </span><span class="c25">h</span><span class="calibre3">&nbsp;or </span><span class="c25">j</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (str-dbl s) (string-append s s))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now watch what happens when we run </span><span class="c25">(j str-dbl)</span><span class="calibre3">&nbsp;and </span><span class="c25">(h str-dbl)</span><span class="calibre3">. Both produce a run-time error, but very different ones. The former (which is entirely in Racket) gives an error at </span><span class="c25">+</span><span class="calibre3">: the “doubled” string is produced and makes it as far as </span><span class="c25">+</span><span class="calibre3">, which reports a violation. In contrast, in the latter case, the doubled string is produced but, when it tries to return from </span><span class="c25">(i "5")</span><span class="calibre3">, the type </span><span class="c25">(-&gt; String Number)</span><span class="calibre3">&nbsp;has been turned into a contract, which halts execution saying that there is a </span><span class="c6">contract</span><span class="c2">&nbsp;violation!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="calibre3">&nbsp;To get a sense of Racket’s contract system, see </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://docs.racket-lang.org/guide/contracts.html&amp;sa=D&amp;source=editors&amp;ust=1695232021518320&amp;usg=AOvVaw3cHKDevH_K7R7ne4KDUsP7">Contracts</a></span><span class="c2">&nbsp;in the Racket Guide.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="calibre3">Another interesting static-dynamic language combination is Racket with plait. plait does not try very much to accommodate Racket idioms, though it does to some extent: recall the predicates and accessors in algebraic dataytypes [</span><span class="c15"><a class="c10" href="#calibre_link-74">👉</a></span><span class="c2">], though at the cost of static type safety. Largely, however, plait is trying to implement the Standard ML type language. Nevertheless, because plait lives in the context of Racket, its values can be exported and used from Racket. Try the above examples in plait!</span></p></div>

<div class="c" id="calibre_link-374">
<h1 class="c13" id="calibre_link-235"><span class="c2">•••••&nbsp;Non-Standard Models •••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c28">We have already seen some non-standard features, but they are in widespread use. Here we look at some that are less widely used (though some are growing in prominence, and others are enjoying a renaissance) but provide fascinating views of what programming languages can do.</span></p></div>

<div class="c" id="calibre_link-314">
<h1 class="c20" id="calibre_link-236"><span class="c2">Relations</span></h1><h2 class="c21" id="calibre_link-237"><span class="c2">A Language Genealogy</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Suppose we want to record a genealogy of programming languages and determine which languages obtained ideas from which ones. We start by recording which languages directly borrowed ideas from which ones: e.g., Java directly borrowed from C++, and C++ directly borrowed from C. From that, we can also trace the descendants down a chain of borrowing.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We will write some of these in the following, maybe peculiar, syntax:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">borrows(A, B)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">means that the language </span><span class="c25">A</span><span class="calibre3">&nbsp;borrows from the language </span><span class="c25">B</span><span class="calibre3">&nbsp;(i.e., </span><span class="c25">A</span><span class="calibre3">&nbsp;is newer, </span><span class="c25">B</span><span class="calibre3">&nbsp;is older). For another peculiar reason, we will write constants not as quotes but as alphanumeric strings with a </span><span class="c6">lower-case initial</span><span class="calibre3">. Given that, here are some facts (with </span><span class="c25">cpp</span><span class="c2">&nbsp;standing for C++):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">borrows(java, cpp).</span></p><p class="c4"><span class="c34">borrows(cpp, c).</span></p><p class="c4"><span class="c34">borrows(c, bcpl).</span></p><p class="c4"><span class="c34">borrows(pascal, algol).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we can express the notion of being a descendant: there are two ways that </span><span class="c25">A</span><span class="calibre3">&nbsp;can be a descendant of </span><span class="c25">B</span><span class="calibre3">. One is if </span><span class="c25">A</span><span class="calibre3">&nbsp;borrows directly from </span><span class="c25">B</span><span class="calibre3">. The other is if it borrows from some language </span><span class="c25">Z</span><span class="calibre3">&nbsp;that is itself a descendant of </span><span class="c25">B</span><span class="c2">. We express these two rules using this syntax:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">descends(A, B) :- borrows(A, B).</span></p><p class="c4"><span class="c34">descends(A, B) :- borrows(A, Z), descends(Z, B).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Congratulations, you’ve just written your first </span><span class="c33">Prolog</span><span class="calibre3">&nbsp;program. To see this run, you can use </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://swish.swi-prolog.org/&amp;sa=D&amp;source=editors&amp;ust=1695232021521364&amp;usg=AOvVaw3htfQEX93FhT5bpRmnE6re">SWI Prolog online</a></span><span class="c2">. But what does it mean to “run” this? Prolog answers questions: we can ask several questions like:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">Does </span><span class="c25">cpp</span><span class="c6">&nbsp;borrow from </span><span class="c25">c</span><span class="c6">?</span></p><p class="c4"><span class="c34">borrows(cpp, c).</span></p><p class="c4"><span class="c2">→ true</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">Does </span><span class="c25">cpp</span><span class="c6">&nbsp;borrow from </span><span class="c25">bcpl</span><span class="c28">?</span></p><p class="c4"><span class="c34">borrows(cpp, bcpl).</span></p><p class="c4"><span class="c2">→ false</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">That is, we can see that Prolog is acting like a basic database. But we can do more:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">Does </span><span class="c25">cpp</span><span class="c6">&nbsp;descend from </span><span class="c25">bcpl</span><span class="c28">?</span></p><p class="c4"><span class="c34">descends(cpp, bcpl).</span></p><p class="c4"><span class="c2">→ true</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">Does </span><span class="c25">bcpl</span><span class="c6">&nbsp;descend from </span><span class="c25">cpp</span><span class="c28">?</span></p><p class="c4"><span class="c34">descends(bcpl, cpp).</span></p><p class="c4"><span class="c2">→ false</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Aha: so Prolog will not only query basic facts, it will also process queries through rules.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But we can actually ask Prolog more sophisticated questions that look more like function applications. Consider:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">What does </span><span class="c25">cpp</span><span class="c6">&nbsp;borrow from?</span></p><p class="c4"><span class="c2">borrows(cpp, X).</span></p><p class="c4"><span class="c2">→ </span></p><p class="c4"><span class="c103">X</span><span class="c104">&nbsp;= </span><span class="c105">c</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This seems to treat borrows like a rather funny function, calling it with a </span><span class="c6">variable</span><span class="c2">&nbsp;(a name that begins with a capital letter) and letting Prolog fill in the variable. Does that work only for basic definitions, or also for rules?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">What does </span><span class="c25">cpp</span><span class="c6">&nbsp;descend from?</span></p><p class="c4"><span class="c2">descends(cpp, X).</span></p><p class="c4"><span class="c2">→ </span></p><p class="c106"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">c</span></p><p class="c109"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">bcpl</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Oh, this is interesting! Prolog didn’t return just one answer; it returned </span><span class="c6">all</span><span class="calibre3">&nbsp;the answers. And this was done by using a </span><span class="c6">variable</span><span class="calibre3">&nbsp;(a name that begins with a </span><span class="c6">capital letter</span><span class="c2">). This naturally suggests the question, what if we did it the other way around?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c6">What descends from </span><span class="c25">cpp</span><span class="c2">?</span></p><p class="c4"><span class="c2">descends(X, cpp).</span></p><p class="c4"><span class="c2">→ </span></p><p class="c4"><span class="c103">X</span><span class="c104">&nbsp;= </span><span class="c105">java</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This is even stranger: it’s like passing a variable as an argument and asking what inputs will produce a particular result from the function!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In fact, a function is just the wrong way to think about any of this. What is happening in Prolog is that we’re defining </span><span class="c6">relations</span><span class="c2">. So borrows and descends are actually relations, where one (borrows) is defined by concrete examples and the other (descends) by abstract rules.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Once we understand these are relations, we no longer need to limit ourselves to just one source of borrowing, to better reflect reality. That is, let’s say this is our set of facts:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">borrows(java, cpp).</span></p><p class="c4"><span class="c34">borrows(cpp, c).</span></p><p class="c4"><span class="c34">borrows(cpp, simula).</span></p><p class="c4"><span class="c34">borrows(smalltalk, simula).</span></p><p class="c4"><span class="c34">borrows(self, smalltalk).</span></p><p class="c4"><span class="c34">borrows(c, bcpl).</span></p><p class="c4"><span class="c34">borrows(pascal, algol).</span></p><p class="c4"><span class="c34">borrows(scheme, algol).</span></p><p class="c4"><span class="c34">borrows(scheme, lisp).</span></p><p class="c4"><span class="c34">borrows(javascript, self).</span></p><p class="c4"><span class="c34">borrows(javascript, scheme).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we can ask what all languages contributed to JavaScript:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">descends(javascript, X).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">From this set of facts, we learn:</span></p><p class="c3"><span class="c2"></span></p><p class="c106"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">self</span></p><p class="c109"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">scheme</span></p><p class="c106"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">smalltalk</span></p><p class="c109"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">simula</span></p><p class="c106"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">algol</span></p><p class="c109"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">lisp</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Similarly, we can ask how widely Lisp’s influence spread:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">descends(X, lisp).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">And we learn that for this very limited set of languages:</span></p><p class="c3"><span class="c2"></span></p><p class="c106"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">scheme</span></p><p class="c109"><span class="c103">X</span><span class="c107">&nbsp;= </span><span class="c108">javascript</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-34">
<h2 class="c21" id="calibre_link-238"><span class="c2">Encoding Type Rules</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">You may have noticed that we’re writing rules that are quite similar to the typing rules we’ve written. Let’s see whether we can encode them directly.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First, we need to encode the rules for syntactic constants:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(numE, numT).</span></p><p class="c4"><span class="c34">tc(strE, strT).</span></p><p class="c4"><span class="c34">tc(boolE, boolT).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We will use the Prolog constant </span><span class="c25">numE</span><span class="c2">&nbsp;to stand for a syntactic numeric expression, and so on.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now, using just what we already know, we can encode the conditional rules:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(plusE(L, R), numT) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(L, numT),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(R, numT).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">tc(catE(L, R), strT) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(L, strT),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(R, strT).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">tc(ifE(C, T, E), Ty) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(C, boolT),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(T, Ty),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(E, Ty).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Note that this is literally just a syntactic transformation of the rules we wrote before!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">With this, we can now use Prolog as a </span><span class="c6">checker</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(ifE(boolE, plusE(numE, numE), numE), numT).</span></p><p class="c4"><span class="c2">→ true</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and as a </span><span class="c6">calculator</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(ifE(boolE, plusE(numE, numE), numE), Y).</span></p><p class="c4"><span class="c2">→ </span></p><p class="c4"><span class="c103">Y</span><span class="c104">&nbsp;= </span><span class="c105">numT</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">But we can do something much more intriguing: what if we leave variables in the </span><span class="c6">program</span><span class="c2">?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">tc(ifE(boolE, plusE(numE, Y), numE), numT).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This is asking Prolog to </span><span class="c6">come up with programs</span><span class="c2">&nbsp;that will make this program have numeric type. Prolog responds with:</span></p><p class="c3"><span class="c2"></span></p><p class="c106"><span class="c103">Y</span><span class="c110">&nbsp;= </span><span class="c111">numE</span></p><p class="c109"><span class="c103">Y</span><span class="c110">&nbsp;= </span><span class="c112">plusE</span><span class="c110">(</span><span class="c113">numE</span><span class="c110">, </span><span class="c113">numE</span><span class="c114">)</span></p><p class="c106"><span class="c103">Y</span><span class="c110">&nbsp;= </span><span class="c112">plusE</span><span class="c110">(</span><span class="c113">numE</span><span class="c110">, </span><span class="c112">plusE</span><span class="c110">(</span><span class="c113">numE</span><span class="c110">, </span><span class="c113">numE</span><span class="c114">))</span></p><p class="c109"><span class="c103">Y</span><span class="c110">&nbsp;= </span><span class="c112">plusE</span><span class="c110">(</span><span class="c113">numE</span><span class="c110">, </span><span class="c112">plusE</span><span class="c110">(</span><span class="c113">numE</span><span class="c110">, </span><span class="c112">plusE</span><span class="c110">(</span><span class="c113">numE</span><span class="c110">, </span><span class="c113">numE</span><span class="c110">)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(and many more; the structure of terms reveals something about how Prolog works). That is, Prolog is acting as a </span><span class="c6">program synthesizer</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s see how to extend this to include the type environment. For that, we have to enlarge our typing rules to include an environment as well. Recall that the environment doesn’t matter for the axioms, while the other rules just pass the environment through:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(numE, _, numT).</span></p><p class="c4"><span class="c34">tc(strE, _, strT).</span></p><p class="c4"><span class="c34">tc(boolE, _, boolT).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">tc(plusE(L, R), Env, numT) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(L, Env, numT),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(R, Env, numT).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">tc(catE(L, R), Env, strT) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(L, Env, strT),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(R, Env, strT).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">tc(ifE(C, T, E), Env, Ty) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(C, Env, boolT),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(T, Env, Ty),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(E, Env, Ty).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">Now let’s add the three variable-oriented rules. We will use a list of </span><span class="c25">bind</span><span class="c2">&nbsp;relations to capture the environment. To look up a variable, we pattern-match on whether the variable is the first binding; if it is we can respond with the relevant type, otherwise we must search in the remaining bindings:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(varE(V), [bind(V, T) | _], T).</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">tc(varE(V), [bind(_, _) | RestTEnv], T) :-</span></p><p class="c4"><span class="c25">&nbsp; &nbsp;tc(varE(V), RestTEnv, T).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The Prolog notation </span><span class="c25">[ … | …&nbsp;]</span><span class="calibre3">&nbsp;means to decompose a list into a first, or head, element to the left of the </span><span class="c25">|</span><span class="calibre3">&nbsp;and the rest, or tail, to the right of the </span><span class="c25">|</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The other two rules look much more like the type rules we wrote earlier:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(lamE(V, B), TEnv, funT(A, R)) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(B, [bind(V, A) | TEnv], R).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that in the above rule, we have done away with the type annotation! This rule looks more like what we would write with type </span><span class="c6">inference</span><span class="calibre3">&nbsp;than with type </span><span class="c6">checking</span><span class="c2">. Finally:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(appE(F, A), TEnv, U) :-</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(F, TEnv, funT(T, U)),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; tc(A, TEnv, T).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We can now use these definitions with the example we used for type </span><span class="c6">inference</span><span class="c2">. Let’s translate this program (we have only single-argument functions) from before:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(lambda (v)</span></p><p class="c4"><span class="c34">&nbsp; (lambda (w)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (if v</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (+ w 1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (+ w 2))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We pass this to the </span><span class="c25">tc</span><span class="c2">&nbsp;relation, encoded as follows, with the type environment and result type left variable:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(lamE(v, </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;lamE(w, </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;ifE(varE(v), </span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;plusE(varE(w), numE),</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;plusE(varE(w), numE)))), TEnv, T)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Prolog produces the following output:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c103">T</span><span class="c104">&nbsp;= </span><span class="c115">funT</span><span class="c107">(</span><span class="c105">boolT</span><span class="c107">, </span><span class="c115">funT</span><span class="c107">(</span><span class="c105">numT</span><span class="c107">, </span><span class="c105">numT</span><span class="c107">))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In other words, it has effectively inferred the type of the function: </span><span class="c25">v</span><span class="calibre3">&nbsp;has Boolean type, </span><span class="c25">w</span><span class="c2">&nbsp;has numeric type, and the result of the whole expression is a number.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In other words, it has </span><span class="c6">inferred</span><span class="c2">&nbsp;the types of the parameters. Now let’s consider some type-erroneous programs:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(lamE(v, ifE(boolE, strE, numE)), _, _)</span></p><p class="c4"><span class="c2">→ false</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Here, Prolog tells us it can’t find any variable name that would satisfy this shape of program. But if instead we give it a program with holes to fill in for expressions:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">tc(lamE(w, ifE(A, strE, numE)), _, _)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Prolog tries to build bigger and bigger terms that might work, and goes into an infinite loop trying to find a program that is typeable! In general, this is a problem for synthesis systems: if the problem they are given has a solution they can often find one quickly, but if it does not have a solution, they have to spend a long time trying to find one&mdash;either very long, if it’s a large but finite space to search, or infinitely long, if the space is infinite. Often, synthesizers will use heuristics to truncate this search.</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-291">
<h1 class="c20" id="calibre_link-239"><span class="c2">Generators</span></h1><h2 class="c21" id="calibre_link-240"><span class="c2">A Canonical Example</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider the following canonical Python program that uses generators:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">def nats():</span></p><p class="c4"><span class="c34">&nbsp; n = 0</span></p><p class="c4"><span class="c34">&nbsp; while True:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; yield n</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n += 1</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">g = nats()</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">next(g) + next(g) + next(g)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">produces </span><span class="c25">0 + 1 + 2</span><span class="calibre3">&nbsp;= </span><span class="c25">3</span><span class="c2">. But how does it work?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">At a textual level, we can understand it as follows. </span><span class="c25">nats</span><span class="calibre3">&nbsp;looks like a function, but it has the keyword </span><span class="c25">yield</span><span class="calibre3">&nbsp;in it. This makes it not a function but a </span><span class="c6">generator</span><span class="calibre3">. Its body initializes </span><span class="c25">n</span><span class="calibre3">&nbsp;to </span><span class="c25">0</span><span class="calibre3">, then goes into an infinite loop. Each time through the loop, it </span><span class="c6">yields</span><span class="calibre3">&nbsp;the current value of </span><span class="c25">n</span><span class="c2">, then increments it, before continuing the loop.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Outside the definition of </span><span class="c25">nats</span><span class="calibre3">, we define </span><span class="c25">g</span><span class="calibre3">&nbsp;to be an </span><span class="c6">instance</span><span class="calibre3">&nbsp;of the generator, and each call to </span><span class="c25">next</span><span class="calibre3">&nbsp;gets the next yielded value. This explains the result. What we need to do is understand what is going on inside </span><span class="c25">nats</span><span class="c2">, and hence what happens with generators in general.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">It is clear that we </span><span class="c6">cannot</span><span class="calibre3">&nbsp;think of </span><span class="c25">nats</span><span class="calibre3">&nbsp;(or of the generator returned by it) as a function. If we do, then clearly it goes into an infinite loop. That means the very first </span><span class="c25">next</span><span class="calibre3">&nbsp;call would run forever; it would never produce a value, which enables the next </span><span class="c25">next</span><span class="c2">&nbsp;call, and then the third, producing the sum. To see this, imagine we had the following version instead:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">def natsr():</span></p><p class="c4"><span class="c34">&nbsp; n = 0</span></p><p class="c4"><span class="c34">&nbsp; while True:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; return n</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n += 1</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">natsr() + natsr() + natsr()</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here, even though natsr (“</span><span class="c25">nats</span><span class="calibre3">&nbsp;with </span><span class="c25">return</span><span class="calibre3">”) has an infinite loop, every time Python runs the </span><span class="c25">return</span><span class="calibre3">, it halts the function and returns. Furthermore, on the next call, we start again from the beginning of </span><span class="c25">natsr</span><span class="calibre3">. As a result, each call produces </span><span class="c25">0</span><span class="calibre3">&nbsp;so the sum is also </span><span class="c25">0</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In contrast, that is clearly not what is happening in (the generator created by) </span><span class="c25">nats</span><span class="calibre3">. Rather, it’s clear that&mdash;as the name </span><span class="c25">yield</span><span class="calibre3">&nbsp;suggests&mdash;the computation is </span><span class="c6">halting</span><span class="calibre3">&nbsp;when the </span><span class="c25">yield</span><span class="calibre3">&nbsp;occurs. When we call </span><span class="c25">next</span><span class="calibre3">, computation does not start at the top of </span><span class="c25">nats</span><span class="calibre3">; if it did, </span><span class="c25">n</span><span class="calibre3">&nbsp;would be </span><span class="c25">0</span><span class="calibre3">. Instead, it </span><span class="c6">resumes</span><span class="calibre3">&nbsp;from where it left off, so that the value of </span><span class="c25">n</span><span class="calibre3">&nbsp;is incremented and the next iteration of the </span><span class="c25">while</span><span class="c2">&nbsp;loop occurs.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If all of this sounds suspiciously like variables in a scope being held on to by a closure, you’re on the right track. To understand this more, though, we need to peer a bit more closely at the evaluation. While we could run this in the </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://pythontutor.com/python-debugger.html%23mode%3Dedit&amp;sa=D&amp;source=editors&amp;ust=1695232021543587&amp;usg=AOvVaw1V3VjgOrP0CFbXmfhLsC-A">Python Tutor</a></span><span class="c2">, that tool does not really have the support necessary for us to understand what is happening in this program. Instead, we will turn to our Stacker.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">In Python, generators are merely syntactic sugar over the more general notion of </span><span class="c6">iterators</span><span class="calibre3">. Iterators respond to the </span><span class="c25">next</span><span class="calibre3">&nbsp;protocol. To learn how a generator desugars into an iterator, see </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators&amp;sa=D&amp;source=editors&amp;ust=1695232021544241&amp;usg=AOvVaw2tKB37Q1fKdFcreD_ejsF-">this StackOverflow post</a></span><span class="calibre3">. To understand Python generators in more depth, see sections 4.1 and 4.3 of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/&amp;sa=D&amp;source=editors&amp;ust=1695232021544525&amp;usg=AOvVaw1G24Y80eCAnFcayzoealQX">this paper</a></span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-370">
<h2 class="c21" id="calibre_link-241"><span class="c2">Translating to SMoL</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The following program is a rough simulation of the above Python program </span><span class="c6">if</span><span class="calibre3">&nbsp;SMoL had a notion of </span><span class="c25">yield</span><span class="calibre3">, which it does not. To avoid unbound identifier errors, we will use the following simple definition of </span><span class="c25">yield</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(deffun (yield n)</span></p><p class="c4"><span class="c34">&nbsp; n)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can then translate the above code as follows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(deffun (gen)</span></p><p class="c4"><span class="c34">&nbsp; (defvar n 0)</span></p><p class="c4"><span class="c34">&nbsp; (deffun (loop)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (yield n)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (set! n (+ n 1))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (loop))</span></p><p class="c4"><span class="c34">&nbsp; (loop))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(+ (gen) (gen) (gen))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">For simplicity, we’re ignoring the step where we </span><span class="c6">instantiate</span><span class="c2">&nbsp;the generator: i.e., we can have only one copy of the generator in this version, whereas the Python version lets us instantiate multiple. We will return to this later.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that running the above program goes into an infinite loop, because </span><span class="c25">yield</span><span class="c2">&nbsp;does not “yield”. However, because the Stacker shows us intermediate steps in the computation, it still provides something very useful.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now that we have this program, let’s run it through the Stacker. We will see a few preliminary states, and then one that looks like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre24"><img alt="" src="images/000004.png" title="" class="calibre25" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">At this point, the oldest frame represents the top-level expression, which is waiting for the first call to </span><span class="c25">gen</span><span class="calibre3">&nbsp;to compute. Inside </span><span class="c25">gen</span><span class="calibre3">, we have initialized </span><span class="c25">n</span><span class="calibre3">&nbsp;to </span><span class="c25">0</span><span class="c2">. Now we are about to start computing the (potentially) infinite loop.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A little bit later, we see the following:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre26"><img alt="" src="images/000003.png" title="" class="calibre27" /></span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="c6">This picture is the essence of generators. Understanding it is critical.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Here is what is happening here. The top-level computation is waiting for the call to </span><span class="c25">gen</span><span class="calibre3">&nbsp;to finish and produce an answer. </span><span class="c6">Within</span><span class="calibre3">&nbsp;the generator, the computation has initialized n and is about to yield its current value. What is critical is the </span><span class="c6">context</span><span class="c2">&nbsp;of this operation:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(begin</span></p><p class="c4"><span class="c34">&nbsp; •</span></p><p class="c4"><span class="c34">&nbsp; (set! n (+ n 1))</span></p><p class="c4"><span class="c34">&nbsp; (loop))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">in @1678, which has no bindings and hence defers to @1909. This binds </span><span class="c25">n</span><span class="calibre3">&nbsp;to </span><span class="c25">0</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now, suppose we could break up this stack into two parts (with the environment and store shared as needed):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ • (gen) (gen))</span></p><p class="c4"><span class="c2">in @1233</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(begin</span></p><p class="c4"><span class="c34">&nbsp; •</span></p><p class="c4"><span class="c34">&nbsp; (set! n (+ n 1))</span></p><p class="c4"><span class="c25">&nbsp; (loop))</span></p><p class="c4"><span class="c2">in @1678</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that each part looks like a full-fledged stack in its own right! The environment @1233 refers to names that the top-level uses (such as </span><span class="c25">gen</span><span class="calibre3">), while the environment @1678 (and hence @1909) refers to ones that the generator uses (such as </span><span class="c25">n</span><span class="c2">).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Until now, however, we have acted as if a program has only one stack. The simplest conceptual model for a generator is:</span></p><p class="c3"><span class="c2"></span></p><p class="c7"><span class="c2">Each generator has its own local stack.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, the generator’s stack does not know about the computation in the main program or in any other generators. It only knows about the computation that it is performing. A </span><span class="c25">yield</span><span class="c2">&nbsp;does two things:</span></p><p class="c3"><span class="c2"></span></p><ol class="c116" start="1"><li class="c117 pcalibre26"><span class="calibre3">It transparently (i.e., without the programmer’s knowledge) stores the </span><span class="c6">local</span><span class="c2">&nbsp;stack with the generator data structure.</span></li><li class="c117 pcalibre26"><span class="c2">It returns the yielded value to the stack that invoked the generator.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Everything else&mdash;variables, aliasing, closures, growth and decline of the stack with functions calls and returns, etc.&mdash;stays exactly the same. The only difference is that calling a generator causes computation to start, or resume the context, in a separate, disconnected stack.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Thus, in the above model, after the first </span><span class="c25">yield</span><span class="c2">&nbsp;succeeds, the top-level stack frame would be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 0 • (gen))</span></p><p class="c4"><span class="c2">in @1233</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">invoking the generator. This would resume the previous stack, so </span><span class="c25">n</span><span class="c2">&nbsp;would be set to 1, and the next iteration of the loop would run, which would</span></p><p class="c3"><span class="c2"></span></p><ol class="c118" start="1"><li class="pcalibre27 c119"><span class="calibre3">Store the generator’s stack (which, conceptually, is exactly the same&mdash;only the value of </span><span class="c25">n</span><span class="c2">&nbsp;has changed, but that is in the environment), and</span></li><li class="pcalibre27 c119"><span class="calibre3">return the new value of </span><span class="c25">n</span><span class="calibre3">&nbsp;(i.e., </span><span class="c25">1</span><span class="c2">) to the top-level stack.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This would result in </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(+ 0 1 •)</span></p><p class="c4"><span class="c2">in @1233</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">repeating the above process, and hence producing </span><span class="c25">3</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-35">
<h2 class="c21" id="calibre_link-242"><span class="c2">A Richer Example</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Using what we have learned, let us consider another Python example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">def nats():</span></p><p class="c4"><span class="c34">&nbsp; n = 0</span></p><p class="c4"><span class="c34">&nbsp; while True:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; yield n</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n += 1</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">def odds():</span></p><p class="c4"><span class="c34">&nbsp; ns = nats()</span></p><p class="c4"><span class="c34">&nbsp; while True:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n = next(ns)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; if n % 2:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; yield n</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">g = odds()</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">next(g) + next(g) + next(g)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This program has two distinct generator creators: the one we’ve already seen for natural numbers, and one more that filters the natural numbers to produce only odd numbers.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We can now think of control proceeding as follows. First, we make an instance of </span><span class="c25">odds</span><span class="calibre3">&nbsp;and bind it to </span><span class="c25">g</span><span class="calibre3">. This immediately creates an instance of </span><span class="c25">nats</span><span class="calibre3">&nbsp;and binds it (within the instance of </span><span class="c25">odds</span><span class="calibre3">) to </span><span class="c25">ns</span><span class="c2">. Now all our generators are set up and ready to compute.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We now begin the infinite loop in </span><span class="c25">odds</span><span class="c2">. This calls the natural number generator. At this point, the odd number generator’s local stack looks like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">while True:</span></p><p class="c4"><span class="c34">&nbsp; n = •</span></p><p class="c4"><span class="c34">&nbsp; if n % 2:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; yield n</span></p><p class="c4"><span class="calibre3">in an environment where </span><span class="c25">ns</span><span class="calibre3">&nbsp;is bound to a generator and </span><span class="c25">n</span><span class="c2">&nbsp;is uninitialized</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Because we have called a generator, not a function, computation now runs in that generator’s own stack. This is the natural number generator, which we have already studied. It binds </span><span class="c25">n</span><span class="calibre3">&nbsp;to </span><span class="c25">0</span><span class="calibre3">&nbsp;and then </span><span class="c25">yield</span><span class="c2">s, storing its local stack&mdash;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">while True:</span></p><p class="c4"><span class="c34">&nbsp; •</span></p><p class="c4"><span class="c34">&nbsp; n += 1</span></p><p class="c4"><span class="calibre3">in an environment where </span><span class="c25">n</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">0</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">&mdash;and returning </span><span class="c25">0</span><span class="c2">&nbsp;to the odd number generator.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This resumes the odd generator’s stack. This binds n to 0 and performs the comparison. It fails, continuing the loop body:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n = next(ns)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; if n % 2:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; yield n</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we are again ready to invoke the natural number generator. The odd number generator’s </span><span class="c6">local</span><span class="calibre3">&nbsp;stack is unchanged from before (same context, same environment, except this time the environment does have a binding for </span><span class="c25">n</span><span class="calibre3">, to </span><span class="c25">0</span><span class="c2">). Meanwhile, the natural’s generator resumes from</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">while True:</span></p><p class="c4"><span class="c34">&nbsp; •</span></p><p class="c4"><span class="c34">&nbsp; n += 1</span></p><p class="c4"><span class="calibre3">in an environment where </span><span class="c25">n</span><span class="calibre3">&nbsp;is bound to </span><span class="c25">0</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This increments </span><span class="c25">n</span><span class="c2">&nbsp;and resumes the loop body:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; yield n</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n += 1</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This immediately causes it to yield </span><span class="c25">1</span><span class="c2">, leaving the stack</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">while True:</span></p><p class="c4"><span class="c34">&nbsp; •</span></p><p class="c4"><span class="c34">&nbsp; n += 1</span></p><p class="c4"><span class="calibre3">in an environment where </span><span class="c25">n</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">1</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This resumes the odd generator’s stack. This binds </span><span class="c25">n</span><span class="calibre3">&nbsp;to </span><span class="c25">1</span><span class="c2">, so the conditional succeeds. Therefore, the stack at the point of yielding becomes</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; while True:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n = next(ns)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; if n % 2:</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; •</span></p><p class="c4"><span class="calibre3">in an environment where </span><span class="c25">ns</span><span class="calibre3">&nbsp;is bound to a generator and </span><span class="c25">n</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">1</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This completes the first call to </span><span class="c25">next(g)</span><span class="c2">, enabling the top-level stack frame to have the context</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">1 + • + next(g)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">From this, we can see the next two computations will produce </span><span class="c25">3</span><span class="calibre3">&nbsp;and </span><span class="c25">5</span><span class="calibre3">, and hence the total of </span><span class="c25">9</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-67">
<h1 class="c20" id="calibre_link-83"><span class="c2">Laziness</span></h1><h2 class="c21" id="calibre_link-243"><span class="c2">Evaluation Strategies</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Back when we began to study evaluation [</span><span class="c15"><a class="c10" href="#calibre_link-68">👉</a></span><span class="calibre3">], we saw that we had a choice when performing evaluation. During function application, we could substitute the actual parameter as an </span><span class="c6">expression</span><span class="calibre3">&nbsp;or as a </span><span class="c6">value</span><span class="c2">. At that time, we indicated that SMoL is eager. Now we will investigate the other option, laziness.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider the following program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(deffun (f x)</span></p><p class="c4"><span class="c34">&nbsp; (g (+ x x)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(deffun (g y)</span></p><p class="c4"><span class="c34">&nbsp; (h (* y 2)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(deffun (h x)</span></p><p class="c4"><span class="c34">&nbsp; (+ x 5))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(f (+ 2 3))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">When run eagerly in the Stacker, we see calls like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre28"><img alt="" src="images/000000.png" title="" class="calibre29" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and the environment contents look like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre30"><img alt="" src="images/000018.png" title="" class="calibre31" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Both the call and the environment reinforce that parameters are evaluated </span><span class="c6">before</span><span class="calibre3">&nbsp;the function body begins to execute, so names are bound to </span><span class="c6">values</span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-379">
<h2 class="c21" id="calibre_link-244"><span class="c2">Why Lazy Evaluation</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Suppose, instead, we evaluate this lazily. The evaluation would look like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (f (+ 2 3))</span></p><p class="c4"><span class="c34">→ (g (+ (+ 2 3) (+ 2 3)))</span></p><p class="c4"><span class="c34">→ (h (* (+ (+ 2 3) (+ 2 3))) 2))</span></p><p class="c4"><span class="c34">→ (+ (* (+ (+ 2 3) (+ 2 3))) 2) 5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A natural question might be, why bother doing this? </span></p><p class="c3"><span class="c2"></span></p><ol class="c120" start="1"><li class="pcalibre28 c121"><span class="calibre3">A reason people often cite is that it can save time, in that we don’t need to evaluate parameters we don’t need. For instance, suppose we have<br class="calibre" /><br class="calibre" /></span><span class="c25">(deffun (f x y z)<br class="calibre" /> &nbsp;(if (zero? x)<br class="calibre" /> &nbsp; &nbsp; &nbsp;y<br class="calibre" /> &nbsp; &nbsp; &nbsp;z))<br class="calibre" /><br class="calibre" /></span><span class="c2">and we call f with two expensive-to-compute parameters in the last two positions. In an eager language, we have evaluated both whether we want to or not. In a lazy language, we only evaluate the one we need. As we will see below, this is actually not a very compelling argument.<br class="calibre" /></span></li><li class="pcalibre28 c121"><span class="calibre3">A second reason is that it enables us to add new, non-eager constructs to the language through functions. Consider </span><span class="c25">if</span><span class="calibre3">: in an eager language it can’t be a function because the whole point of </span><span class="c25">if</span><span class="c2">&nbsp;is to not evaluate one of the branches (which would become parameters that are evaluated). Again, this argument has somewhat limited merit: we have seen how we can add such constructs using macros, which can do a great deal more as well.<br class="calibre" /></span></li><li class="pcalibre28 c121"><span class="calibre3">The most interesting reason is probably that </span><span class="c6">the set of equations that govern the language changes</span><span class="calibre3">. Consider the following. Suppose we have the expressions </span><span class="c25">E</span><span class="calibre3">&nbsp;and </span><span class="c25">(lambda (x) (E x))</span><span class="calibre3">. Are they the “same”? It would seem, intuitively, that they are. Suppose </span><span class="c25">E</span><span class="calibre3">&nbsp;is a function. In any setting where we apply </span><span class="c25">E</span><span class="calibre3">&nbsp;to a parameter, the second expression does exactly the same: it takes that parameter, binds it to </span><span class="c25">x</span><span class="calibre3">, and then applies </span><span class="c25">E</span><span class="calibre3">&nbsp;to </span><span class="c25">x</span><span class="calibre3">, which has the same effect.<br class="calibre" /><br class="calibre" />However, note that </span><span class="c25">E</span><span class="calibre3">&nbsp;may not be a function! It could be a </span><span class="c25">print</span><span class="calibre3">&nbsp;statement,</span><span class="c25">&nbsp;(/ 1 0)</span><span class="calibre3">, and so on. In those cases, </span><span class="c25">E</span><span class="calibre3">&nbsp;evaluates right away and has some observable effect, but the version “hidden under the </span><span class="c25">lambda</span><span class="c2">” will not until it is used.<br class="calibre" /><br class="calibre" />Why does this matter? It matters because many parts of programming implementations and tools want to replace some terms with other terms. An optimizing compiler does this (replacing a term with an equivalent one that is better by whatever optimizing criterion is in use), as do program refactoring engines, and more. Thus, the more terms that can be replaced, or the fewer conditions under which terms can be replaced, the better. Lazy languages allow more terms to be replaced.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology: </span><span class="c2">This equivalence is called “rule eta” (η).</span></p><p class="c43"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology: </span><span class="calibre3">You may see some people say that lazy languages have “referential transparency”. If you ask them to define it, they may say something like “you can replace equals with equals”. Think about that for a moment: you can </span><span class="c6">always</span><span class="calibre3">&nbsp;replace equals with equals. That is (by some definitions) literally what equality </span><span class="c6">means</span><span class="c2">: two things are equal exactly when you can replace one with the other. So that phrase tells us nothing. In fact, every language has some degree of “referential transparency”: you can always replace some things with other equivalent things. In lazy languages, the set of things you can replace is usually bigger: the referential transparency relation is larger. That’s all.<br class="calibre" /></span></p><ol class="c22" start="4"><li class="pcalibre28 c121"><span class="c2">One very important, practical reason is to create potentially-infinite data structures. See the example on streams below.<br class="calibre" /></span></li><li class="pcalibre28 c121"><span class="calibre3">More fundamentally, the famous paper </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://www.cse.chalmers.se/~rjmh/Papers/whyfp.html&amp;sa=D&amp;source=editors&amp;ust=1695232021569949&amp;usg=AOvVaw13ypvMWgaZXeEPuILJzYCX">Why Functional Programming Matters</a></span><span class="calibre3">&nbsp;argues that laziness is a </span><span class="c6">modularity</span><span class="c2">&nbsp;concept, and develops this argument through several beautiful examples.</span></li></ol></div>

<div class="c" id="calibre_link-283">
<h2 class="c21" id="calibre_link-245"><span class="c2">Strictness Points</span></h2><p class="c4"><span class="c2">Coming back to our example from earlier: when we run such a program in a language with lazy evaluation, when, if ever, does all this arithmetic resolve and print a value?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Before we answer that question, let us also observe that sometimes programs can’t really defer decisions indefinitely. For instance, consider this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(deffun (f x)</span></p><p class="c4"><span class="c34">&nbsp; (if (even? x)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 7</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 11))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(f (+ 2 3))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What happens when we try to evaluate it? Presumably substitution reduces this to</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(if (even? (+ 2 3))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; 7</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; 11)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and now what? Presumably that could be considered “the answer”, but that doesn’t seem very useful; and in real programs, these terms would just grow larger and larger. Furthermore, suppose the program were</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(deffun (fact n)</span></p><p class="c4"><span class="c34">&nbsp; (if (zero? n)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (* n (fact (- n 1)))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(fact 5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can certainly produce as an answer</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (if (zero? 5)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (* 5 (fact (- 5 1)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">but…then what? And for that matter, what is </span><span class="c25">fact</span><span class="c2">&nbsp;in this response? This does not seem like a very useful programming language.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Instead, lazy programming languages define certain points in the language as </span><span class="c6">strictness</span><span class="calibre3">&nbsp;points, which are points where expressions are forced to compute and produce an answer. Different choices of strictness points will result in languages that behave slightly differently. Conventionally, the following are considered </span><span class="c6">useful</span><span class="c2">&nbsp;strictness points:</span></p><p class="c3"><span class="c2"></span></p><ol class="c122" start="1"><li class="c123 pcalibre29"><span class="c2">The conditional portion of a conditional expression. This enables the language to determine which branch to take and which branch to ignore.</span></li><li class="c123 pcalibre29"><span class="c2">Arithmetic. This avoids long chains of computations building up.</span></li><li class="c123 pcalibre29"><span class="c2">The printer in an interactive environment. This makes the environment useful.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">All three of these are </span><span class="c6">pragmatic</span><span class="c2">&nbsp;choices. Notice that our first example above concerned the top-level printer, while the second example has to do with conditionals.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Because of these strictness points, a typical lazy language will in fact compute the programs we have seen above very similarly to an eager language. To get to something that really differentiates eagerness from laziness, we need to get to richer programs.</span></p></div>

<div class="c" id="calibre_link-355">
<h2 class="c21" id="calibre_link-246"><span class="c2">Evaluating Without Substitution</span></h2><p class="c4"><span class="c2">Above, we saw how we can think of lazy evaluation using substitution. While this is a useful mental model, as we have seen in earlier interpreters, we don’t really want to use substitution as our implementation strategy. That involves repeatedly rewriting program source, which is not how our interpreter worked.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So let’s say we don’t pass the value but instead “the expression”. Does it mean the above sequence becomes this?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (f (+ 2 3))</span></p><p class="c4"><span class="c25">→ (g (+ x x))</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">(+ 2 3)</span></p><p class="c4"><span class="c25">→ (h (* y 2))</span><span class="calibre3">&nbsp;where </span><span class="c25">y</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">(+ (+ 2 3) (+ 2 3)))</span></p><p class="c4"><span class="c25">→ (+ x 5)</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">(* (+ (+ 2 3) (+ 2 3)) 2)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">In fact, even this isn’t quite right. It should rather be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&nbsp; (f (+ 2 3))</span></p><p class="c4"><span class="c25">→ (g (+ x x))</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is bound to </span><span class="c34">(+ 2 3)</span></p><p class="c4"><span class="c25">→ (h (* y 2))</span><span class="calibre3">&nbsp;where </span><span class="c25">y</span><span class="calibre3">&nbsp;is bound to </span><span class="c25">(+ x x))</span><span class="calibre3">&nbsp;whose </span><span class="c25">x</span><span class="calibre3">&nbsp;is </span><span class="c34">(+ 2 3)</span></p><p class="c4"><span class="c25">→ (+ x 5)</span><span class="calibre3">&nbsp;where </span><span class="c25">x</span><span class="calibre3">&nbsp;is bound to </span><span class="c25">(* y 2)</span><span class="calibre3">&nbsp;whose </span><span class="c25">y</span><span class="calibre3">&nbsp;is </span><span class="c25">(+ x x))</span><span class="calibre3">&nbsp;whose </span><span class="c25">x</span><span class="calibre3">&nbsp;is </span><span class="c34">(+ 2 3)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c2">In other words, we want to pass the unevaluated expression…but you can probably see where this is going! If we’re not careful, we will end up with dynamic scope. Even setting that aside, we can’t just pass the expression on its own, because when we eventually get a strictness point, we simply will have no idea what value a variable resolves to.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">However, the solution also presents itself very naturally. We don’t just pass an expression, we pass along its corresponding environment. An expression and environment combine to form a…closure! Of course, this closure does not take any parameters; its only job is to </span><span class="c6">suspend the evaluation of the expression</span><span class="calibre3">&nbsp;until we reach a strictness point, and at that point, </span><span class="c6">evaluate it in the right environment</span><span class="c2">. Fortunately, we don’t need to do any new work here; closure application already does it for us.</span></p></div>

<div class="c" id="calibre_link-63">
<h2 class="c21" id="calibre_link-247"><span class="c2">Laziness Via Closures: Beyond Numbers</span></h2><p class="c4"><span class="calibre3">Laziness becomes more interesting when we consider data structures. Conventionally, data constructors are </span><span class="c6">not</span><span class="calibre3">&nbsp;strict, so their arguments are not evaluated eagerly. We can illustrate this using lists, though technically we will be constructing </span><span class="c6">streams</span><span class="c2">&nbsp;(which are infinite, as opposed to lists, which are finite).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First, read about streams represented using closures:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/func-as-data.html%23%2528part._streams-from-funs%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021577933&amp;usg=AOvVaw3xFcgFEVIzH5OuDVgtWddP">https://dcic-world.org/2022-08-28/func-as-data.html#%28part._streams-from-funs%29</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What would the same code look like in a language that was already lazy?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To experiment with that, we’ll now use the Racket language</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">#lang lazy</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define ones (cons 1 ones))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (nats-from n)</span></p><p class="c4"><span class="c34">&nbsp; (cons n (nats-from (add1 n))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define nats (nats-from 0))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (take n s)</span></p><p class="c4"><span class="c34">&nbsp; (if (zero? n)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; empty</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (cons (first s) (take (sub1 n) (rest s)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Observe how some of these values print:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; ones</span></p><p class="c4"><span class="c34">#&lt;promise:ones&gt;</span></p><p class="c4"><span class="c34">&gt; nats</span></p><p class="c4"><span class="c34">#&lt;promise:nats&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The word “promise” means these are </span><span class="c6">thunks</span><span class="calibre3">&nbsp;that represent the stream. To view the thunk’s content, we need to “force” the “promise”, which we do using the </span><span class="c25">!</span><span class="c2">&nbsp;operator:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (! ones)</span></p><p class="c4"><span class="c34">#0='(1 . #&lt;promise!#0#&gt;)</span></p><p class="c4"><span class="c34">&gt; (! nats)</span></p><p class="c4"><span class="c34">'(0 . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In the case of </span><span class="c25">ones</span><span class="calibre3">, Racket is telling us that the rest of the stream is the </span><span class="c6">same</span><span class="calibre3">&nbsp;stream as the one we are viewing: i.e., it’s a cyclic stream. For </span><span class="c25">nats</span><span class="calibre3">, it tells us that the first element is </span><span class="c25">0</span><span class="c2">, followed by another promise. We can explore these streams a bit further:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (! (rest ones))</span></p><p class="c4"><span class="c34">#0='(1 . #&lt;promise!#0#&gt;)</span></p><p class="c4"><span class="c34">&gt; (! (rest (rest (rest ones))))</span></p><p class="c4"><span class="c34">#0='(1 . #&lt;promise!#0#&gt;)</span></p><p class="c4"><span class="c34">&gt; (! (rest nats))</span></p><p class="c4"><span class="c34">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c4"><span class="c34">&gt; (! (rest (rest (rest nats))))</span></p><p class="c4"><span class="c34">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Unsurprisingly, </span><span class="c25">ones</span><span class="calibre3">&nbsp;does not change. But with </span><span class="c25">nats</span><span class="calibre3">, as we explore more of the stream, we run into more thunks. This is where </span><span class="c25">take</span><span class="calibre3">&nbsp;is useful: it gives us a finite prefix of the potentially infinite stream. Unfortunately, that also seems to just produce more thunks, and it seems like we would need to laboriously apply </span><span class="c25">!</span><span class="c2">&nbsp;to each part:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (take 10 ones)</span></p><p class="c4"><span class="c34">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c4"><span class="c34">&gt; (take 10 nats)</span></p><p class="c4"><span class="c34">'(#&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt; . #&lt;promise:...e/pkgs/lazy/base.rkt:299:29&gt;)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">For situations like this, where we </span><span class="c6">know</span><span class="calibre3">&nbsp;the output is going to be finite, we might want to resolve all the thunks. For this, Lazy Racket provides </span><span class="c25">!!</span><span class="c2">, which recursively applies strictness to all contained thunks:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (!! (take 10 ones))</span></p><p class="c4"><span class="c34">'(1 1 1 1 1 1 1 1 1 1)</span></p><p class="c4"><span class="c34">&gt; (!! (take 10 nats))</span></p><p class="c4"><span class="c34">'(0 1 2 3 4 5 6 7 8 9)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Sure enough, we get the expected answer.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise:</span><span class="calibre3">&nbsp;What happens if we apply </span><span class="c25">!!</span><span class="calibre3">&nbsp;to </span><span class="c25">ones</span><span class="calibre3">&nbsp;and to </span><span class="c25">nats</span><span class="c2">? Try it out, and explain what you see.</span></p></div>

<div class="c" id="calibre_link-333">
<h2 class="c21" id="calibre_link-248"><span class="c2">Tracing Laziness</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Another way to understand laziness is to study the encoding of streams in the Stacker. Here is the code:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang stacker/smol/hof</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(deffun (lz-first s) (left s))</span></p><p class="c4"><span class="c34">(deffun (lz-rest s) ((right s)))</span></p><p class="c4"><span class="c34">(deffun (take n s)</span></p><p class="c4"><span class="c34">&nbsp; (if (equal? n 0)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; empty</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (cons (lz-first s) (take (- n 1) (lz-rest s)))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(defvar ones (mpair 1 (λ () ones)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(deffun (nats-from n)</span></p><p class="c4"><span class="c34">&nbsp; (mpair n (λ () (nats-from (+ n 1)))))</span></p><p class="c4"><span class="c34">(defvar nats (nats-from 0))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now run each of</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(take 3 ones)</span></p><p class="c4"><span class="c34">(take 3 nats)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and study </span><span class="c6">when</span><span class="calibre3">&nbsp;evaluation happens and </span><span class="c6">what is being held on to by the closures</span><span class="calibre3">. (You may find it helpful to view just one of these at a time: the definition and use of </span><span class="c25">ones</span><span class="calibre3">, and separately of </span><span class="c25">nats</span><span class="calibre3">&nbsp;and </span><span class="c25">nats-from</span><span class="c2">.)</span></p></div>

<div class="c" id="calibre_link-36">
<h2 class="c21" id="calibre_link-249"><span class="c2">Laziness and Side-Effects</span></h2><p class="c4"><span class="c2">Given the (potential) benefits of lazy evaluation, why is laziness not more widely used?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The problem is that laziness makes it much harder to predict what will happen in programs that use state. Therefore, popular lazy languages do not have state, or have it in very controlled forms. (This is not a bad thing! State </span><span class="c6">should</span><span class="c2">&nbsp;only be used in very controlled ways, and Haskell, for instance, has very interesting designs that help with that. But programmers have traditionally expected to have unfettered access to state.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider, for instance, the following pair of functions:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (f x y)</span></p><p class="c4"><span class="c34">&nbsp; (g x y))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (g x y)</span></p><p class="c4"><span class="c34">&nbsp; (if (zero? (random 2)) x y))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">On their own, they seem harmless. However, now consider this call:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(f (print "X") (print "Y"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In an eager language, we know both strings would be printed right away. However, in a lazy language, only one will, and we cannot tell which one. To understand which, we can no longer treat </span><span class="c25">f</span><span class="calibre3">&nbsp;as an abstraction but instead have to peer into its implementation, which in turn forces us to examine the source of </span><span class="c25">g</span><span class="c2">&nbsp;as well. We would have to examine every call, and track all the strictness points along the way, to determine which effects will occur and when. Here is another example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define n 0)</span></p><p class="c4"><span class="c34">(f (set! n (add1 n)) (set! n (sub1 n)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Again, if we ran this eagerly, we know </span><span class="c25">n</span><span class="calibre3">&nbsp;would be set back to </span><span class="c25">0</span><span class="calibre3">&nbsp;before the body of </span><span class="c25">f</span><span class="calibre3">&nbsp;even begins to evaluate. In lazy evaluation, we cannot be sure what value </span><span class="c25">n</span><span class="calibre3">&nbsp;will have: it could be </span><span class="c25">-1</span><span class="calibre3">&nbsp;or </span><span class="c25">1</span><span class="calibre3">. Furthermore if, tomorrow, </span><span class="c25">g</span><span class="c2">&nbsp;were altered to be</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (g x y)</span></p><p class="c4"><span class="c34">&nbsp; (if (zero? (random 2)) "X" "Y"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">then </span><span class="c25">n</span><span class="calibre3">&nbsp;remains </span><span class="c25">0</span><span class="c2">&mdash;but we can’t know without examining its code!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">A natural reaction to reading these programs might be, “Don’t do that!” That is in fact an entirely legitimate reaction. The problem is not laziness: it’s the interaction between laziness and state. As we deprecate the use of unfettered state in programming, that increases the potential for laziness. Still, there are other situations&mdash;like errors&mdash;that we cannot avoid, and that can stay latent under lazy evaluation.</span></p></div>

<div class="c" id="calibre_link-46">
<h2 class="c21" id="calibre_link-250"><span class="c2">Caching Results</span></h2><p class="c4"><span class="calibre3">If we use lazy programming without side effects, we get a nice benefit: each expression always produces the same result. In that case, we don’t ever have to recompute an expression; we can just store its result and reuse it on subsequent accesses. That is, we can </span><span class="c6">cache</span><span class="c2">&nbsp;the result, enabling us to trade space for time.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside: </span><span class="calibre3">If you are not familiar with trading space for time in computation&mdash;as found in techniques such as memoization and dynamic programming&mdash;see DCIC:<br class="calibre" /></span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://dcic-world.org/2022-08-28/part_advtopics.html%23%2528part._avoid-recomp%2529&amp;sa=D&amp;source=editors&amp;ust=1695232021588822&amp;usg=AOvVaw1pcTCRspVLqsEkkFNFbtyj">https://dcic-world.org/2022-08-28/part_advtopics.html#%28part._avoid-recomp%29</a></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There are, however, two kinds of result caching one can perform.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">One is what happens in Lazy Racket, where each expression’s result is cached locally. This means that if the same source </span><span class="c6">location</span><span class="c2">&nbsp;is evaluated multiple times, the cached value can be reused. Other implementation strategies can look for the same expression even in a dynamic setting (as happens, for instance, in a Fibonacci function, which dynamically generates sub-problems). This requires a rather different implementation approach, but can yield even bigger time-space trade-offs.</span></p></div>

<div class="c" id="calibre_link-353">
<h2 class="c21" id="calibre_link-251"><span class="c2">Space Consumption</span></h2><p class="c4"><span class="c2">The ability to automatically memoize computation seems to show even more benefit to making lazy evaluation a default. Why not do it?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">One problem is that lazy evaluation can often take up significant amounts of space, </span><span class="c6">beyond</span><span class="c2">&nbsp;the space consumed by memoization. To understand this, consider this squaring function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (sq x)</span></p><p class="c4"><span class="c34">&nbsp; (* x x))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">Because we are evaluating lazily, </span><span class="c25">x</span><span class="calibre3">&nbsp;is bound to an </span><span class="c6">expression</span><span class="c2">&nbsp;represented as a closure. Now suppose our program looks like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define v (make-vector 1000 0))</span></p><p class="c4"><span class="c34">(sq (vector-ref v 2))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and beyond this we make no further reference to </span><span class="c25">v</span><span class="calibre3">. In an eager language, we would extract the second element of </span><span class="c25">v</span><span class="calibre3">&nbsp;and can reclaim all the remaining storage. But in a lazy language, the </span><span class="c6">entire vector</span><span class="c2">&nbsp;needs to stay alive until the last use of the closure that refers to it. Seemingly straightforward programs that have an intuitive space model in an eager language can have much more subtle and complicated space models in lazy programming. Observe that the issue above has nothing to do with memoization; it’s inherent in laziness.</span></p></div>

<div class="c" id="calibre_link-23">
<h2 class="c21" id="calibre_link-252"><span class="c2">Laziness in Eagerness</span></h2><p class="c4"><span class="calibre3">As a result of these issues, laziness has not gained popularity as a default option. At the same time, it is very useful in some settings. As we have seen above, we can always </span><span class="c6">simulate</span><span class="calibre3">&nbsp;laziness by using thunks. This can, however, be syntactically unwieldy, so some languages provide syntactic support for it. In languages like Racket, for instance, </span><span class="c25">delay</span><span class="calibre3">&nbsp;is a syntactic form that thunks its expression, and </span><span class="c25">force</span><span class="c2">&nbsp;is a function that evaluates it (caching the result).</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-307">
<h1 class="c20" id="calibre_link-253"><span class="c2">Control on the Web</span></h1><h2 class="c21" id="calibre_link-254"><span class="c2">Server-Side Programming</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider a program like this:</span></p><p class="c3"><span class="c124"></span></p><p class="c4"><span class="c124">print(read("First number") + read("Second number")) </span></p><p class="c3"><span class="c124"></span></p><p class="c4"><span class="calibre3">Imagine we were to run this program on a traditional command-line operating system. What happens when we call </span><span class="c25">read</span><span class="calibre3">? The operating system’s </span><span class="c6">synchronous</span><span class="calibre3">&nbsp;input-reading commands are invoked: synchronous meaning that the program suspends its execution&mdash;that is, the stack stays intact&mdash;waiting for the user to respond (if ever they do), and when they do, the program’s stack resumes, with the value typed in by the user becoming the value returned by </span><span class="c25">read</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This seems so straightforward that we might never think twice about how remarkable this ability is. To understand that, we should try to run this program on the Web. When we do, we run headlong into a central problem on the Web: that there is no such thing as a “</span><span class="c125">read</span><span class="c2">” operation. Why not?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">On the Web, a hypothetical </span><span class="c25">read</span><span class="calibre3">&nbsp;function can certainly send the prompt to the client. In principle, it should then wait for the client to respond with a value, which it returns. However, the </span><span class="c6">stateless</span><span class="calibre3">&nbsp;nature of the Web means that this can’t happen: the program has to terminate. This is an </span><span class="c6">asynchronous</span><span class="c2">&nbsp;operation. When the user responds (if they ever do), there is no computation waiting to go back to.</span></p><h3 class="c67" id="calibre_link-255"><span class="c68">Recording Contexts</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Therefore, a Web computation has to be arranged in a very different way. The programmer must manually remember the rest of the computation, and store it somewhere. For instance, we would break up the above program in the following way: what is going to be done next:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c124">read("First number")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and what is waiting for the result:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c124">print(• + read("Second number")) </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">(This is, of course, our old friend, a context.) But whereas the context is implicit on the program’s stack, because the program must terminate, the context needs to be written out explicitly. Of course, • is not a program operation; rather, we can think of the context as a function of one argument:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">lam(•</span><span class="c126">1</span><span class="c125">): print(•</span><span class="c126">1</span><span class="c125">&nbsp;+ read("Second number")) </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">and this is the function that is stored in a way associated with the outgoing prompt. Then, when (if) the user responds, their response value is bound to </span><span class="c125">•</span><span class="c126">1</span><span class="calibre3">, allowing the program to resume. Suppose, for instance, the user types </span><span class="c25">5</span><span class="c2">. Then this program effectively becomes</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">print(5 + read("Second number"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This needs to also perform a Web interaction, so we again split it into what must happen now</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">read("Second number")</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and what is waiting for the result:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">print(5 + •)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which we can represent as a function:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">lam(•</span><span class="c126">2</span><span class="c125">): print(5 + •</span><span class="c126">2</span><span class="c125">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">If and when the user resumes, this function is applied to the value they supply, and the result prints as we would expect.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This explanation glosses over some important details. Real program evaluation, as we have seen, does not proceed by rewriting programs, so the second function is not really</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">lam(•</span><span class="c126">2</span><span class="c125">): print(5 + •</span><span class="c126">2</span><span class="c125">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">but rather a </span><span class="c6">closure</span><span class="c2">&nbsp;with the body</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c125">lam(•</span><span class="c126">2</span><span class="c125">): print(•</span><span class="c126">1</span><span class="c125">&nbsp;+ •</span><span class="c126">2</span><span class="c125">)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">closed over an environment where </span><span class="c125">•</span><span class="c126">1</span><span class="calibre3">&nbsp;is bound to </span><span class="c125">5</span><span class="calibre3">. Getting into these details is interesting from a Web architecture perspective, but for us, all we care about is that </span><span class="c6">contexts must be saved and restored</span><span class="c2">.</span></p><h3 class="c67" id="calibre_link-256"><span class="c68">Simulating in the Stacker</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can simulate the above using the Stacker, provided we forego the input operation and pretend it always returns some constant:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang stacker/smol/hof</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(deffun (get-number s)</span></p><p class="c4"><span class="c34">&nbsp; 5)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(+ (get-number "first") (get-number "second"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">At the point of the second call, we see that the state looks like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre32"><img alt="" src="images/000011.png" title="" class="calibre33" /></span></p></div>

<div class="c" id="calibre_link-293">
<h2 class="c21" id="calibre_link-257"><span class="c2">Client-Side Termination</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">On the client-side Web, in JavaScript, we see the same phenomenon, but for a completely different reason. Imagine we write a factorial computation in JavaScript:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">function fact(n) {</span></p><p class="c4"><span class="c34">&nbsp; ans = 1;</span></p><p class="c4"><span class="c34">&nbsp; while (n != 0) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; ans = ans * n;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n = n - 1;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; return ans;</span></p><p class="c4"><span class="c34">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Notice that the loop checks for </span><span class="c25">n != 0</span><span class="calibre3">&nbsp;and not </span><span class="c25">n &gt; 0</span><span class="c2">, so if we put this in a Web page and run it, the program will in principle run forever:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&lt;script type="application/javascript"&gt;</span></p><p class="c4"><span class="c34">function fact(n) {</span></p><p class="c4"><span class="c34">&nbsp; ans = 1;</span></p><p class="c4"><span class="c34">&nbsp; while (n != 0) {</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; ans = ans * n;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n = n - 1;</span></p><p class="c4"><span class="c34">&nbsp; }</span></p><p class="c4"><span class="c34">&nbsp; return ans;</span></p><p class="c4"><span class="c34">}</span></p><p class="c4"><span class="c34">function show() {</span></p><p class="c4"><span class="c34">&nbsp; window.alert('here');</span></p><p class="c4"><span class="c34">&nbsp; ans = fact(-1);</span></p><p class="c4"><span class="c34">&nbsp; window.alert(ans);</span></p><p class="c4"><span class="c34">&nbsp; document.getElementById('answer').innerHTML = ans;</span></p><p class="c4"><span class="c34">&nbsp; </span></p><p class="c4"><span class="c34">}</span></p><p class="c4"><span class="c34">&lt;/script&gt;</span></p><p class="c4"><span class="c34">&lt;/head&gt;</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&lt;body&gt;</span></p><p class="c4"><span class="c34">&lt;button onclick="show()"&gt;Click me&lt;/button&gt;</span></p><p class="c4"><span class="c34">&lt;div id="answer"&gt;&lt;/div&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">However, this creates a problem: the JavaScript virtual machine runs only one computation at a time, and the same JavaScript virtual machine also manages the page and the browser’s components. Therefore, if the program inside a page goes into an infinite loop, the entire page stops being responsive. For this reason, after a little while, the browser will pop up a window offering to kill the computation.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">There is a solution to this in JavaScript, but it is hardly elegant. The programmer creates a closure&mdash;called a </span><span class="c6">callback</span><span class="c2">&mdash;that represents the rest of the computation. The programmer then calls</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">setTimeout(C, 0)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">or, in more modern programs,</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">requestAnimationFrame(C)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">(though the former version perhaps makes a bit clearer what is happening), where </span><span class="c25">C</span><span class="calibre3">&nbsp;is the callback. This creates an event to run </span><span class="c25">C</span><span class="calibre3">&nbsp;as soon as possible (after </span><span class="c25">0</span><span class="calibre3">&nbsp;units of time). The programmer then&mdash;does this sound familiar?&mdash;</span><span class="c6">terminates the program</span><span class="calibre3">. This returns control to the JavaScript virtual machine. It runs any other pending events, then arrives at this event, which it runs immediately&mdash;i.e., it “calls back” into the computation using </span><span class="c25">C</span><span class="calibre3">. If </span><span class="c25">C</span><span class="c2">&nbsp;was constructed correctly, then this properly resumes the computation, as if it had never halted. Phew!</span></p></div>

<div class="c" id="calibre_link-0">
<h2 class="c21" id="calibre_link-258"><span class="c2">Abstracting the Problem</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Thus, we have the same problem on both the server and client sides of the Web. The reasons are very different, but the net effect is the same: the programmer has to manually keep track of information that needs to persist, store it somewhere, halt the computation to return control to whatever called it and, when resumed, fetch information back from storage; all this code must run exactly as if an interruption had never occurred.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This programming quandary is not new. Back in the early days of computing, programmers had to manually keep track of where in memory values resided; then we got compilers that did this for us. Then we had to manually keep track of allocation on the heap to later reclaim it; then we got garbage collectors to do this for us. The history of programming languages is full of tasks that programmers did manually until we learned to create language constructs and compilers that could do these automatically. It would be nice if we could do the same here to reduce the burden of writing such programs.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To study these phenomena better, it would be helpful if we could abstract away from the details of servers, clients, JavaScript, Web pages, timeouts, and so on, and examine the phenomenon in its essence.</span></p><h3 class="c67" id="calibre_link-259"><span class="c68">Using Closures</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We can simulate the solution by assuming a new primitive, </span><span class="c25">get-number/k</span><span class="calibre3">. Instead of taking one argument, the prompt string, it also takes a second argument. This second argument is a closure that represents the </span><span class="c6">rest</span><span class="calibre3">&nbsp;of the computation&mdash;i.e., it’s the stack represented as a closure. This function binds that closure to a variable, </span><span class="c25">resume</span><span class="c2">, and then…does nothing:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(defvar yielder #false)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(deffun (get-number/k s rest)</span></p><p class="c4"><span class="c34">&nbsp; (set! resume rest))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Recall that we want the program to invoke this function and then halt; all remaining computation&mdash;the context&mdash;needs to be in the second parameter given to </span><span class="c25">get-number/k</span><span class="c2">. Thus, our program now looks like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(get-number/k "first"</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (λ (•1)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (get-number/k "second"</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (λ (•2)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (+ •1 •2)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology: </span><span class="calibre3">The second argument&mdash;embodying the entire rest of the computation&mdash;is called the </span><span class="c6">continuation</span><span class="calibre3">, and it’s traditional to use the letter </span><span class="c25">k</span><span class="c2">&nbsp;for it.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Terminology: </span><span class="calibre3">The program structure above has been turned inside-out: instead of the first operation being innermost and last operation outermost, the first one is outermost and the last one is innermost. This unwieldy program structure has a name: </span><span class="c6">inversion of control</span><span class="calibre3">. Instead of the client calling the helper function whose values it wants (in this case, </span><span class="c25">get-number</span><span class="calibre3">), the helper function (in this case </span><span class="c25">get-number/k</span><span class="c2">) calls the client. This leads to an unnatural, unwieldy, and error-prone programming style.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Sure enough, when we run this program, it just…halts with no output. It is instructive to look at the state of the program when it ends:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre34"><img alt="" src="images/000017.png" title="" class="calibre35" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Notice that </span><span class="c25">resume</span><span class="c2">&nbsp;is bound to a function that is awaiting a number. If we invoke it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(resume 5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">then our state (unfortunately, we had to re-run the program) becomes:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre36"><img alt="" src="images/000013.png" title="" class="calibre37" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that resume is now bound to a closure whose environment remembers the value of </span><span class="c25">•1</span><span class="c2">. If we now resume again:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(resume 7)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">the “program” halts naturally, with an output of </span><span class="c25">12</span><span class="c2">! (We use quotes around “program” because we have really fragmented our simple program into three: one that gets the prompts for the first input, one that remembers that value and prompts for the second, and the third that sums those two values.)</span></p><h3 class="c67" id="calibre_link-260"><span class="c68">Using Racket</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp;It turns out that Racket also has tools for manipulating continuations.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Imagine we have two tabs in DrRacket. In the first (let’s suppose we save it as </span><span class="c25">"yielder.rkt"</span><span class="c2">) we have the following mysterious program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang racket</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(provide yield resume)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define resumer #false)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (yield)</span></p><p class="c4"><span class="c34">&nbsp; (let/cc k</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (set! resumer k)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (raise 'yield)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (resume)</span></p><p class="c4"><span class="c34">&nbsp; (resumer 'dummy))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The operation </span><span class="c25">let/cc</span><span class="calibre3">&nbsp;binds the named variable (here, </span><span class="c25">k</span><span class="c2">) to a continuation value: it turns the current stack into a value that can be treated as a function.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In another tab, we will write a simple program that pretends to be our long-running computation: a factorial function. We can run this directly in Racket, of course. But </span><span class="c25">fact</span><span class="calibre3">&nbsp;could run for a very long time, depending on the input; so following the rules of JavaScript, we want it to halt periodically, let’s say every time </span><span class="c25">n</span><span class="calibre3">&nbsp;is divisible by </span><span class="c25">5</span><span class="c2">&nbsp;(i.e., roughly every five iterations). That is, we would like to run:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang racket</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(require "yielder.rkt")</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (fact n)</span></p><p class="c4"><span class="c34">&nbsp; (if (= n 0)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; 1</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (if (zero? (modulo n 5))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (begin</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (yield)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* n (fact (- n 1))))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (* n (fact (- n 1))))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">where </span><span class="c25">(yield)</span><span class="calibre3">&nbsp;makes it pause in a way that, when we run </span><span class="c25">(resume)</span><span class="c2">, the computation will pick up exactly where it left off. Indeed, we see the following outcome:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (fact 7)</span></p><p class="c4"><span class="c34">uncaught exception: 'yield</span></p><p class="c4"><span class="c34">&gt; (resume)</span></p><p class="c4"><span class="c34">5040</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The first time it yields is when </span><span class="c25">n</span><span class="calibre3">&nbsp;is </span><span class="c25">5</span><span class="calibre3">. Yielding, in this case, means </span><span class="c6">terminating</span><span class="c2">&nbsp;the computation using the Racket exception mechanism. Resuming somehow causes computation to continue and run to completion but, remarkably, it produces the exact same answer as if computation had never halted at all!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that thanks to the use of </span><span class="c25">let/cc</span><span class="calibre3">, we have been able to invert the inverted control, i.e., write the program in what is called </span><span class="c6">direct style</span><span class="calibre3">. The language has taken care of storing and restoring the computation without the user program having to do it manually. Thus, continuations are useful tools for inverting inverted control. We will also see another language mechanism that does this: </span><span class="c59"><a class="c10" href="https://www.google.com/url?q=https://docs.google.com/document/d/1ECyFV88K-jU-i0qHLfUNjbIYthChzpcjZ0eiostD3d8/edit%23&amp;sa=D&amp;source=editors&amp;ust=1695232021608622&amp;usg=AOvVaw1WfaeEjiDupGmDBj0AuHdK">Non-SMoL: Reactivity</a></span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-351">
<h2 class="c21" id="calibre_link-261"><span class="c2">Yielding on a Web Server</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The Racket Web server has a special primitive that does just this for the Web. We’ll build it up in stages. First, we’ll use a special Racket language, designed to make it easier to write server-side Web programs:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang web-server/insta</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Programs in this language must have a “main” function, called </span><span class="c25">start</span><span class="calibre3">, which is given an initial request (whatever information is provided when we first run the computation). This function is then written assuming a convenient fiction: the existence of a function </span><span class="c25">get-number</span><span class="calibre3">&nbsp;that will print a prompt, send out a Web page, </span><span class="c6">wait for its response</span><span class="c2">, extract the value entered, and return it as a number:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (start req)</span></p><p class="c4"><span class="c25">&nbsp; (let ([result </span><span class="c53">(+ (get-number "first") (get-number "second"))</span><span class="c34">])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (response/xexpr</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;`(html (body (p "The result is " ,(number-&gt;string result)))))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If we can make this fiction reality, then we can write a program like the above: it calls </span><span class="c25">get-number</span><span class="c2">&nbsp;in a “deep” context, twice, adds the results, and then converts the result into a string to embed it into a Web page.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The question, of course, is how such a function can exist. First, we have to discuss some Web mechanics. When we create a Web form, it needs a field called the </span><span class="c25">action</span><span class="calibre3">, which holds a URL. When the user submits the form, the browser bundles up the information entered into the fields of the form and sends them&mdash;effectively, as a set of key-value pairs&mdash;</span><span class="c6">to the URL</span><span class="c2">, i.e., to the server, requesting it to run the program at that URL and provide the key-value pairs to that program.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Therefore, we can see that we’ve turned the problem of suspending the program’s execution into one of being able to fill in this URL with something meaningful. If the URL can somehow correspond to the stack, then perhaps the stack (and hence the computation) can be restored, and can be provided with these key-value pairs, from which the program can extract the required information.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The “secret sauce” that the Racket Web server provides is a primitive called </span><span class="c25">send/suspend</span><span class="c2">. It does the following:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">It takes a </span><span class="c6">single-argument function</span><span class="c2">&nbsp;as a parameter. </span></li><li class="pcalibre c23"><span class="c2">It records the current stack as a value.</span></li><li class="pcalibre c23"><span class="c2">It stores this stack in a hash-table, associated with a unique, unguessable string.</span></li><li class="pcalibre c23"><span class="c2">It turns this string into a URL.</span></li><li class="pcalibre c23"><span class="calibre3">It then </span><span class="c6">calls</span><span class="c2">&nbsp;the given function with this URL string.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The resulting function can then use this URL string as the </span><span class="c25">action</span><span class="c2">&nbsp;field of the form.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Aside:</span><span class="c2">&nbsp;This is not the only way to use it. The URL could also, for instance, be sent in an email message. This is a handy way to validate email addresses. Because the URL is unique and unguessable, the only way for someone to resume the computation would be to receive that URL, i.e., to have access to the email address. Thus, resuming the computation can be thought of as having validated the email address (assuming, of course, that an intruder is not reading emails and clicking on validation links that the email’s owner would not have clicked on).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">So here is an actual working implementation of get-number:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define (get-number which)</span></p><p class="c4"><span class="c34">&nbsp; (define title (format "What is the ~a number?" which))</span></p><p class="c4"><span class="c34">&nbsp; (define req</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (send/suspend</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(lambda (k-url)</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c127">(response/xexpr</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c128">`(html (head (title ,title))</span></p><p class="c4"><span class="c101">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(body</span></p><p class="c4"><span class="c101">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (form ([action ,</span><span class="c129">k-url</span><span class="c128">])</span></p><p class="c4"><span class="c128">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ,title ": "</span></p><p class="c4"><span class="c128">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (input ([name "number"]))</span></p><p class="c4"><span class="c101">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (input ([type "submit"]))))</span><span class="c130">)</span><span class="c34">))))</span></p><p class="c4"><span class="c34">&nbsp; (string-&gt;number</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; </span><span class="c127">(extract-binding/single 'number</span></p><p class="c4"><span class="c130">&nbsp; &nbsp; &nbsp; (request-bindings req))</span><span class="c34">))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that most of this function is just </span><span class="c131">HTML</span><span class="calibre3">&nbsp;and </span><span class="c132">API</span><span class="calibre3">&nbsp;bookkeeping. We have to construct the Web page with the relevant components. When (if) the computation resumes, it returns with the key-value pairs sent from the form. These are bound to </span><span class="c25">req</span><span class="c2">. From there, it’s a simple matter of extracting the right value using the APIs.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">And that’s it! That gives us a full, working program.</span></p></div>

<div class="c" id="calibre_link-49">
<h2 class="c21" id="calibre_link-262"><span class="c2">Interaction with State</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s think about how all this interacts with state. Let’s write a simple Web program that simply counts how many times we submitted a form.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">One natural way to write it is as follows. We’ll have a mutable variable, </span><span class="c25">count</span><span class="c2">, that keeps the count. We’ll have a page that shows the current count and provides the user a button. When they click it, computation resumes; the resumed computation increments the count, and loops:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang web-server/insta</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define count 0)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (show-count)</span></p><p class="c4"><span class="c34">&nbsp; (send/suspend</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(lambda (k-url)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(response/xexpr</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; `(html (head "Counter")</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(body</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (p () "The current count is " ,(number-&gt;string count))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (form ([action ,k-url])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (input ([type "submit"])))))))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (start req)</span></p><p class="c4"><span class="c34">&nbsp; (show-count)</span></p><p class="c4"><span class="c34">&nbsp; (set! count (add1 count))</span></p><p class="c4"><span class="c34">&nbsp; (start 'dummy))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We’ll call it the </span><span class="c6">stateful counter</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">This works as you might expect. </span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But now let’s think about a different way to write this same program. Instead of using a global mutable variable, we could instead keep the count as a local variable and functionally update it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">#lang web-server/insta</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (show-count count)</span></p><p class="c4"><span class="c34">&nbsp; (send/suspend</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp;(lambda (k-url)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp;(response/xexpr</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; `(html (head "Counter")</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(body</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (p () "The current count is " ,(number-&gt;string count))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (form ([action ,k-url])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (input ([type "submit"])))))))))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (loop count)</span></p><p class="c4"><span class="c34">&nbsp; (show-count count)</span></p><p class="c4"><span class="c34">&nbsp; (loop (add1 count)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define (start req)</span></p><p class="c4"><span class="c34">&nbsp; (loop 0))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We’ll call this the </span><span class="c6">functional counter</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This, too, works as you would expect. And it works the same as the previous program. And yet, somehow, these programs seem to be different. Are they in fact </span><span class="c6">exactly</span><span class="c2">&nbsp;the same?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">They’re not!</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="c2">Map out the stacks, environments, and stores to simulate how these programs would run.</span></p></div>

<div class="c" id="calibre_link-40">
<h2 class="c21" id="calibre_link-263"><span class="c2">Web Interactions</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In conventional, desktop software, concurrency is an artifact of the </span><span class="c6">program</span><span class="c2">. If the program is not concurrent, we can’t really force it to behave concurrently.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Not so on the Web. There, we can copy URLs, duplicate them, and replay them. Therefore, the same program state can be invoked multiple times, returned to, and so on.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider the following sequence of interactions on the Web:</span></p><p class="c3"><span class="c2"></span></p><ol class="c133" start="1"><li class="c134 pcalibre30"><span class="c2">A user visits a travel Web site.</span></li><li class="c134 pcalibre30"><span class="c2">They enter a city and search for hotels.</span></li><li class="c134 pcalibre30"><span class="c2">They are given a list of hotels, L.</span></li><li class="c134 pcalibre30"><span class="c2">They click on one of the hotels, say L1.</span></li><li class="c134 pcalibre30"><span class="c2">This takes them to a page for L1.</span></li><li class="c134 pcalibre30"><span class="c2">They click the reservation link.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">They obtain a reservation at L1. All this seems perfectly normal.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now suppose instead they do the following:</span></p><p class="c3"><span class="c2"></span></p><ol class="c135" start="1"><li class="pcalibre31 pcalibre32"><span class="c2">A user visits a travel Web site.</span></li><li class="pcalibre31 pcalibre32"><span class="c2">They enter a city and search for hotels.</span></li><li class="pcalibre31 pcalibre32"><span class="c2">They are given a list of hotels, L.</span></li><li class="pcalibre31 pcalibre32"><span class="calibre3">They click on one of the hotels, say L1, in a </span><span class="c6">new</span><span class="c2">&nbsp;tab.</span></li><li class="pcalibre31 pcalibre32"><span class="calibre3">They click on another of the hotels, say L2, in </span><span class="c6">another</span><span class="c2">&nbsp;new tab.</span></li><li class="pcalibre31 pcalibre32"><span class="c2">They go back to L1’s tab.</span></li><li class="pcalibre31 pcalibre32"><span class="c2">They click the reservation link.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Think about these two questions:</span></p><ol class="c136" start="1"><li class="pcalibre33 pcalibre34"><span class="calibre3">At which hotel would you </span><span class="c6">like</span><span class="c2">&nbsp;the reservation to be made: L1 or L2?</span></li><li class="pcalibre33 pcalibre34"><span class="calibre3">Where do you </span><span class="c6">expect</span><span class="c2">&nbsp;the site to make the reservation: L1 or L2?</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Naturally, we would </span><span class="c6">expect</span><span class="calibre3">&nbsp;the reservation at L1, because we clicked on the reservation link from L1’s page. But on many Web sites, you used to get a reservation at L</span><span class="c6">2</span><span class="calibre3">, not L</span><span class="c6">1</span><span class="c2">. This suggests that there is some interaction between the two tabs: specifically, there seems to be mutable state, the “current hotel”, that is shared between the two tabs. Opening a hotel’s page sets this. Thus, this is initially set to L1; the new tab for L2 sets it to L2; when we return to L1’s tab and make a reservation, this act reads the mutable state, which makes the reservation at the “current hotel”, namely L2.</span></p></div>

<div class="c" id="calibre_link-318">
<h2 class="c21" id="calibre_link-264"><span class="c2">Returning to the Counters</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s return to the two counters, armed with the ideas from the interactions above.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Run the stateful counter program and submit, say, 3 times. After that, the page will list the count as 3, and the URL will look something like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">http://localhost:51264/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2097639995)%22))?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now copy this URL, create a </span><span class="c6">new</span><span class="calibre3">&nbsp;tab, paste it, and enter. This runs the computation associated with this URL. Perhaps surprisingly, this shows the count as 4. Now go back to the previous tab and submit the form. That tab now shows a count not of 4 but of 5. Return to the second tab and submit; it now shows 6. The stacks help us see why: every return mutates the </span><span class="c6">same</span><span class="calibre3">&nbsp;</span><span class="c25">counter</span><span class="c2">&nbsp;variable.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now repeat the same process with the functional counter. After 3 submissions, we get a URL like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">http://localhost:51379/servlets/standalone.rkt;((%22k%22%20.%20%22(1%203%2028533532)%22))?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">which seems very similar. Now copy </span><span class="c6">this</span><span class="c2">&nbsp;URL into a new tab, and repeat the interactions above.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What we see is very different. Each tab has its own local “memory”, much as we expected of the pages on the travel Web site. The continuation does not mutate a single shared variable, but rather makes a new </span><span class="c6">call</span><span class="c2">&nbsp;to loop, which creates a new binding that is distinct from previous bindings. Each time we submit we make another call, which makes another stack frame and its corresponding environment frame, which are distinct.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This distinction between creating a single, shared, mutable variable and creating distinct variables that each have their own immutable value should be familiar: it’s the exact same problem that we saw in the Loops assignment [</span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/courses/cs173/2022/loops.html&amp;sa=D&amp;source=editors&amp;ust=1695232021622985&amp;usg=AOvVaw0xjaprMcAAUZTQQEvCfWVs">https://cs.brown.edu/courses/cs173/2022/loops.html</a></span><span class="c2">].</span></p></div>

<div class="c" id="calibre_link-308">
<h2 class="c21" id="calibre_link-265"><span class="c2">Mapping between Web and Programming Language Features</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Interestingly, there is a deep connection between features of Web programs and ideas from programming languages. On the Web, we have</span></p><p class="c3"><span class="c2"></span></p><a id="calibre_link-404"></a><a id="calibre_link-405"></a><table class="c37"><tbody class="calibre13"><tr class="c38"><td class="c69" colspan="1" rowspan="1"><p class="c44"><span class="c2"></span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c40"><span class="c41">Server-side</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c40"><span class="c41">Client-side</span></p></td></tr><tr class="c38"><td class="c69" colspan="1" rowspan="1"><p class="c137"><span class="c41">Mutable</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c42"><span class="c2">Database (page-independent)</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c42"><span class="c2">Cookie (page-independent)</span></p></td></tr><tr class="c38"><td class="c69" colspan="1" rowspan="1"><p class="c137"><span class="c41">Immutable</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c44"><span class="c2"></span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c42"><span class="c2">Hidden field (page-specific)</span></p></td></tr></tbody></table><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe that when we have a single mutable entry, the net result will be that all pages that share it will end up seeing the effects of each other. Therefore, the bad travel Web site pattern is inherent in this style of programming. Unfortunately, Web APIs make cookies very easy to use, leading to programs following this bad pattern. In contrast, when we have immutable data that is specific to the page (the field is on the page…it’s just hidden), then each page keeps its own information separate from all the other pages. Notice also that hidden fields are key-value mappings. Therefore, a collection of hidden fields is an </span><span class="c6">environment</span><span class="calibre3">. Since a page also has a reference to code to run, a page with hidden fields is effectively a </span><span class="c6">closure</span><span class="calibre3">! In contrast, a page with shared mutable state is using the </span><span class="c6">store</span><span class="calibre3">&nbsp;(or </span><span class="c6">heap</span><span class="c2">). The Racket Web server simply makes these implicit ideas explicit.</span></p></div>

<div class="c" id="calibre_link-375">
<h2 class="c21" id="calibre_link-266"><span class="c2">Readings</span></h2><p class="c4"><span class="c2">The work in this chapter is elaborated in several papers:</span></p><ul class="c22"><li class="pcalibre c23"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mfgkf-web-restructuring-cps-journal/&amp;sa=D&amp;source=editors&amp;ust=1695232021626503&amp;usg=AOvVaw0dteFuRcMEar0kOBZ7ejqS">Automatically Restructuring Programs for the Web</a></span></li><li class="pcalibre c23"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/kfgf-model-web-inter-error/&amp;sa=D&amp;source=editors&amp;ust=1695232021627009&amp;usg=AOvVaw0OKynkecNBanIitj-dtIoI">Modeling Web Interactions and Errors</a></span></li><li class="pcalibre c23"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/&amp;sa=D&amp;source=editors&amp;ust=1695232021627310&amp;usg=AOvVaw2VVyDnhdzHGBVmpsp7j3xb">Implementation and Use of the PLT Scheme Web Server</a></span></li><li class="pcalibre c23"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/bnpkg-stopify/&amp;sa=D&amp;source=editors&amp;ust=1695232021627644&amp;usg=AOvVaw0ZxiewB1AmM3Se5hWPXBGb">Putting in All the Stops: Execution Control for JavaScript</a></span></li></ul><p class="c3"><span class="c2"></span></p></div>

<div class="c" id="calibre_link-288">
<h1 class="c20" id="calibre_link-267"><span class="c2">Reactivity</span></h1><p class="c4"><span class="calibre3">We learned early on that SMoL languages evaluate formal arguments at a function call. We then saw laziness as a contrast to this: an argument is evaluated </span><span class="c6">zero</span><span class="c2">&nbsp;times at the call, and is maybe only evaluated later. (Of course, if the result is not cached, it may be evaluated many times.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now we will see another contrast to SMoL, focusing this time on the function call itself: where what syntactically looks like a single function call can actually be numerous, even an unbounded number.</span></p></div>

<div class="c" id="calibre_link-315">
<h2 class="c21" id="calibre_link-268"><span class="c2">GUIs through Callbacks</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">To do so, it helps to remind ourselves of the evaluation model in most graphical applications, these days embodied by JavaScript. Suppose we want to make a Web page with a timer that counts up every second, and whose value resets when we click on a Reset button:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre38"><img alt="" src="images/000014.png" title="" class="calibre39" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">One version of the JavaScript code would look as follows:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&lt;script type="text/javascript"&gt;</span></p><p class="c4"><span class="c34">var timerID = null;</span></p><p class="c4"><span class="c34">var elapsedTime = 0;</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">function doEverySecond() {</span></p><p class="c4"><span class="c34">&nbsp; elapsedTime += 1;</span></p><p class="c4"><span class="c34">&nbsp; document.getElementById('curTime').innerHTML = elapsedTime; }</span></p><p class="c4"><span class="c34">function startTimer() {</span></p><p class="c4"><span class="c34">&nbsp; timerId = setInterval(doEverySecond, 1000); }</span></p><p class="c4"><span class="c34">function resetElapsed() {</span></p><p class="c4"><span class="c34">&nbsp; elapsedTime = 0; }</span></p><p class="c4"><span class="c34">&lt;/script&gt;</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&lt;body onload="startTimer()"&gt;</span></p><p class="c4"><span class="c34">&nbsp; &lt;center&gt;Elapsed time&lt;/center&gt;</span></p><p class="c4"><span class="c34">&nbsp; &lt;center&gt;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &lt;div id='curTime'&gt;&nbsp;&lt;/div&gt;</span></p><p class="c4"><span class="c34">&nbsp; &lt;/center&gt;</span></p><p class="c4"><span class="c34">&nbsp; &lt;center&gt;</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &lt;input id="reset" type="button" value="Reset" onclick="resetElapsed()" /&gt;</span></p><p class="c4"><span class="c34">&nbsp; &lt;/center&gt;</span></p><p class="c4"><span class="c34">&lt;/body&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">There are three parts to the logic here:</span></p><p class="c3"><span class="c2"></span></p><ol class="c138" start="1"><li class="pcalibre36 pcalibre35"><span class="c2">Updating the elapsed time every second.</span></li><li class="pcalibre36 pcalibre35"><span class="c2">Resetting the timer on a button-press.</span></li><li class="pcalibre36 pcalibre35"><span class="c2">Initiating the computation.</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These are accomplished as follows:</span></p><p class="c3"><span class="c2"></span></p><ol class="c139" start="1"><li class="pcalibre37 pcalibre38"><span class="calibre3">When loaded, the Web page invokes </span><span class="c25">startTimer</span><span class="c2">. </span></li><li class="pcalibre37 pcalibre38"><span class="calibre3">We use </span><span class="c25">elapsedTime</span><span class="calibre3">&nbsp;to record how much time has elapsed, and create a timer, referenced by </span><span class="c25">timerID</span><span class="calibre3">. This installs a timer (and records a reference to it in case we need it later, which we don’t in this program) that runs every second (1000 milliseconds). Whenever the timer goes off, it invokes the function </span><span class="c25">doEverySecond</span><span class="c2">. That function increments the elapsed time, and writes the current value into the Web page.</span></li><li class="pcalibre37 pcalibre38"><span class="calibre3">Finally, the reset button has </span><span class="c25">resetElapsed</span><span class="calibre3">&nbsp;as its callback. This resets the value of </span><span class="c25">elapsedTime</span><span class="c2">, whose updated value is then shown the next time the display is updated. (In principle, we might want to update the display in this callback too.)</span></li></ol><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Let us suppose we were given this program to maintain. We want to ask a simple question: what is the value of the Web page’s </span><span class="c25">curTime</span><span class="c2">&nbsp;element? Observe the reasoning we have to perform:</span></p><ul class="c22"><li class="pcalibre5 c23"><span class="calibre3">It is set inside </span><span class="c25">doEverySecond</span><span class="c2">.</span></li><li class="pcalibre5 c23"><span class="calibre3">It’s set to the value of </span><span class="c25">elapsedTime</span><span class="c2">.</span></li><li class="pcalibre5 c23"><span class="c2">That value is incremented in the previous statement.</span></li><li class="pcalibre5 c23"><span class="calibre3">That increment takes place every time </span><span class="c25">doEverySecond</span><span class="c2">&nbsp;is called.</span></li><li class="pcalibre5 c23"><span class="calibre3">That call takes place in the first argument of </span><span class="c25">setInterval</span><span class="c2">.</span></li><li class="pcalibre5 c23"><span class="calibre3">That event is installed by </span><span class="c25">startTimer</span><span class="c2">.</span></li><li class="pcalibre5 c23"><span class="c2">Which is called on page load.</span></li><li class="pcalibre5 c23"><span class="calibre3">Wait. We also need to know the initial value, where </span><span class="c25">elapsedTime</span><span class="c2">&nbsp;is declared.</span></li><li class="pcalibre5 c23"><span class="c2">Oh, but wait. We also see it reset.</span></li><li class="pcalibre5 c23"><span class="calibre3">That happens inside </span><span class="c25">resetElapsed</span><span class="c2">.</span></li><li class="pcalibre5 c23"><span class="c2">Which is called when the button is clicked.</span></li></ul><p class="c4"><span class="c2">In short, we have to follow all this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre40"><img alt="" src="images/000015.png" title="" class="calibre41" /></span></p></div>

<div class="c" id="calibre_link-22">
<h2 class="c21" id="calibre_link-269"><span class="c2">Reactivity</span></h2><p class="c4"><span class="calibre3">There is an alternative, called </span><span class="c6">functional-reactive programming</span><span class="calibre3">&nbsp;(FRP). We will see one particular instantiation, which is baked into Racket with an interesting user interface. The language is called FrTime. For technical reasons, we will not use a </span><span class="c25">#lang</span><span class="c2">&nbsp;but rather choose it from the Language menu (under Other Languages).</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Do Now! </span><span class="c2">Below are some expressions whose output is best experienced in DrRacket. Run them in DrRacket and see the output for yourself!</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">FrTime essentially provides a basic version of Racket, so basic computations work exactly as we would expect:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; 5</span></p><p class="c4"><span class="c34">5</span></p><p class="c4"><span class="c34">&gt; (+ 2 3)</span></p><p class="c4"><span class="c34">5</span></p><p class="c4"><span class="c34">&gt; (string-length "hello")</span></p><p class="c4"><span class="c34">5</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can also ask for values like the current system time:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (current-seconds)</span></p><p class="c4"><span class="c34">1668363009</span></p><p class="c4"><span class="c34">&gt; (add1 (current-seconds))</span></p><p class="c4"><span class="c34">1668363010</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">You will likely see a different value than the one shown above, because you are not reading this at the same time as when I wrote it. But that is a problem: indeed, even I am seeing a </span><span class="c6">stale</span><span class="c2">&nbsp;value, because time has passed since I ran the command.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The typical solution is to use callbacks. We can imagine a timer that takes a callback, which is called every time the time changes. However, this would invert control, which is exactly what happens in our timer example.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">But FrTime, following the principles of FRP, provides a special kind of value. Try it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; seconds</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">See what happens? </span><span class="c25">seconds</span><span class="calibre3">&nbsp;is a </span><span class="c6">time-varying value</span><span class="c2">: i.e., it is (technically: evaluates to) a value, but what it evaluates to changes over time. (It changes, in fact, every second.)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Naturally, we should ask: if </span><span class="c25">seconds</span><span class="c2">&nbsp;evaluates to a value, we can use it in expressions, so what happens if we write expressions like these?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (add1 seconds)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (modulo seconds 10)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Notice that both </span><span class="c25">add1</span><span class="calibre3">&nbsp;and </span><span class="c25">modulo</span><span class="calibre3">&nbsp;demand that their first argument be numbers. </span><span class="c25">seconds</span><span class="c2">&nbsp;is a time-varying value that at every point in time is a number. Therefore, these expressions are well-typed, producing no errors, and in fact produce the answer we might expect (but also perhaps be a bit surprised by).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Nothing prevents us from writing even longer expressions. Consider the function </span><span class="c25">build-list</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (build-list 5 (lambda (n) n))</span></p><p class="c4"><span class="c34">'(0 1 2 3 4)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What happens if we now use a time-varying value?</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; (build-list (modulo seconds 10) (lambda (n) n))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Or build an even deeper expression:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">&gt; (length (build-list (modulo seconds 10) (lambda (n) n)))</span></p></div>

<div class="c" id="calibre_link-50">
<h2 class="c21" id="calibre_link-270"><span class="c2">How Evaluation Works</span></h2><h3 class="c67" id="calibre_link-271"><span class="c68">Dataflow Graphs</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">What happens when we write these expressions? FrTime rewrites the way function applications happen. If </span><span class="c6">no</span><span class="calibre3">&nbsp;argument to a function is time-varying, then the function evaluates just as it would in regular Racket. If, however, any of its arguments is time-varying, then FrTime constructs a node in a </span><span class="c6">dataflow</span><span class="c2">&nbsp;graph. This node is attached to the nodes corresponding to the time-varying arguments.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Consider this expression:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c25">(length (build-list (modulo seconds 10) (lambda (n) n)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The act of calling length evaluates its argument, which is a call to build-list, which evaluates its two arguments. The second argument is an ordinary closure. The first argument is a call to modulo, which evaluates </span><span class="c6">its</span><span class="c2">&nbsp;two arguments. Again, the second argument is just a number, but the first argument is time-varying. Consequently, this turns into a dataflow graph node, where we use the context notation to indicate where time-varying values go:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">&nbsp;</span><span class="calibre42"><img alt="" src="images/000007.png" title="" class="calibre43" /></span></p><p class="c4"><span class="calibre3">Because </span><span class="c25">(modulo seconds 10)</span><span class="c2">&nbsp;evaluates to a time-varying value, so does the next outer expression:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre44"><img alt="" src="images/000010.png" title="" class="calibre45" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and finally the outermost one:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre46"><img alt="" src="images/000016.png" title="" class="calibre47" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The program source therefore evaluates to this dataflow graph. Now, each time-varying value may evaluate at different rates and for different reasons. </span><span class="c25">seconds</span><span class="calibre3">, naturally, updates once every second. When it does, its updated value is </span><span class="c6">pushed</span><span class="c2">&nbsp;to all the nodes that depend on it, which update their value and push their values, and so on all the way through the graph. Finally, values may arrive at the REPL, which in FrTime is designed to display them automatically updating.</span></p><h3 class="c67" id="calibre_link-272"><span class="c68">Rewriting Application</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Essentially, we can think of reactivity being implemented by rewriting how function application works. In the simplest case, imagine we have a function application, </span><span class="c25">(f a)</span><span class="calibre3">. Let us assume that </span><span class="c25">f</span><span class="calibre3">&nbsp;is itself not a time-varying value. Then, this application rewrites </span><span class="c25">(f a)</span><span class="c2">&nbsp;as</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(let ([a-value a])</span></p><p class="c4"><span class="c34">&nbsp; (if (time-varying? a-value)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; …</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (f a-value)))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We will return to the </span><span class="c25">…</span><span class="calibre3">&nbsp;in a moment. Observe that this evaluates the argument expression and, if it is not currently a time-varying value, then computation proceeds exactly as it would have in regular Racket. This means that progams that don’t use time-varying values behave </span><span class="c6">exactly</span><span class="calibre3">&nbsp;as they would in Racket, so this is a </span><span class="c6">conservative</span><span class="c2">&nbsp;extension of Racket.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now let’s consider what happens if the parameter </span><span class="c6">is</span><span class="calibre3">&nbsp;time-varying. That means, instead of immediately computing an answer, we have to create a node in the dataflow graph. We can imagine a time-varying value is an object of the class </span><span class="c25">tvv%</span><span class="calibre3">&nbsp;(</span><span class="c25">tvv</span><span class="calibre3">&nbsp;for time-varying value, and </span><span class="c25">%</span><span class="calibre3">&nbsp;using the Racket convention for classes). We will first illustrate how this might be used, then show its definition. This class has two methods: </span><span class="c25">add-consumer</span><span class="calibre3">, which provides another object of </span><span class="c25">tvv%</span><span class="calibre3">&nbsp;that will receive updated values, and </span><span class="c25">update</span><span class="calibre3">, which receives updated values. We reproduce the bottom three parts of the above dataflow graph as follows and, to keep the output short, compute the remainder relative to </span><span class="c25">5</span><span class="calibre3">&nbsp;rather than </span><span class="c25">10</span><span class="c2">:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define seconds</span></p><p class="c4"><span class="c34">&nbsp; (new tvv% [updater (λ (v) v)]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In practice, </span><span class="c25">seconds</span><span class="calibre3">&nbsp;would be attached to a system timer that pushes an update every second. For simplicity, we make it an inert object that only changes when we manually call its </span><span class="c25">updater</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The remainder node now looks like this:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define mod•5</span></p><p class="c4"><span class="c34">&nbsp; (new tvv% [updater (λ (v) (modulo v 5))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That is, every time it receives a value from </span><span class="c25">seconds</span><span class="calibre3">, it computes that value </span><span class="c25">modulo</span><span class="calibre3">&nbsp;</span><span class="c25">5</span><span class="calibre3">. Of course, right now it has no way of knowing that it must listen to </span><span class="c25">seconds</span><span class="c2">; we have to register it as a consumer:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(send seconds add-consumer mod•5)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Similarly, the </span><span class="c25">build-list</span><span class="c2">&nbsp;expression creates a time-varying value object:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define bl•id</span></p><p class="c4"><span class="c34">&nbsp; (new tvv% [updater (λ (v) (build-list v (λ (n) n)))]))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">which too we must attach to its value producer:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(send mod•5 add-consumer bl•id)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Observe how the </span><span class="c25">v</span><span class="calibre3">&nbsp;parameters in </span><span class="c25">mod•5</span><span class="calibre3">&nbsp;and in </span><span class="c25">bl•id</span><span class="c2">&nbsp;correspond to the • in the dataflow graph.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Finally, just as </span><span class="c25">seconds</span><span class="calibre3">&nbsp;is a source in the graph, we will define a sink that prints results, and send values from </span><span class="c25">bl•id</span><span class="c2">&nbsp;to it:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define show</span></p><p class="c4"><span class="c34">&nbsp; (new tvv% [updater (λ (v) (println v))]))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(send bl•id add-consumer show)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Now we’re ready to test it all! If we simulate </span><span class="c25">seconds</span><span class="c2">&nbsp;updating for the first ten seconds:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(for-each (λ (n) (send seconds update n)) (range 0 10))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">we see the following output printed, just as we would expect:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">'()</span></p><p class="c4"><span class="c34">'(0)</span></p><p class="c4"><span class="c34">'(0 1)</span></p><p class="c4"><span class="c34">'(0 1 2)</span></p><p class="c4"><span class="c34">'(0 1 2 3)</span></p><p class="c4"><span class="c34">'()</span></p><p class="c4"><span class="c34">'(0)</span></p><p class="c4"><span class="c34">'(0 1)</span></p><p class="c4"><span class="c34">'(0 1 2)</span></p><p class="c4"><span class="c34">'(0 1 2 3)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So how did this work? The </span><span class="c25">tvv%</span><span class="calibre3">&nbsp;class keeps track of a list of consumers, of which above we have had only one per object. </span><span class="c25">add-consumer</span><span class="calibre3">&nbsp;merely augments this list. The </span><span class="c25">update</span><span class="calibre3">&nbsp;method receives a value, uses its </span><span class="c25">updater</span><span class="c2">&nbsp;function to compute a new current value, and broadcasts it to all of its consumers:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define tvv%</span></p><p class="c4"><span class="c34">&nbsp; (class object%</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (init updater)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (define updater-function updater)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (super-new)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (define consumers empty)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (define/public (add-consumer new-consumer)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (set! consumers (cons new-consumer consumers)))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (define/public (update pushed-value)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (let ([new-current-value (updater-function pushed-value)])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; (for-each (λ (c) (send c update new-current-value))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; consumers)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">That’s (most of) the core logic (but read on). This brings us back to the rewriting of applications: what goes in </span><span class="c25">…</span><span class="c2">? Well, we have to</span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">make a new </span><span class="c25">tvv%</span><span class="c2">&nbsp;instance</span></li><li class="pcalibre c23"><span class="calibre3">supply it an updater function that corresponds to </span><span class="c34">(f •)</span></li><li class="pcalibre c23"><span class="calibre3">registers that node as a consumer to the </span><span class="c25">tvv%</span><span class="calibre3">&nbsp;object that </span><span class="c25">a-value</span><span class="c2">&nbsp;references</span></li><li class="pcalibre c23"><span class="calibre3">return the new </span><span class="c25">tvv%</span><span class="c2">&nbsp;instance as the result of this function “application”</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="calibre3">Turn the above rewriting idea into a proper macro. If you can, turn it into the </span><span class="c25">#%app</span><span class="calibre3">&nbsp;of a </span><span class="c25">#lang</span><span class="c2">&nbsp;so that one can program a module in a FrTime-like style.</span></p><p class="c3"><span class="c2"></span></p><h3 class="c67" id="calibre_link-273"><span class="c68">Non-Linear Graphs</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The above example may be a bit misleading in suggesting that an expression must always have at most one time-varying parameter. Consider this program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(= (modulo seconds 3) (modulo seconds 5))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Its dataflow graph looks like</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre48"><img alt="" src="images/000023.png" title="" class="calibre49" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">On every update of </span><span class="c25">seconds</span><span class="calibre3">, </span><span class="c6">both</span><span class="c2">&nbsp;expressions that depend on it update, and their result flows to the equality comparison. Every 15 seconds, we would expect to see 12 consecutive false values followed by three consecutive true values, and that is what we see.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="calibre3">Does the above definition of </span><span class="c25">tvv%</span><span class="c2">&nbsp;permit non-linear graphs? Can you write the above example with it? If so, show how. If not, modify it to allow such a definition.</span></p><h3 class="c67" id="calibre_link-274"><span class="c68">Avoiding Glitches</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">These forks in the graph, however, might be a cause for concern. Let us see an even simpler example:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(&lt; seconds (add1 seconds))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="calibre3">Let us first be clear about what we expect this to produce: we want it to always be </span><span class="c25">#true</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">However, let us view how a simplistic dataflow graph evaluator might work. Here is the graph:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre50"><img alt="" src="images/000025.png" title="" class="calibre51" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Suppose the value of </span><span class="c25">seconds</span><span class="calibre3">&nbsp;updates to become 10. This value is pushed, as we would expect, to </span><span class="c6">both</span><span class="calibre3">&nbsp;its </span><span class="c6">listeners</span><span class="calibre3">. This causes the </span><span class="c25">(add1 seconds)</span><span class="calibre3">&nbsp;node to update its value from </span><span class="c25">10</span><span class="calibre3">&nbsp;to </span><span class="c25">11</span><span class="calibre3">. However, the update to </span><span class="c25">seconds</span><span class="calibre3">&nbsp;might have caused the comparison to occur immediately. At that point FrTime would be evaluating </span><span class="c25">(&lt; 10 10)</span><span class="calibre3">, which is clearly false. So for one instant this expression would evaluate to </span><span class="c25">#true</span><span class="calibre3">, before the update from </span><span class="c25">(add1 seconds)</span><span class="calibre3">&nbsp;arrives and it reverts to </span><span class="c25">#false</span><span class="calibre3">. This is called a </span><span class="c6">glitch</span><span class="calibre3">, a term borrowed from the same phenomenon in </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Glitch&amp;sa=D&amp;source=editors&amp;ust=1695232021650816&amp;usg=AOvVaw2D-DrKG6J0VAjm-pDxm4Ri">electrical circuits</a></span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Avoiding glitches is actually quite simple. Rather than updating a node in this eager manner, FrTime schedules the graph to be updated in </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Topological_sorting&amp;sa=D&amp;source=editors&amp;ust=1695232021651423&amp;usg=AOvVaw17recAG9rHgwYI9lEViEXR">topographical order</a></span><span class="calibre3">. That ensures that no node will ever see old, or “stale”, values, and the expression will evaluate correctly. Of course, we can only apply topological sorting to directed </span><span class="c6">acyclic</span><span class="c2">&nbsp;graphs, so handling cycles requires some additional work, which we do not discuss here.</span></p><p class="c3"><span class="c2"></span></p><p class="c27"><span class="c33">Exercise: </span><span class="c2">Make the above definition of non-linear graphs behave glitch-free.</span></p></div>

<div class="c" id="calibre_link-348">
<h2 class="c21" id="calibre_link-275"><span class="c2">Other Time-Varying Values</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So far we have seen only one basic time-varying value, </span><span class="c25">seconds</span><span class="calibre3">. FrTime provides many others. For instance, </span><span class="c25">mouse-pos</span><span class="c2">&nbsp;is the current position of the mouse. If we run the following program:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(require frtime/animation)</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(display-shapes</span></p><p class="c4"><span class="c34">&nbsp;(list</span></p><p class="c4"><span class="c34">&nbsp; (make-circle mouse-pos 10 "blue")))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">we see a blue circle, and it </span><span class="c6">automatically</span><span class="c2">&nbsp;follows the mouse.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">The function </span><span class="c25">display-shapes</span><span class="calibre3">&nbsp;in the FrTime animation library takes a list of shapes; above, we have only one. This function builds a list of (four) circles whose positions are determined by the mouse’s location, except each one is </span><span class="c6">delayed</span><span class="c2">, i.e., represents where the mouse used to be. (One might call this the Rhode Island mouse.) Therefore, as the mouse moves these circles appear to “follow” it around.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(display-shapes</span></p><p class="c4"><span class="c34">&nbsp;(let ([n 4])</span></p><p class="c4"><span class="c34">&nbsp; &nbsp;(build-list</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; n</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; (lambda (i)</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; (make-circle (delay-by mouse-pos (* 200 (- (- n 1) i)))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10</span></p><p class="c4"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"green")))))</span></p></div>

<div class="c" id="calibre_link-371">
<h2 class="c21" id="calibre_link-276"><span class="c2">Even More Time-Varying Values</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We have actually seen only one kind of time-varying value, called a </span><span class="c6">behavior</span><span class="c2">. There are actually two kinds of time-varying values, which is easy to see if we consider a few different kinds of stimuli from the world:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="c2">Current mouse position</span></li><li class="pcalibre c23"><span class="c2">Sequence of keystrokes</span></li><li class="pcalibre c23"><span class="c2">Current user location</span></li><li class="pcalibre c23"><span class="c2">Sequence of network responses</span></li><li class="pcalibre c23"><span class="c2">Current status of mode keys</span></li><li class="pcalibre c23"><span class="c2">Sequence of mouse-clicks</span></li><li class="pcalibre c23"><span class="c2">Current time</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Notice that several of those are “current…” and others are “sequence of…”. The former have the property that they always have a value, and the value may change at any time. The latter have the property that at any given moment they may not have a value&mdash;for instance, there may not be a “current keystroke”&mdash;and we don’t know when (or if) the next one will come, and there may be an infinite number of them. The latter are, of course, just </span><span class="c6">streams</span><span class="calibre3">, often called </span><span class="c6">event streams</span><span class="c2">.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">If we go back to our original counter example, we had both present. The elapsed time was a behavior (always has a value, which changes either when a second finishes or when a button is clicked). The sequence of button presses is, conversely, an event stream: at any given moment there may not be a press, we don’t know when or even if the next one will come, and there may be an unbounded number of them (from a very bored user). To learn more, see the papers about the design and implementation of </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ck-frtime/&amp;sa=D&amp;source=editors&amp;ust=1695232021655719&amp;usg=AOvVaw1rTfSyu1ttBqGmZrO7l9th">FrTime</a></span><span class="calibre3">, and a similar language for JavaScript called </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/mgbcgbk-flapjax/&amp;sa=D&amp;source=editors&amp;ust=1695232021656156&amp;usg=AOvVaw05OqgMykYggyiyBjsWWIJU">Flapjax</a></span><span class="c2">.</span></p></div>

<div class="c" id="calibre_link-285">
<h2 class="c21" id="calibre_link-277"><span class="c2">Returning to Our Timer</span></h2><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">We can write the original timer program using FrTime’s GUI library. Here is the program, explained.</span></p><h3 class="c67" id="calibre_link-278"><span class="c68">Elapsed Time Without Resetting</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">First we will write a simpler version that simply shows the elapsed time since the program began. To do so, we need to load the GUI library:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(require frtime/gui)</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and then we need to determine how much time has elapsed. It may be tempting to write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define init-time seconds)</span></p><p class="c4"><span class="c34">(define elapsed-time (- seconds init-time))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and then make a GUI display object that presents this (after converting the number into a string):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(make-message (number-&gt;string elapsed-time))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">When we run this, however, we get a rather disappointing display that seems to always show </span><span class="c25">0</span><span class="calibre3">. That is because that’s what we asked for! We can check this by asking for the value of </span><span class="c25">init-time</span><span class="c2">&nbsp;in the REPL:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">&gt; init-time</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">When we do, we see that it is constantly changing. But that’s what we should expect: we defined it to be the same as </span><span class="c25">seconds</span><span class="calibre3">! Instead, we need to hold on to the value of </span><span class="c25">seconds</span><span class="calibre3">&nbsp;</span><span class="c6">at the time</span><span class="calibre3">&nbsp;we started the program: i.e., we do </span><span class="c6">not</span><span class="c2">&nbsp;want it to automatically update. For that, we instead write</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define init-time (value-now seconds))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">and then the rest of the program works as we would expect.</span></p><h3 class="c67" id="calibre_link-279"><span class="c68">Adding Resets</span></h3><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Now let’s add the button. We create a button object, which returns an event stream of its clicks:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define reset-clicks (make-button "Reset"))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Every time there’s a click, we want the elapsed time to reset to </span><span class="c25">0</span><span class="calibre3">. That is, we want to keep track of when the reset occurred. Note that again we need to use </span><span class="c25">value-now</span><span class="calibre3">&nbsp;to get the time when it </span><span class="c6">occurred</span><span class="calibre3">, not the current time. We use </span><span class="c25">map-e</span><span class="c2">&nbsp;to map over event streams:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">So we have two kinds of events: the start of the program, and the clicks. We want a single behavior that reflects when these occurred: starting with when the program began, and updating whenever there’s a click. The function </span><span class="c25">switch</span><span class="c2">&nbsp;does this, “switching” the behavior’s value whenever an event occurs:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define event-times (switch click-times init-time))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">At this point, the elapsed time to show is how far the current time is from the last event:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define elapsed-time (- seconds event-times))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Visually:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre52"><img alt="" src="images/000024.png" title="" class="calibre53" /></span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Putting this all together, and adding the output directive:</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(define init-time (value-now seconds))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(define reset-clicks (make-button "Reset"))</span></p><p class="c4"><span class="c34">(define click-times (map-e (lambda (_) (value-now seconds)) reset-clicks))</span></p><p class="c4"><span class="c34">(define event-times (switch click-times init-time))</span></p><p class="c4"><span class="c34">(define elapsed-time (- seconds event-times))</span></p><p class="c3"><span class="c34"></span></p><p class="c4"><span class="c34">(make-message (number-&gt;string elapsed-time))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Observe that in this program, there are two kinds of changes that can occur:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">Another second elapses. Thus, </span><span class="c25">seconds</span><span class="calibre3">&nbsp;changes; so does </span><span class="c25">elapsed-time</span><span class="calibre3">; and so </span><span class="c25">make-message</span><span class="c2">&nbsp;updates its output.</span></li><li class="pcalibre c23"><span class="calibre3">The user clicks the button. Then </span><span class="c25">reset-clicks</span><span class="calibre3">&nbsp;has an event, so </span><span class="c25">click-times</span><span class="calibre3">&nbsp;has an event, </span><span class="c25">event-times</span><span class="calibre3">&nbsp;updates, and so does </span><span class="c25">elapsed-time</span><span class="calibre3">, thereby also causing </span><span class="c25">make-message</span><span class="c2">&nbsp;to also update its output.</span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">In both cases </span><span class="c25">elapsed-time</span><span class="calibre3">&nbsp;updates, triggering a change in the output. But there are two inputs to the subtraction in </span><span class="c25">elapsed-time</span><span class="c2">, and they update for different reasons.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">What may be lost in the above presentation, which is incremental to enhance readability, is that we actually have deeply nested expressions that we can think of algebraically. To make that clearer, here is the whole program written as a single expression, with each name replaced with the expression it was bound to (though this is almost certainly a less readable version):</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c34">(make-message (number-&gt;string</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(- seconds</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (switch</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(map-e (lambda (_) (value-now seconds))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (make-button "Reset"))</span></p><p class="c4"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(value-now seconds)))))</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">The interested reader can prove properties of the time shown based purely on the rules of algebra, perhaps even identifying a slightly unsatisfying behavior in the time shown by the timer (which was also a problem with the callback version).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This example shows that we really can compose expressions in a conventional manner </span><span class="c6">even though</span><span class="c2">&nbsp;we are writing a reactive program using a GUI library. It is worth comparing the structure of this program against the callback-based version that we started with.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://cs.brown.edu/~sk/Publications/Papers/Published/ick-adapt-oo-fwk-frp/&amp;sa=D&amp;source=editors&amp;ust=1695232021664301&amp;usg=AOvVaw1WOPAKU7HpkFtzRQxaaDl3">This paper</a></span><span class="c2">&nbsp;shows how the GUI library was given a functional-reactive interface by exploiting the encapsulation of object-oriented state.</span></p></div>

<div class="c" id="calibre_link-310">
<h1 class="c13" id="calibre_link-280"><span class="c2">•••••&nbsp;What’s Next? •••••</span></h1><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">You have just finished a detailed look at the landscape of programming languages.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">It’s a broad and rich landscape with many, many dimensions to consider.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">This book has largely eschewed programming language </span><span class="c6">theory</span><span class="c2">, because there are already many wonderful books about that. I recommend:</span></p><p class="c3"><span class="c2"></span></p><ul class="c22"><li class="pcalibre c23"><span class="calibre3">Felleisen, Findler, Flatt: </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://mitpress.mit.edu/9780262062756/semantics-engineering-with-plt-redex/&amp;sa=D&amp;source=editors&amp;ust=1695232021665409&amp;usg=AOvVaw1KqS_Jy_nK815yWIVBp7ex">Semantics Engineering with PLT Redex</a></span></li><li class="pcalibre c23"><span class="calibre3">Harper: </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/practical-foundations-programming-languages-2nd-edition?format%3DHB%26isbn%3D9781107150300&amp;sa=D&amp;source=editors&amp;ust=1695232021665792&amp;usg=AOvVaw1AAwlEjddhBK-I2YGlk71l">Practical Foundations for Programming Languages</a></span></li><li class="pcalibre c23"><span class="calibre3">Pierce: </span><span class="c24"><a class="c10" href="https://www.google.com/url?q=https://mitpress.mit.edu/9780262162098/types-and-programming-languages/&amp;sa=D&amp;source=editors&amp;ust=1695232021666106&amp;usg=AOvVaw3g2h6FqQKLiHwO8ZNmsd-O">Types and Programming Languages</a></span></li></ul><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">for three rather different, but all foundational, perspectives on the further study of the subject.</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">Equally, programming languages are more popular than ever before. Working programmers not only contribute to their development but also put a great deal of effort into understanding more advanced features and distilling them for others. Their work tends to be found on blogs or at various conferences (such as those </span><span class="c15"><a class="c10" href="https://www.google.com/url?q=https://twitter.com/ShriramKMurthi/status/1600574419914854400&amp;sa=D&amp;source=editors&amp;ust=1695232021666661&amp;usg=AOvVaw0QxljIxYwpEq2ec0JQcfOL">listed here</a></span><span class="calibre3">).</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="calibre3">We’re done! </span><span class="c2">I hope you’ve enjoyed reading this as much as I enjoyed writing it!</span></p><p class="c3"><span class="c2"></span></p><div class="calibre54"><p class="c140"><span class="c2"></span></p></div></div>

</body></html>